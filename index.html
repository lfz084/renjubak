<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="shortcut icon" href="./pic/favicon1.ico" />
  <title> 摆棋小工具</title>
  <style>
    @font-face {

      font-family: 'mHeiTi';
      src: url('./font/simhei.otf');
    }

    font {
      font-family: 微软雅黑, STHeiti, MingLiu, mHeiTi;
      font-weight: bold;
      -webkit-user-select: none;
      /* Chrome/Safari/Opera */
    }



    button {
      font-family: 微软雅黑, STHeiti, MingLiu, mHeiTi;
      -webkit-user-select: none;
      /* Chrome/Safari/Opera */
    }


    div {
      font-family: 微软雅黑, STHeiti, MingLiu, mHeiTi;
      font-weight: bolder;
      -webkit-user-select: none;
      /* Chrome/Safari/Opera */
    }

    canvas {
      -webkit-user-select: none;
      /* Chrome/Safari/Opera */
    }


    body {
      height: 100%;
      width: 100%;
      -webkit-user-select: none;
      /* Chrome/Safari/Opera */
    }
  </style>
</head>


<body>
  <script src="./script/jsPDF/jspdf.customfonts.min.js"></script>
  <script src="./script/jsPDF/msyh-bold.js"></script>
  <script src="./script/NoSleep.min.js"></script>
  <script language="javascript">
    "use strict";
    // 定制按钮，button，file，Radio，select。
    function button(parentNode, type, left, top, width, height) {

      this.parentNode = parentNode; //保存父节点;
      this.div = document.createElement("div"); //定位
      this.button = document.createElement("button"); //显示
      if (type == "select") {
        this.input = document.createElement("select"); //接受用户事件  
      }
      else {
        this.input = document.createElement("input"); //接受用户事件  
        this.input.setAttribute("type", type);
      }

      this.option = [];
      this.type = type;
      this.position = "absolute";
      this.width = width == null ? "200px" : width;
      this.height = height == null ? "150px" : height;
      this.left = left == null ? 0 : left;
      this.top = top == null ? 0 : top;
      this.color = "#333333";
      this.selectColor = "black";
      this.notChangeColor = false; // 不自动调整按钮字体颜色
      this.backgroundColor = "#f0f0f0";
      this.selectBackgroundColor = "#d0d0d0";
      /*if (this.type=="button") {
        let col = this.backgroundColor;
        this.backgroundColor = this.selectBackgroundColor;
        this.selectBackgroundColor = col;
      }*/
      this.margin = 0;
      this.outline = "none"; //去掉外框
      this.fontFamily = "微软雅黑";
      this.fontSize = parseInt(this.height) / 2.2 + "px";
      this.textAlign = "center";
      this.checked = false;
      this.borderRadius = '20px';
      this.text = ""; //未选中显示的文本
      this.text2 = ""; //选中时显示的文本

      this.isEventMove = false; // 记录 touchstart 到 touchend 中间 是否触发 touchmove;
      this.touchStart = [];

      let but = this;

      this.input.ontouchstart = function() {
        but.defaultontouchstart();
      }

      this.input.onmousedown = function() {
        but.defaultontouchstart();
      }

      this.input.ontouchcancel = function() {
        but.defaultontouchend();
      }

      this.input.ontouchleave = function() {
        but.defaultontouchend();
      }

      this.input.ontouchend = function() {
        but.defaultontouchend();
      }

      this.input.onmouseup = function() {
        but.defaultontouchend();
      }

      this.input.onchange = function() {
        but.defaultonchange();
      }

      this.input.ontouchmove = function() {
        but.defaultontouchmove();
      }


    }


    // 对 select 添加 option
    button.prototype.addOption = function(value, text) {

      if (this.type != "select") return;
      let op = document.createElement("option");

      op.setAttribute("value", value);
      op.innerHTML = text;
      this.input.appendChild(op);

    }



    button.prototype.defaultontouchstart = function() {

      this.isEventMove = false;
      this.button.style.opacity = 1;
      this.button.style.fontSize = parseInt(this.fontSize) * 0.9 + "px";
      if (this.backgroundColor != "black") {
        this.button.style.color = "black";
      }
      else {
        this.button.style.color = "#ccc";
      }
      this.button.style.backgroundColor = this.selectBackgroundColor;
      return true;
    }


    button.prototype.defaultontouchmove = function() {

      this.isEventMove = true; // 取消单击事件
      return true;
    }




    // 默认事件，
    button.prototype.defaultontouchend = function() {

      // select 要弹出菜单不能屏蔽
      if (this.type != "select") event.preventDefault();
      //   "✔  ○●",radio,checked,前面加上特殊字符。
      let s;
      let timer;
      let cancel = false; // 判断是否取消单击

      if (this.isEventMove) cancel = true; // 不触发单击事件

      // radio, checkbox 默认事件
      if ((this.type == "radio" || this.type == "checkbox") && (!cancel)) this.checked = !this.checked;

      if (this.checked) {
        // 选中的时，按钮外观
        s = this.type == "radio" ? "☞" : this.type == "checkbox" ? "✔" : "";
        s += this.text2 == "" ? this.text : this.text2;
        if (this.type == "select") {
          for (let i = 5 - s.length; i > 0; i--) {
            s = "&nbsp" + s + "&nbsp;";
          }
          s = "&nbsp;" + s + "▼";
        }
        this.button.innerHTML = s;
        this.button.style.fontSize = this.fontSize;
        this.button.style.color = this.notChangeColor ? this.color : this.selectColor;
        this.button.style.backgroundColor = this.selectBackgroundColor;
      }
      else {
        // 未选中时的外观
        if (this.type == "radio" || this.type == "checkbox" || this.type == "select") {
          timer = 0;
        }
        else {
          timer = 100;
        }
        s = this.type == "radio" ? "" : this.type == "checkbox" ? "" : "";
        s += this.text;
        if (this.type == "select") {
          for (let i = 5 - s.length; i > 0; i--) {
            s = "&nbsp" + s + "&nbsp;";
          }
          s = "&nbsp;" + s + "▼";
        }
        this.button.innerHTML = s;

        let but = this;
        if (timer) {
          setTimeout(function() {
            but.button.style.fontSize = but.fontSize;
            but.button.style.color = but.color;
            but.button.style.backgroundColor = but.backgroundColor;
          }, timer);
        }
        else
        {
          but.button.style.fontSize = but.fontSize;
          but.button.style.color = but.color;
          but.button.style.backgroundColor = but.backgroundColor;
        }


      }

      if (this.type == "file") this.input.click();
      return cancel ? false : true;
    }




    button.prototype.defaultonchange = function() {

      if (this.type != "select") return;
      let txt = this.input.options[this.input.selectedIndex].text;
      this.setText(txt);
      return true;
    }




    //移出节点
    button.prototype.hide = function() {
      let f = this.div;
      /*
      var childs = f.childNodes; 
      for(let i = childs.length - 1; i >= 0; i--)
       { 
        f.removeChild(childs[i]); 
       }
       */
      if (f.parentNode) f.parentNode.removeChild(f);


    }


    //  移动和设置大小
    button.prototype.move = function(left, top, width, height) {

      this.left = left == null ? this.left : left;
      this.top = top == null ? this.top : top;
      this.width = width == null ? this.width : width;
      this.height = height == null ? this.height : height;
      this.show();
    }


    //按钮背景色
    button.prototype.setBackgroundColor = function(color) {
      this.backgroundColor = color;
      this.button.style.backgroundColor = color;

    }



    //  设置按钮形状
    button.prototype.setBorderRadius = function(rs) {

      this.borderRadius = rs;
      this.show();

    }



    button.prototype.setColor = function(color) {

      this.color = color;
      this.selectColor = color;
      this.button.style.color = color;

    }



    //设置选定状态    
    button.prototype.setChecked = function(checked) {

      if (this.checked == (checked == true)) return;
      this.checked = checked ? true : false;
      this.setText(this.text, this.text2);

    }


    //字体
    button.prototype.setFontSize = function(fontSize) {

      this.fontSize = parseInt(fontSize) + "px";
      if (this.checked) {
        this.button.style.fontSize = parseInt(parseInt(this.fontSize) * 0.9) + "px";
      }
      else {
        this.button.style.fontSize = this.fontSize;
      }

    }



    button.prototype.setNotChangeColor = function(nc) {

      this.notChangeColor = nc;

    }



    // 給事件绑定函数
    button.prototype.setonchange = function(callbak) {

      let but = this;
      this.input.onchange = function() {
        but.defaultonchange();
        callbak(but);
      }

    }



    // 給事件绑定函数
    button.prototype.setontouchstart = function(callbak) {

      let but = this;
      this.input.ontouchstart = function() {
        if (!but.defaultontouchstart(but)) return;
        callbak(but);
      }
    }





    // 給事件绑定函数
    button.prototype.setontouchend = function(callbak) {

      let but = this;
      this.input.ontouchend = function() {
        if (!but.defaultontouchend(but)) return;
        callbak(but);
      }
      this.input.onmouseup = this.input.ontouchend;
    }


    // 设置文本
    button.prototype.setText = function(txt, txt2) {
      let s;
      this.text = txt == null ? "" : txt;
      this.text2 = txt2 == null ? "" : txt2;

      if (this.checked) {
        s = this.type == "radio" ? "☞" : this.type == "checkbox" ? "✔" : "";
        s += this.text2 == "" ? this.text : this.text2;
        this.button.innerHTML = s;
        this.button.style.fontSize = this.fontSize;
        this.button.style.color = this.notChangeColor ? this.color : this.selectColor;
        this.button.style.backgroundColor = this.selectBackgroundColor;

      }
      else {
        let timer;
        if (this.type == "radio" || this.type == "checkbox") {
          timer = 0;
        }
        else {
          timer = 100;
        }
        s = this.type == "radio" ? "" : this.type == "checkbox" ? "" : "";
        s += this.text;
        this.button.innerHTML = s;

        let but = this;
        if (timer) {
          setTimeout(function() {
            but.button.style.fontSize = but.fontSize;
            but.button.style.color = but.color;
            but.button.style.backgroundColor = but.backgroundColor;
          }, timer);
        }
        else
        {
          but.button.style.fontSize = but.fontSize;
          but.button.style.color = but.color;
          but.button.style.backgroundColor = but.backgroundColor;
        }


      }
      if (this.type == "select") {
        for (let i = 5 - s.length; i > 0; i--) {
          s = "&nbsp" + s + "&nbsp;";
        }
        s = "&nbsp;" + s + "▼";
      }
      this.button.innerHTML = s;
    }



    //显示，刷新
    button.prototype.show = function(left, top, width, height) {

      this.parentNode.appendChild(this.div);
      this.div.appendChild(this.button);
      this.div.appendChild(this.input);

      this.div.style.position = this.position;
      if (width) this.width = width;
      this.div.style.width = this.width;
      if (height) this.height = height;
      this.div.style.height = this.height;
      if (top) this.top = top;
      this.div.style.top = this.top;
      if (left) this.left = left;
      this.div.style.left = this.left;
      this.div.style.borderRadius = this.borderRadius == null ? parseInt(this.width) + "px" : this.borderRadius;

      this.div.style.borderStyle = 'solid';
      this.div.style.borderWidth = parseInt(this.width) < parseInt(this.height) ? parseInt(this.width) / 30 + "px" : parseInt(this.height) / 30 + "px";
      this.div.style.borderColor = this.selectBackgroundColor;
      //this.div.style.backgroundColor = "red"

      this.fontSize = parseInt(this.div.style.height) / 2.2 + "px";

      this.button.style.position = "relative";
      this.button.style.padding = "0px 0px 0px 0px";
      this.button.style.zIndex = this.div.style.zIndex;
      this.button.style.width = this.width;
      this.button.style.height = this.height;
      this.button.style.top = 0;
      this.button.style.left = 0;
      this.button.style.borderWidth = 0;
      this.button.style.margin = 0;
      this.button.style.borderRadius = this.div.style.borderRadius
      this.button.style.outline = 'none';
      this.button.style.textAlign = "center";
      this.button.style.lineHeight = parseInt(this.height) + "px";
      this.button.style.backgroundColor = this.backgroundColor;
      this.button.style.fontSize = this.fontSize;
      this.button.style.color = this.color;
      this.button.style.opacity = 0.9;

      this.input.style.position = "relative";
      this.input.style.zIndex = this.button.style.zIndex + 1;
      this.input.style.width = this.width;
      this.input.style.height = this.height;
      this.input.style.top = -parseInt(this.height);
      this.input.style.left = 0;
      this.input.style.borderRadius = this.div.style.borderRadius
      this.input.style.opacity = 0;

      this.setText(this.text, this.text2); // 正确显示按钮文本
      if (this.type == "select") this.defaultonchange();
    }
  </script>
  <script language="javascript">
    "use strict";
    const isTest = 0;
    //记录日志
    var logDiv = null;
    if (isTest) {
      logDiv = document.createElement("div");
      logDiv.style.position = "absolute";
      logDiv.style.borderStyle = "dashed";
      logDiv.style.borderWidth = '1px';
      //logDiv.style.borderColor = '#eee';
      logDiv.style.left = 0;
      logDiv.style.top = 0
      logDiv.style.width = 600
      logDiv.style.height = 200;
      logDiv.style.innerHTML = "AAAA";
      document.body.appendChild(logDiv);
    }

    function log(msg, color) {

      setTimeout(function() {
        if (!isTest) return;
        if (color == null) color = 'black';
        logDiv.innerHTML = "<font color=" + color + ">" + msg + "</font><br>" + logDiv.innerHTML.slice(0, 1500);
      }, 10);
    }
  </script>
  <script language="javascript">
    "use strict";
    var d = document;
    var dw = d.documentElement.clientWidth;
    var dh = d.documentElement.clientHeight;
    var cWidth = dw < dh ? dw * 0.95 : dh * 0.95;
    cWidth = cWidth < dh ? cWidth : dh;
    // dw = 2000;
    //  dh = 2000;
    var noSleep;
    var isNoSleep = false; // bodyTouchStart 防止锁屏
    var noSleepTime = 0;
    if (typeof(NoSleep) == "function") {
      noSleep = new NoSleep();
      setInterval(function() {
        if ((new Date().getTime() - noSleepTime) < 3000) {
          if (!isNoSleep) { isNoSleep = true;
            noSleep.enable(); }
        }
        else
        {
          if (isNoSleep) { isNoSleep = false;
            noSleep.disable(); }
        }
      }, 30 * 1000);
    }

    //用来保存跟踪正在发送的触摸事件

    var canvasStartTouches = [];

    var bodyStartTouches = [];

    var previousTouch = []; // 辅助判断双击

    var bodyPreviousTouch = [];

    var bodyMoveTouches = [];

    var continueSetCutDivX = 0;
    var continueSetCutDivY = 0;

    var isBodyClick = false; // 辅助判断单击

    var timerCanvasKeepTouch = null;

    var timerBodyKeepTouch = null;

    var timerContinueSetCutDiv = null;

    var cBoard = null; //棋盘对象


    document.write("<div width = 100% style = 'height:3000px' ></div>");
    if (dw > dh) {
      d.write(`<div id='up' style='position:absolute;left:${0}px;top:0px;background-Color:red' > </div>`);
      d.write("<div id='down' style='position:absolute;left:" + cWidth + "px;top:0px;background-Color:red' > </div>");
    }
    else {
      d.write(`<div id='up' style='position:absolute;left:${(dw-cWidth)/2}px;top:800px;background-Color:red' > </div>`);
      d.write("<div id='down' style='position:absolute;left:0px;top:" + (800 + cWidth + 50) + "px;background-Color:red' > </div>");
    }



    document.body.onload = function() {

      cBoard = new checkerBoard(d.getElementById("up"), 0, 0, cWidth, cWidth);
      cBoard.printCheckerBoard();

      setCheckerBoardEvent(cBoard.canvas);

      createRenjuCmdDiv(d.getElementById("down"), 0, 0, cWidth, cWidth);

      createImgCmdDiv(d.getElementById("down"), 0, 0, cWidth, cWidth);

      renjuLoad();


    }



    //设置事件处理程序

    function setCheckerBoardEvent(canvas) {

      canvas.addEventListener("touchstart", handleStart, false);

      canvas.addEventListener("touchend", handleEnd, false);

      canvas.addEventListener("touchcancel", handleCancel, false);

      canvas.addEventListener("touchleave", handleCancel, false);

      canvas.addEventListener("touchmove", handleMove, false);

      //canvas.addEventListener("click", canvasClick, false);

      canvas.addEventListener("contextmenu", bodyKeepTouch, false);

      canvas.addEventListener("dblclick", canvasDblClick, false);


      document.body.addEventListener("touchstart", bodyTouchStart, true);

      document.body.addEventListener("touchend", bodyTouchEnd, true);

      document.body.addEventListener("touchcancel", bodyTouchCancel, true);

      document.body.addEventListener("touchleave", bodyTouchEnd, true);

      document.body.addEventListener("touchmove", bodyTouchMove, true);

      document.body.addEventListener("click", canvasClick, false);

      log("setCheckBoardEvent End");

    }



    //处理触摸开始事件

    function handleStart(evt) {

      //evt.preventDefault();//阻止事件的默认行为

    }



    //处理触摸移动事件

    function handleMove(evt) {

      if (timerContinueSetCutDiv) evt.preventDefault();

    }



    //处理触摸结束事件

    function handleEnd(evt) {

      evt.preventDefault();

    }



    //处理触摸对出事件

    function handleCancel(evt) {

      evt.preventDefault();


    }



    //处理触摸开始事件

    function bodyTouchStart(evt) {

      //evt.preventDefault();
      //阻止事件的默认行为
      //log("touchstart...","red");
      if (isMsgShow) return;
      // 防止锁屏

      var touches = evt.changedTouches;

      //记录坐标，给continueSetCutDiv使用
      continueSetCutDivX = touches[0].pageX;
      continueSetCutDivY = touches[0].pageY;

      if (bodyStartTouches.length == 0) {

        if (bodyPreviousTouch.length) { //触发滑动调整
          //evt.preventDefault();
          if (timerContinueSetCutDiv == null) {
            timerContinueSetCutDiv = setTimeout(continueSetCutDivStart, 0);
            // 触发长按事件之前删除定时器，变量timerBodyKeepTouch还要用来判断双击事件，由touchend 清空变量。
            setTimeout(function() { clearTimeout(timerBodyKeepTouch) }, 600);
          }
        }

        //初始化长按事件
        if (!timerBodyKeepTouch) timerBodyKeepTouch = setTimeout(bodyKeepTouch, 900);

        //保存当前触摸点
        bodyStartTouches.push(copyTouch(touches[0], 1));
        //初始化单击事件
        isBodyClick = true;

      }
      else
      {

        // 多点触摸取消长按事件
        if (timerBodyKeepTouch) {
          clearTimeout(timerBodyKeepTouch);
          timerBodyKeepTouch = null;
        }

        var touchNum = bodyStartTouches.length + 1; //判断是第几个手指触摸屏幕
        if (touchNum > 3) return; //超过3指忽略
        // 多点触摸 取消单击事件。
        isBodyClick = false;
        bodyStartTouches.push(copyTouch(touches[0], touchNum));
      }

      //log("bodyPreviousTouch.length = " + bodyPreviousTouch.length);
      //log(bodyStartTouches);
    }



    //处理触摸移动事件

    function bodyTouchMove(evt) {
      log("bodyTouchMove")
      if (timerContinueSetCutDiv) evt.preventDefault();
      var touches = evt.changedTouches;

      if (isMsgShow) return;

      if (timerBodyKeepTouch != null) { //取消长按事件
        clearTimeout(timerBodyKeepTouch);
        timerBodyKeepTouch = null;
      }

      //记录坐标，给continueSetCutDiv使用
      continueSetCutDivX = touches[0].pageX;
      continueSetCutDivY = touches[0].pageY;

      if ((bodyPreviousTouch.length && Math.abs(bodyPreviousTouch[0].pageX - touches[0].pageX) > 30) && (Math.abs(bodyPreviousTouch[0].pageY - touches[0].pageY) > 30)) {
        // 取消单击事件。
        isBodyClick = false;
      }

    }



    //处理触摸结束事件

    function bodyTouchEnd(evt) {

      //evt.preventDefault();
      if (isMsgShow) return;

      //log("touchend/touchleave...","red");

      let cancelClick = false;

      var touches = evt.changedTouches;

      var idx = onTouchesIndex(touches[0].identifier, bodyStartTouches);
      // 取消  ContinueSetCutDiv 事件
      clearTimeout(timerContinueSetCutDiv);
      if (timerContinueSetCutDiv) {
        timerContinueSetCutDiv = null;
        setTimeout(continueSetCutDivEnd(), 10);
      }

      if (timerBodyKeepTouch) { //取消长按事件
        clearTimeout(timerBodyKeepTouch);
        timerBodyKeepTouch = null;
      }
      else // 触发了长按事件，取消单击
      {
        cancelClick = true;
      }

      if (idx >= 0) {

        var sX = bodyStartTouches[idx].pageX;
        var sY = bodyStartTouches[idx].pageY;
        var tX = touches[0].pageX;
        var tY = touches[0].pageY;
        var xMove = tX - sX;
        var yMove = tY - sY;

        var touchNum = bodyStartTouches.length; //判断是第几个手指触摸屏幕

        //log("touchNum=" + touchNum);

        if (touchNum > 3) { // 超过3指重置触摸跟踪

          bodyStartTouches.length = 0 //remove it; we're done

          return;
        }

        log("第" + bodyStartTouches[idx].touchNum + "个手指离开屏幕");

        if ((!cancelClick) && isBodyClick) {
          if ((bodyPreviousTouch.length > 0) && (Math.abs(bodyPreviousTouch[0].pageX - tX) < 30) && (Math.abs(bodyPreviousTouch[0].pageY - tY) < 30)) {
            bodyPreviousTouch.length = 0;
            /////////这里添加双击事件////////
            //通过 isOut 模拟 canvas事件
            if (!cBoard.isOut(tX, tY, cBoard.canvas)) {
              setTimeout(canvasDblClick(tX, tY), 10);
              //log("canvas 双击");
            }
            else {
              setTimeout(bodyDblClick(tX, tY), 10);
              //log("Body 双击");
            }
          }
          else {
            bodyPreviousTouch[0] = copyTouch(touches[0], 1);
            setTimeout("bodyPreviousTouch.length = 0;", 500);
            /////////这里添加单击事件////////
            //通过 isOut 模拟 canvas事件
            if (!cBoard.isOut(tX, tY, cBoard.canvas)) {
              evt.preventDefault();
              setTimeout(canvasClick(tX, tY), 10);
              //log("canvas 单击","red");
            }
            else {
              setTimeout(bodyClick(tX, tY), 10);
              //log("Body 单击","red");
            }
          }
        }
        else if (xMove > 380 && Math.abs(xMove / yMove) > 2) {

          log("右滑", "red");
        }
        else if (xMove < -380 && Math.abs(xMove / yMove) > 2) {

          log("左滑", "red");
        }
        else if (yMove > 380 && Math.abs(yMove / xMove) > 2) {

          log("下滑", "red");
        }
        else if (yMove < -380 && Math.abs(yMove / xMove) > 2) {

          log("上滑", "red");
        }


        bodyStartTouches.splice(idx, 1); //remove it;we're done

      } else {
        // 出错重新初始化 触摸跟踪
        bodyStartTouches.length = 0;

        log("can't figure out which touch to end");

      }

      bodyStartTouches.length = 0;
    }



    //处理触摸对出事件

    function bodyTouchCancel(evt) {

      evt.preventDefault();

      log("touchcancel.", "blue");

      var touches = evt.changedTouches;
      // 取消 continueSetCutDiv 事件
      clearInterval(timerContinueSetCutDiv);
      if (timerContinueSetCutDiv) {
        timerContinueSetCutDiv = null;
        setTimeout(continueSetCutDivEnd(), 10);
      }

      if (timerBodyKeepTouch) { // 取消长按事件
        clearTimeout(timerBodyKeepTouch);
        timerBodyKeepTouch = null;
      }

      bodyStartTouches.length = 0;
    }





    //拷贝一个触摸对象

    function copyTouch(touch, touchNum) {

      return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY, touchNum: touchNum };

    }





    //找出正在进行的触摸

    function onTouchesIndex(idToFind, touches) {

      for (var i = 0; i < touches.length; i++) {

        var id = touches[i].identifier;


        log("onTouchesIndex  " + touches)
        if (id == idToFind) {

          return i;

        }

      }

      return -1; //notfound

    }




    function canvasKeepTouch(x, y) {

      log("canvad长按start");
      if (playModel == renjuModel) {
        if (event && event.type == "contextmenu") {
          renjuKeepTouch(event.pageX, event.pageY);
        }
        else {
          renjuKeepTouch(x, y);
        }
      }
      else {
        if (cLockImg.checked) {
          putCheckerBoard(cBoard.getPIndex(x, y));
        }
        else {
          if (!timerContinueSetCutDiv) timerContinueSetCutDiv = setTimeout(continueSetCutDivStart, 10);
        }
      }

    }


    function canvasClick(x, y) {

      log("canvad 单击", "pink");
      if (isMsgShow) return; // 针对鼠标事件
      x = event.type == "click" ? event.pageX : x;
      y = event.type == "click" ? event.pageY : y;
      if (playModel == renjuModel) {
        renjuClick(x, y);
      }
      else if (!cLockImg.checked) {
        if (cBoard.isOut(x, y, cBoard.canvas)) return;
        let p = { x: x, y: y };
        cBoard.setxy(p, 1);
        cBoard.setCutDiv(p.x, p.y, true);
        cBoard.resetP();
        cBoard.printBorder();
      }
      else {
        let idx = cBoard.getPIndex(x, y);
        if (idx < 0) return;
        let color = cAddwhite2.checked ? "white" : "black";
        if (cBoard.P[idx].type != tEmpty) {
          cBoard.P[idx].cle();
        }
        else {
          cBoard.P[idx].printNb("★", color, cBoard.gW, cBoard.gH);
        }
      }
    }


    function canvasDblClick(x, y) {

      log("canvad 双击", "pink");
      if (playModel == renjuModel) {
        if (event.type == "dblclick") {
          renjuDblClick(event.pageX, event.pageY);
        }
        else {
          renjuDblClick(x, y);
        }
      }
    }


    function bodyClick(x, y) {}



    function bodyDblClick() {

    }


    function bodyKeepTouch() {
      log("keepTouch........。", "red");
      clearTimeout(timerBodyKeepTouch); //防止与canvas重复重复
      timerBodyKeepTouch = null;
      let x = bodyStartTouches[0].pageX;
      let y = bodyStartTouches[0].pageY;
      //  针对 msg 弹窗 恢复下一次长按事件
      bodyStartTouches.length = 0;
      //通过 isOut 模拟 canvas事件
      if (!cBoard.isOut(x, y, cBoard.canvas)) {
        setTimeout(canvasKeepTouch(x, y), 10);
        //log("canvad 长按");
      }
      else {
        log("Body 长按");
      }

    }



    function continueSetCutDivStart() {
      if (playModel == renjuModel || cLockImg.checked) return;
      setTimeout(cBoard.cleAllPointBorder(), 10);
      continueSetCutDivMove();
    }




    function continueSetCutDivMove() {

      //log("continueSetCutDiv start");
      var x = parseInt(continueSetCutDivX);
      var y = parseInt(continueSetCutDivY);
      var p = { x: x, y: y };
      if (!cBoard.isOut(x, y, cBoard.canvas))
      {
        cBoard.setxy(p, 0.25);
        cBoard.setCutDiv(p.x, p.y, true);
      }

      if (timerContinueSetCutDiv != null) timerContinueSetCutDiv = setTimeout(continueSetCutDivMove, 150);
    }




    function continueSetCutDivEnd() {
      if (playModel == renjuModel || cLockImg.checked) return;
      timerContinueSetCutDiv = null;
      cBoard.resetP();
      cBoard.printBorder();

    }
  </script>
  <script language="javascript">
    // 弹窗代码
    "use strict";
    const typeMSG = 1;
    const typeINPUT = 2;
    var isMsgShow = false; // =true 屏蔽 bodytouch 事件;

    // 创建一个屏蔽层
    var MsgBoxobj = document.createElement("div");
    MsgBoxobj.ontouchend = function() { event.preventDefault() };

    // msg 窗口
    var windowDiv = document.createElement("div");
    MsgBoxobj.appendChild(windowDiv);
    windowDiv.style.position = "relative";

    // 文本框
    var msgTextarea = document.createElement("textarea");
    windowDiv.appendChild(msgTextarea);
    msgTextarea.style.position = "relative";
    //msgTextarea.oninput = function(event){alert(event.keyCode)}

    //确认按钮
    var butEnter = new button(windowDiv, "button", 50, 50, 50, 50);
    butEnter.show();

    //取消按钮
    var butCancel = new button(windowDiv, "button", 50, 50, 50, 50);
    butCancel.show();

    function msg(text, type, left, top, width, height, enterTXT, cancelTXT, callEnter, callCancel, butNum, lineNum) {

      let p = { x: parseInt(cBoard.width) / 10, y: 0 };
      cBoard.xyObjToPage(p, cBoard.canvas);
      type = type == null ? "msgbox" : type;
      left = left == null ? p.x : left;
      top = top == null ? dh / 11 : top;
      width = width || cBoard.width * 0.8;
      //height = 
      butNum = butNum == null ? type == "input" ? 2 : 1 : butNum;

      isMsgShow = true; // 屏蔽 bodytouch 事件;
      var s = MsgBoxobj.style;
      document.body.appendChild(MsgBoxobj);
      s.position = "fixed";
      s.zIndex = 9999;
      s.width = d.documentElement.clientWidth;
      s.height = d.documentElement.clientHeight * 2;
      s.top = 0;
      s.left = 0;

      if (lineNum == "auto") {
        lineNum = parseInt(height * 0.8 / parseInt(s.width) / 0.05 / 1.25);
      }
      else if (!lineNum) {
        lineNum = parseInt(String(text).length / 20) + 1;
        lineNum = lineNum > 10 ? 10 : lineNum;
      }

      s = windowDiv.style;
      s.left = left;
      s.top = top;
      s.width = width;
      s.height = height || parseInt(s.width) / 20 * (lineNum + 3) * 1.3;
      s.backgroundColor = "#666666";


      s = msgTextarea.style;
      msgTextarea.value = text || "";
      s.left = "10px";
      s.top = "10px";
      s.width = parseInt(windowDiv.style.width) - 20;
      s.fontSize = parseInt(s.width) * 0.05 + "px";
      s.height = parseInt(s.fontSize) * 1.3 * lineNum;
      s.borderColor = "#666666";
      if (type == "msgbox") {
        msgTextarea.readOnly = true;
        s.autofocus = false;
        s.textAlign = "center";
        s.backgroundColor = "#777777";
      }
      else {
        msgTextarea.readOnly = false;
        s.autofocus = true;
        msgTextarea.focus()
        s.textAlign = "left";
        s.backgroundColor = "white";
      }

      let w = parseInt(s.fontSize) * 5;
      let h = w / 3.1;
      let t = parseInt(s.height) + parseInt(s.top) + (parseInt(windowDiv.style.height) - parseInt(s.height) - h) / 2;

      butEnter.setText(enterTXT ? enterTXT : "确定");
      butEnter.show(butNum == 1 ? w * 1.5 : w * 0.66, t, w, h);
      butEnter.setontouchend(function() {
        MsgBoxobj.parentNode.removeChild(MsgBoxobj);
        isMsgShow = false;
        if (callEnter) callEnter(msgTextarea.value);
        msgTextarea.value = "";
      });


      if (butNum == 2 || butNum == null) {

        butCancel.show(w * 2.32, t, w, h);
        butCancel.setText(cancelTXT ? cancelTXT : "取消");
        butCancel.setontouchend(function() {
          MsgBoxobj.parentNode.removeChild(MsgBoxobj);
          isMsgShow = false;
          if (callCancel) callCancel(msgTextarea.value);
        });

      }
      else if (butNum == 1) {

        butCancel.hide();

      }
      else {
        butCancel.hide();
        butEnter.hide();
      }

    }



    function closeMsg() {

      if (MsgBoxobj.parentNode == null) return;
      MsgBoxobj.parentNode.removeChild(MsgBoxobj);
      isMsgShow = false;
      msgTextarea.value = "";

    }
  </script>
  <script language="javascript">
    "use strict";
    const renjuModel = 0;
    const imgModel = 1;
    let playModel = renjuModel;
    let lbColor = ["black", "green", "red"];
    let renjuCmddiv = null;
    let imgCmdDiv = null;

    let cLockImg = null;
    let cPutBoard = null;
    let cAutoPut = null;
    let cCleAll = null;
    let cShownum = null;
    let cCleLb = null;
    let cLocknum = null;
    let cAutoadd = null;
    let cAddblack = null;
    let cAddwhite = null;
    let cAddblack2 = null;
    let cAddwhite2 = null;
    let cLba = null;
    let cLbb = null;
    let cLbc = null;
    let cLbd = null;
    let cLbColor = null;
    let cBack = null;
    let cResetnum = null;
    let cReset = null;
    let cNextone = null;
    let cInputcode = null;
    let cOutputcode = null;
    let cStart = null;
    let cEnd = null;
    let cPrevious = null;
    let cNext = null;
    let cFlipX = null;
    let cFlipY = null;
    let cCW = null;
    let cCCW = null;
    let cLABC = null;
    let cMoveL = null;
    let cMoveR = null;
    let cMoveT = null;
    let cMoveB = null;
    let cCutImage = null;
    let cSelBlack = null;
    let cSelWhite = null;
    let cPrintVCF = null;
    let cFindPoint = null;
    let cFindVCF = null;
    let cCancelFind = null;
    let cObjVCF = { arr: [], winMoves: [], color: 0, done: false }; // 保存VCF分支
    let cLoadImg = null;
    let cSLTX = null;
    let cSLTY = null;
    let putCheckerBoard = function() {};


    // renju 模式控制面板
    function createRenjuCmdDiv(parentNode, left, top, width, height) {

      renjuCmddiv = document.createElement("div");
      let s = renjuCmddiv.style;
      log("creatrenjuCmddiv");
      parentNode.appendChild(renjuCmddiv);
      s.position = "absolute";
      s.width = width / 1.15;
      s.height = width;
      s.top = top;
      s.left = (dw - parseInt(s.width)) / 2;
      if (dw > dh) s.left = (dw - cWidth * 2) / 2;

      let sw = parseInt(s.width);
      let w = sw / 9;
      let h = w / 1.5;
      let t = 0;


      cStart = new button(renjuCmddiv, "button", w * 0, t, w, h);
      cStart.show();
      cStart.setText("‖<<");
      cStart.setontouchend(function() {
        cBoard.toStart(cShownum.checked);
      });

      cPrevious = new button(renjuCmddiv, "button", w * 1.6, t, w, h);
      cPrevious.show();
      cPrevious.setText(" <<");
      cPrevious.setontouchend(function() {
        cBoard.toPrevious(cShownum.checked);
      });

      cNext = new button(renjuCmddiv, "button", w * 3.2, t, w, h);
      cNext.show();
      cNext.setText(">>");
      cNext.setontouchend(function() {
        cBoard.toNext(cShownum.checked);
      });

      cEnd = new button(renjuCmddiv, "button", w * 4.8, t, w, h);
      cEnd.show();
      cEnd.setText(" >>‖");
      cEnd.setontouchend(function() {
        cBoard.toEnd(cShownum.checked);
      });

      cShownum = new button(renjuCmddiv, "checkbox", w * 6.4, t, w, h);
      cShownum.show();
      cShownum.setText("●", "❶");
      cShownum.setChecked(1);
      cShownum.setontouchend(function() {
        renjucShownumClick();
        cBoard.isShowNum = cShownum.checked;
        //cShownum.setText(cShownum.checked?"❶" :"●");
      });

      cCleLb = new button(renjuCmddiv, "button", w * 8, t, w, h);
      cCleLb.show();
      cCleLb.setText("新棋局");
      cCleLb.setontouchend(function() {
        cBoard.cle();
        cBoard.resetNum = 0;
      });


      w = sw / 9;
      t = t + h * 1.5;

      /*
      cFlipX = new button(renjuCmddiv,"button",w*0,t,w,h);
      cFlipX.show();
      cFlipX.setText("↕180°");
      cFlipX.setontouchend( function() {      
          cBoard.boardFlipX(cShownum.checked);
      });
      */

      cFlipY = new button(renjuCmddiv, "button", w * 0, t, w, h);
      cFlipY.show();
      cFlipY.setText("↔180°");
      cFlipY.setontouchend(function() {
        cBoard.boardFlipY(cShownum.checked);
      });

      cCW = new button(renjuCmddiv, "button", w * 1.6, t, w, h);
      cCW.show();
      cCW.setText(" ↗90°");
      cCW.setontouchend(function() {
        cBoard.boardCW(cShownum.checked);
      });

      /*
      cCCW = new button(renjuCmddiv,"button",w*3.2,t,w,h);
      cCCW.show();
      cCCW.setText("↖90°");
      cCCW.setontouchend( function() {      
          cBoard.boardCCW(cShownum.checked);
      });
      */

      cMoveL = new button(renjuCmddiv, "button", w * 3.2, t, w, h);
      cMoveL.show();
      cMoveL.setColor("black");
      cMoveL.setText("←");
      cMoveL.setontouchend(function() {
        cBoard.moveCheckerBoard("left");
      });

      cMoveR = new button(renjuCmddiv, "button", w * 4.8, t, w, h);
      cMoveR.show();
      cMoveR.setColor("black");
      cMoveR.setText("→ ");
      cMoveR.setontouchend(function() {
        cBoard.moveCheckerBoard("right");
      });

      cMoveT = new button(renjuCmddiv, "button", w * 6.4, t, w, h);
      cMoveT.show();
      cMoveT.setColor("black");
      cMoveT.setText(" ↑");
      cMoveT.setontouchend(function() {
        cBoard.moveCheckerBoard("top");
      });

      cMoveB = new button(renjuCmddiv, "button", w * 8, t, w, h);
      cMoveB.show();
      cMoveB.setColor("black");
      cMoveB.setText("↓");
      cMoveB.setontouchend(function() {
        cBoard.moveCheckerBoard("bottom");
      });


      w = sw / 5;
      t = t + h * 1.5;

      cSelBlack = new button(renjuCmddiv, "checkbox", w * 0, t, w, h);
      cSelBlack.show();
      cSelBlack.setText("黑先");
      cSelBlack.setChecked(1);
      cSelBlack.setontouchend(function() {
        cSelChecked(cSelBlack);
      });

      cSelWhite = new button(renjuCmddiv, "checkbox", w * 1.33, t, w, h);
      cSelWhite.show();
      cSelWhite.setText("白先");
      cSelWhite.setontouchend(function() {
        cSelChecked(cSelWhite);
      });

      cFindPoint = new button(renjuCmddiv, "select", w * 2.66, t, w, h);
      cFindPoint.addOption(0, "<<");
      cFindPoint.addOption(1, "做V点");
      cFindPoint.addOption(2, "做杀(43,冲44,冲冲抓)");
      cFindPoint.addOption(3, "活三级别");
      cFindPoint.addOption(4, "活三");
      cFindPoint.addOption(5, "❌\b三三");
      cFindPoint.addOption(6, "❌\b四四");
      cFindPoint.addOption(7, "❌\b长连");
      cFindPoint.addOption(8, "五连");
      cFindPoint.addOption(9, "活四");
      cFindPoint.addOption(10, "冲四");
      cFindPoint.addOption(11, "眠三");
      cFindPoint.show();
      cFindPoint.setText("找点");
      cFindPoint.setonchange(function(but) {
        but.setText("找点");
        if (but.input.value < 1 || vcfFinding != -1) {
          but.input.value = 0;
          return;
        }


        let arr = [];
        cBoard.getPointArray(arr);
        let newarr = getArr([]);
        switch (but.input.value * 1) {
          case 1:
            setCmd(but);

            function* vcf() {
              yield* findLevelThreePoint(arr, getRenjuSelColor(), newarr, OnlyVCF, 112, false);
              callback();
            }
            generator = vcf();
            generator.next();
            break;

          case 2:
            setCmd(but);

            function* swin() {
              yield* findLevelThreePoint(arr, getRenjuSelColor(), newarr, OnlySimpleWin, 112, false);
              callback();
            }
            generator = swin();
            generator.next();
            break;

          case 3:
            setCmd(but);

            function* three() {
              yield* findLevelThreePoint(arr, getRenjuSelColor(), newarr, null, 112, false);
              callback();
            }
            generator = three();
            generator.next();
            break;

          case 4:
            findThreePoint(arr, getRenjuSelColor(), newarr, Onlyfree);
            cBoard.printArray(newarr, "③", "red");
            break;
          case 5:
            findTTPoint(arr, getRenjuSelColor(), newarr);
            cBoard.printArray(newarr, "❌", "red");
            break;
          case 6:
            findFFPoint(arr, getRenjuSelColor(), newarr);
            cBoard.printArray(newarr, "❌", "red");
            break;
          case 7:
            findSixPoint(arr, getRenjuSelColor(), newarr, null);
            cBoard.printArray(newarr, "❌", "red");
            break;
          case 8:
            findFivePoint(arr, getRenjuSelColor(), newarr, null);
            cBoard.printArray(newarr, "⑤", "red");
            break;
          case 9:
            findFourPoint(arr, getRenjuSelColor(), newarr, Onlyfree);
            cBoard.printArray(newarr, "④", "red");
            break;
          case 10:
            findFourPoint(arr, getRenjuSelColor(), newarr, Onlynfree);
            cBoard.printArray(newarr, "④", "black");
            break;
          case 11:
            findThreePoint(arr, getRenjuSelColor(), newarr, Onlynfree);
            cBoard.printArray(newarr, "③", "black");
            break;
        }

        but.input.value = 0;
      });
      cFindPoint.setontouchend(function() {});
      let setCmd = function(but) {
        //msg ("","msgbox",0,cBoard.height,dw+8,dh-cBoard.height,"停止计算",null,
        //  cancelFind,null,null,"auto");
        cFindPoint.hide();
        cFindVCF.hide();
        cCancelFind.move(but.left, but.top, but.width, but.height);
      }
      let callback = function() {
        cFindPoint.show();
        cFindPoint.setText("找点");
        cFindVCF.show();
        cFindVCF.setText("解题");
        cCancelFind.hide();
        closeMsg();
      }



      cFindVCF = new button(renjuCmddiv, "select", w * 3.99, t, w, h);
      cFindVCF.addOption(0, "<<");
      cFindVCF.addOption(1, "快速找\b VCF");
      cFindVCF.addOption(2, "找全\b  VCF");
      cFindVCF.addOption(3, "找\b 双杀");
      cFindVCF.addOption(4, "大道五目");
      cFindVCF.addOption(5, "防\b冲四抓禁");

      cFindVCF.addOption(6, "找\b VCF防点");
      cFindVCF.addOption(7, "判断\b进攻级别");
      cFindVCF.addOption(8, "判断\b简单必胜");

      cFindVCF.show();
      cFindVCF.setText("解题");
      cFindVCF.setonchange(function(but) {
        but.setText("解题");
        if (but.input.value < 1 || vcfFinding != -1) {
          but.input.value = 0;
          return;
        }
        setCmd(but);
        let arr = [];
        cBoard.getPointArray(arr);
        let printMsg = function() {
          let fclr = vcfcolor == 1 ? "黑棋" : "白棋";
          if (vcfWinMoves.length) {
            // 显示手顺
            let len = vcfWinMoves[0].length;
            let x = vcfWinMoves[0][len - 1] % 15;
            let y = parseInt(vcfWinMoves[0][len - 1] / 15);

            setTimeout(function() {
              cBoard.printMoves(vcfWinMoves[0].slice(0, len), vcfcolor);
              cBoard.wLb(vcfWinMoves[0][len - 1], len, "red");
            }, 600);

            msg("✔ " + fclr + " 找到 " + vcfWinMoves.length + "套 VCF,用时 " + (new Date().getTime() - vcfStartTimer) / 1000 + "秒");

            let str = "";
            for (let y = 0; y < vcfWinMoves.length; y++) {
              str += "\n" + vcfWinMoves[y] + "====" + vcfWinMoves[y].length;
            }

          }
          else {

            msg("❌❌❌ " + fclr + " 查找VCF失败了");
          }

        }
        let finishEvent = function(done) {
          cObjVCF.arr = copyArr([], cBoard.getPointArray([]));
          cObjVCF.winMoves = [];
          cObjVCF.color = vcfcolor;
          cObjVCF.done = done;
          for (let i = 0; i < vcfWinMoves.length; i++) {
            cObjVCF.winMoves.push(vcfWinMoves[i].slice(0));
          }
          callback();
          printMsg();
        }
        // continueFindVCF(color,timeOut,depth,count,backStage,arr,callback,callbackParameter) 
        switch (but.input.value * 1) {
          case 1:
            generator = continueFindVCF(getRenjuSelColor(), null, null, 1, null, arr);
            generator.next();
            vcfFinishEvent = function() {
              finishEvent(false);
            }
            break;
          case 2:
            generator = continueFindVCF(getRenjuSelColor(), null, null, null, null, arr);
            generator.next();
            vcfFinishEvent = function() {
              finishEvent(true);
            }
            break;
          case 3:
            function* ftwo() {
              yield* findTwoVCF(arr, getRenjuSelColor(), getArr([]));
              callback();
            }
            generator = ftwo();
            generator.next();
            break;
          case 7:
            function* g() {
              let level = (yield* getLevelB(arr, 1, getArr([]), 25000, null, false)).level;
              let level2 = (yield* getLevelB(arr, 2, getArr([]), 25000, null, false)).level;
              let str = "";
              if (level > 2) {
                str = "黑进攻级别  =  " + levelToStr(level) + "\n";
              }
              if (level2 > 2) {
                str += "白进攻级别  =  " + levelToStr(level2) + "\n";
              }
              if (str == "") {
                str = "黑,白进攻级别  =  " + levelToStr(level) + "\n";
                if (isWin(1, arr) && isWin(2, arr)) str = "❌❌❌黑白都有五连❌❌❌";
              }
              callback();
              msg(str);
            }

            function levelToStr(level) {
              switch (level) {
                case 5:
                  return "胜";
                case 4.5:
                  return "冲四";
                case 4:
                  return "冲四";
                case 3:
                  return "活三级别";
                default:
                  return "小于活三级别";
              }
            }
            generator = g();
            generator.next();
            break;
          case 6:
            function* gbf() {
              if (yield* continueFindVCF(getRenjuSelColor(), null, null, 1, null, copyArr([], arr))) {
                let p = yield* getBlockVCFb(vcfWinMoves, vcfcolor, arr, false);
                if (!p) msg("❌❌❌没有成立的防点");
              }
              else {
                msg("❌❌❌没有VCF");
              }
              callback();
            }
            generator = gbf();
            generator.next();
            break
          case 5:
            function* bcf() {
              let r = yield* blockCatchFoul(arr);
              callback();
              if (r == -1) {
                msg("❌❌❌ 没有找到冲四抓禁 ❌❌❌");
              }
              else if (r == 0) {
                msg("❌❌❌ 没有成立的解禁点 ❌❌❌");
              }
            }
            generator = bcf();
            generator.next();
            break;
          case 8:
            function* gwl() {
              let lvl = yield* getWinLevel(arr, getRenjuSelColor());
              let str = getRenjuSelColor() == 1 ? "黑棋" : "白棋";
              str += winToStr(lvl);
              callback();
              msg(str);
            }
            generator = gwl();
            generator.next();

            function winToStr(level) {
              switch (level) {
                case 5:
                  return "已胜";
                case 4.5:
                  return "活4级必胜(44，冲四抓)";
                case 4.4:
                  return "VCF必胜";
                case 3.5:
                  return "33级必胜(双杀)";
                default:
                  return "没有找到33以上的必胜";
              }
            }
            break;
          case 4:
            function* sp() {
              if (!(yield* findSimpleWin(arr, getRenjuSelColor(), getArr([]), 4))) {
                msg("❌❌❌没有两手43胜❌❌❌");
              }
              callback();
            }
            generator = sp();
            generator.next();

            break;
        }
        but.input.value = 0;

      });
      cFindVCF.setontouchend(function() {});


      cCancelFind = new button(renjuCmddiv, "button", w * 3.99, t, w, h);
      //cCancelFind.show();
      cCancelFind.setText("停止");
      cCancelFind.setontouchend(function(but) {
        cancelFind();
      });



      t = t + h * 1.5;

      cAutoadd = new button(renjuCmddiv, "radio", 0, t, w, h);
      cAutoadd.show();
      cAutoadd.setText("\b◐\b棋");
      cAutoadd.setChecked(1);
      cAutoadd.setontouchend(function() {
        nSetChecked(cAutoadd);
      });

      cAddblack = new button(renjuCmddiv, "radio", w * 1.33, t, w, h);
      cAddblack.show();
      cAddblack.setText("\b●\b棋");
      cAddblack.setontouchend(function() {
        nSetChecked(cAddblack);
      });

      cAddwhite = new button(renjuCmddiv, "radio", w * 2.66, t, w, h);
      cAddwhite.show();
      cAddwhite.setText("\b○\b棋");
      cAddwhite.setontouchend(function() {
        nSetChecked(cAddwhite);
      });

      cPrintVCF = new button(renjuCmddiv, "select", w * 3.99, t, w, h);
      cPrintVCF.addOption(0, "<<");
      cPrintVCF.addOption(1, "第1套VCF");
      cPrintVCF.addOption(2, "第2套VCF");
      cPrintVCF.addOption(3, "第3套VCF");
      cPrintVCF.addOption(4, "第4套VCF");
      cPrintVCF.addOption(5, "第5套VCF");
      cPrintVCF.addOption(6, "第6套VCF");
      cPrintVCF.addOption(7, "第7套VCF");
      cPrintVCF.addOption(8, "第8套VCF");
      cPrintVCF.show();
      cPrintVCF.setText("➩\b VCF \b");
      cPrintVCF.setonchange(function(but) {
        but.setText("➩\b VCF \b");
        if (but.input.value) {
          let color = getRenjuSelColor();
          let arr = cBoard.getPointArray([]);
          if (color == cObjVCF.color && bArr(arr, cObjVCF.arr)) {
            if (cObjVCF.winMoves.length >= but.input.value) {
              let moves = cObjVCF.winMoves[but.input.value - 1].slice(0, cObjVCF.winMoves[but.input.value - 1].length);
              cBoard.printMoves(moves, cObjVCF.color);
              cBoard.wLb(moves[moves.length - 1], moves.length, "red");
            }
            else {
              let str = `\b${color==1?"黑棋":"白棋"}\b只找到\b${cObjVCF.winMoves.length} 套\bVCF\b记录`;
              msg(str);
            }
          }
          else {
            let str = `请先\b找全\b${color==1?"黑棋":"白棋"}\bVCF`;
            msg(str);
          }
          but.input.value = 0;
        }

        function bArr(arr, arr2) {
          if (arr2.length) {
            for (let y = 0; y < 15; y++) {
              for (let x = 0; x < 15; x++) {
                if (arr[y][x] != arr2[y][x]) return false;
              }
            }
            return true;
          }
          return false;
        }
      });





      t = t + h * 1.3;


      cLba = new button(renjuCmddiv, "radio", w * 0, t, w, h);
      cLba.show();
      cLba.setText("\b ■ \b");
      cLba.setontouchend(function() {
        nSetChecked(cLba);
      });

      cLbb = new button(renjuCmddiv, "radio", w * 1.33, t, w, h);
      cLbb.show();
      cLbb.setText("\b◎\b");
      cLbb.setontouchend(function() {
        nSetChecked(cLbb);
      });

      cLABC = new button(renjuCmddiv, "select", w * 2.66, t, w, h);
      cLABC.addOption(0, "ABC...");
      cLABC.addOption(1, "abc...");
      cLABC.addOption(2, "123...");
      cLABC.addOption(3, "☆标记");
      cLABC.show();
      cLABC.setontouchstart(function() {
        nSetChecked(cLABC);
      });

      cNextone = new button(renjuCmddiv, "button", w * 3.99, t, w, h);
      cNextone.show();
      cNextone.setColor("black");
      cNextone.setText(" 下手为❶");
      cNextone.setontouchend(function() {
        cBoard.setResetNum(cBoard.MSindex + 1);
      });



      t = t + h * 1.3;


      cLbc = new button(renjuCmddiv, "radio", w * 0, t, w, h);
      cLbc.show();
      cLbc.setText("\b ▲\b");
      cLbc.setontouchend(function() {
        nSetChecked(cLbc);
      });


      cLbd = new button(renjuCmddiv, "radio", w * 1.33, t, w, h);
      cLbd.show();
      cLbd.setText("\b ×\b");
      cLbd.setontouchend(function() {
        nSetChecked(cLbd);
      });

      cLbColor = new button(renjuCmddiv, "select", w * 2.66, t, w, h);
      cLbColor.addOption(0, "黑色标记");
      cLbColor.addOption(1, "绿色标记");
      cLbColor.addOption(2, "红色标记");
      cLbColor.show();
      cLbColor.setText("✎\b颜色");
      cLbColor.setonchange(function(but) {
        but.setColor(lbColor[but.input.value]);
        but.setText("✎\b颜色");
        cLba.setColor(lbColor[but.input.value]);
        cLbb.setColor(lbColor[but.input.value]);
        cLbc.setColor(lbColor[but.input.value]);
        cLbd.setColor(lbColor[but.input.value]);
        cLABC.setColor(lbColor[but.input.value]);
      });

      cResetnum = new button(renjuCmddiv, "button", w * 3.99, t, w, h);
      cResetnum.show();
      cResetnum.setColor("black");
      cResetnum.setText(" 重置手数");
      cResetnum.setontouchend(function() {
        cBoard.setResetNum(0);
        cShownum.setChecked(true);
      });




      t = t + h * 1.5;

      cInputcode = new button(renjuCmddiv, "button", w * 0, t, w, h);
      cInputcode.show();
      cInputcode.setColor("black");
      cInputcode.setText("输入代码");
      let inputCode = function(msgStr) {
        // 成功设置棋盘 ，就开始解析棋盘摆盘
        let st = 0;
        let end = msgStr.indexOf("{");
        end = end == -1 ? msgStr.length : end;
        let moves;
        let blackMoves;
        let whiteMoves;
        moves = cBoard.setMoves(msgStr.slice(st, end));
        st = end + 1;
        end = msgStr.indexOf("}{", st);
        end = end == -1 ? msgStr.length : end;
        blackMoves = cBoard.setMoves(msgStr.slice(st, end));
        st = end + 2;
        end = msgStr.length;
        whiteMoves = cBoard.setMoves(msgStr.slice(st, end));
        if (moves || blackMoves || whiteMoves) {
          cBoard.cle();
          cBoard.resetNum = 0;
          if (moves) cBoard.unpackMoves(cShownum.checked, "auto", moves);
          if (blackMoves) cBoard.unpackMoves(cShownum.checked, "black", blackMoves);
          if (whiteMoves) cBoard.unpackMoves(cShownum.checked, "white", whiteMoves);
        }
      }
      cInputcode.setontouchend(function() {
        let w = cBoard.width * 0.8;
        let h = w;
        let l = (dw - w) / 2;
        let t = (dh - dw) / 4;
        t = t < 0 ? 1 : t;
        msg("长按下面空白区域，粘贴棋谱代码 " + "\n" + "-------------" + "\n\n", "input", l, t, w, h, "输入代码", null,
          inputCode, null, null, 10);
      });

      cOutputcode = new button(renjuCmddiv, "button", w * 1.33, t, w, h);
      cOutputcode.show();
      cOutputcode.setColor("black");
      cOutputcode.setText("输出代码");
      cOutputcode.setontouchend(function() {
        let w = cBoard.width * 0.8;
        let h = w;
        let l = (dw - w) / 2;
        let t = (dh - dw) / 4;
        t = t < 0 ? 1 : t;
        let code = cBoard.getMoves();
        code += "\n{" + cBoard.getMoves(tBlack) + "}";
        code += "{" + cBoard.getMoves(tWhite) + "}";
        code = code == "" ? "空棋盘没有棋盘代码" : code;
        msg(code + "\n\n\n" + "-------------" + "\n" + "长按上面代码，复制棋谱代码 ", "input", l, t, w, h, "输入代码", null,
          inputCode, null, null, 10);
      });

      cLoadImg = new button(renjuCmddiv, "file", w * 2.66, t, w, h);
      cLoadImg.show();
      cLoadImg.input.accept = "image/*";
      cLoadImg.setText("输入图片");
      cLoadImg.setonchange(function() {
        let reader = new FileReader();
        let file = cLoadImg.input.files[0];
        cLoadImg.input.value = "";
        let img = cBoard.bakImg;
        img.src = null;
        reader.readAsDataURL(file);
        reader.onload = function() {
          img.src = reader.result;
        }
        img.onload = function() {
          img.onload = null;
          putImg();
        }
      });

      function putImg() {
        let img = cBoard.bakImg;
        let w = parseInt(img.width);
        let h = parseInt(img.height);
        let w1 = cBoard.width;
        let h1 = cBoard.width * h / w;
        let h2 = cBoard.canvas.height;
        cBoard.cle();
        // 画图之前，设置画布大小
        cBoard.canvas.width = w1;
        cBoard.canvas.height = h1;
        cBoard.canvas.style.width = w1;
        cBoard.canvas.style.height = h1;
        let ctx = cBoard.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h, w1 / 13, h1 / 13, w1 / 13 * 11, h1 / 13 * 11);
        parentNode.style.top = h1 + parentNode.offsetTop - h2;
        cBoard.resetCutDiv();
        parentNode.removeChild(renjuCmddiv);
        parentNode.appendChild(imgCmdDiv);
        playModel = imgModel;
        cLockImg.setChecked(0);
        cAddblack2.setChecked(1);
        cAddwhite2.setChecked(0);
        cSLTX.input.value = cBoard.SLTX;
        cSLTX.setText(cSLTX.input.value + "\b列");
        cSLTY.input.value = cBoard.SLTY;
        cSLTY.setText(cSLTY.input.value + "\b行");
        ctx = null;
      }

      cCutImage = new button(renjuCmddiv, "select", w * 3.99, t, w, h);
      cCutImage.addOption(0, "<<");
      cCutImage.addOption(1, "JPEG/(*.jpg)__压缩");
      cCutImage.addOption(2, "PNG/(*.png)__清晰");
      cCutImage.addOption(3, "SVG/(*.svg)__矢量,无损");
      cCutImage.addOption(4, "SVG/(*.svg.html__矢量，无损");
      cCutImage.addOption(5, "PDF/(*.pdf)__矢量，无损");
      cCutImage.show();
      cCutImage.setText("✄\b截图");
      cCutImage.setonchange(function(but) {
        but.setText("✄\b截图");
        switch (but.input.value * 1) {
          case 1:
            cBoard.saveAsImage("jpeg");
            break;
          case 2:
            cBoard.saveAsImage("png");
            break;
          case 3:
            cBoard.saveAsSVG("svg");
            break;
          case 4:
            cBoard.saveAsSVG("html");
            break;
          case 5:
            cBoard.saveAsPDF();
            break;
        }
        but.input.value = 0;
      });



      /*
      cReset = new button(renjuCmddiv,"button",w*2.66,t,w,h);
      cReset.show();
      cReset.setColor("black");
      cReset.setText(" 复原棋局");
      cReset.setontouchend( function() {    
          cBoard.cle();
          cBoard.unpackMoves(cShownum.checked);
      });
      
      cLocknum = new button(renjuCmddiv,"checkbox",w*3.99,t,w,h);
      cLocknum.show();
      cLocknum.setText("锁定棋局");
      cLocknum.setontouchend( function() {    
          if (cLocknum.checked) {
              cBoard.MSToMoves();  // 保存棋谱代码
          }
          else {
              cBoard.cleMoves();  // 清空棋谱代码
          }
      });
      */



      t = t + h * 1.3;


      function cSelChecked(chk) {
        cSelBlack.setChecked(0);
        cSelWhite.setChecked(0);
        chk.setChecked(1);
      }



      function nSetChecked(chk) {
        cLba.setChecked(0);
        cLbb.setChecked(0);
        cLbc.setChecked(0);
        cLbd.setChecked(0);
        cAutoadd.setChecked(0);
        cAddblack.setChecked(0);
        cAddwhite.setChecked(0);
        cLABC.setChecked(0);
        chk.setChecked(1);
      }


    }





    function createImgCmdDiv(parentNode, left, top, width, height) {

      imgCmdDiv = document.createElement("div");
      let s = imgCmdDiv.style;
      //parentNode.appendChild(imgCmdDiv);
      s.position = "absolute";
      s.width = width / 1.15;
      s.height = width;
      s.top = top;
      s.left = (dw - parseInt(s.width)) / 2;
      if (dw > dh) s.left = (dw - cWidth * 2) / 2;

      let sw = parseInt(s.width);
      let w = sw / 5;
      let h = sw / 9 / 1.5;
      let t = 0;

      cLockImg = new button(imgCmdDiv, "checkbox", w * 0, t, w, h);
      cLockImg.show();
      cLockImg.setText("选定棋盘");
      cLockImg.setontouchend(function() {
        if (cLockImg.checked) {
          lockImg();
        }
        else {
          putImg();
          return;
        }
      });

      function putImg() {
        let img = cBoard.bakImg;
        let w = parseInt(img.width);
        let h = parseInt(img.height);
        let w1 = cBoard.width;
        let h1 = cBoard.width * h / w;
        let h2 = cBoard.canvas.height;
        cBoard.cle();
        // 画图之前，设置画布大小
        cBoard.canvas.width = w1;
        cBoard.canvas.height = h1;
        cBoard.canvas.style.width = w1;
        cBoard.canvas.style.height = h1;
        let ctx = cBoard.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h, w1 / 13, h1 / 13, w1 / 13 * 11, h1 / 13 * 11);
        parentNode.style.top = h1 + parentNode.offsetTop - h2;
        cBoard.resetCutDiv();
        ctx = null;
      }

      function lockImg(generator) {

        let div = cBoard.cutDiv;
        let w = parseInt(cBoard.cutDiv.style.width);
        let h = parseInt(cBoard.cutDiv.style.height);
        let w2 = w / 11 * 13;
        let h2 = h / 11 * 13;
        let l = div.offsetLeft - w / 11 > 0 ? div.offsetLeft - w / 11 : 0;
        let t = div.offsetTop - h / 11 > 0 ? div.offsetTop - h / 11 : 0;
        let L2 = l > 0 ? 0 : w / 11 - div.offsetLeft;
        let t2 = t > 0 ? 0 : h / 11 - div.offsetTop;

        cBoard.bakCanvas.width = w2;
        cBoard.bakCanvas.height = h2;
        cBoard.bakCanvas.style.width = w2;
        cBoard.bakCanvas.style.height = h2;

        let ctx = cBoard.bakCanvas.getContext("2d");
        ctx.fillStyle = cBoard.backgroundColor;
        ctx.fillRect(0, 0, w2, h2);
        cBoard.cutImg.src = cBoard.bakCanvas.toDataURL("image/png");

        cBoard.cutImg.onload = function() {
          cBoard.cutImg.onload = null;
          let w3 = parseInt(cBoard.canvas.width) - div.offsetLeft;
          w3 = w3 < w / 11 * 12 ? w : w / 11 * 12;
          w3 += l == 0 ? div.offsetLeft : w / 11;
          let h3 = parseInt(cBoard.canvas.height) - div.offsetTop;
          h3 = h3 < h / 11 * 12 ? h : h / 11 * 12;
          h3 += t == 0 ? div.offsetTop : h / 11;
          ctx.drawImage(cBoard.canvas, l, t, w3, h3, L2, t2, w3, h3);
          cBoard.cutImg.src = cBoard.bakCanvas.toDataURL("image/png");

          cBoard.cutImg.onload = function() {
            cBoard.cutImg.onload = null;
            ctx = cBoard.canvas.getContext("2d");

            h = parseInt(cBoard.canvas.height);
            cBoard.canvas.height = parseInt(cBoard.width) * h2 / w2;
            cBoard.canvas.style.height = parseInt(cBoard.width) * h2 / w2;
            ctx.drawImage(cBoard.cutImg, 0, 0, w2, h2, 0, 0, parseInt(cBoard.width), parseInt(cBoard.width) * h2 / w2);

            cBoard.XL = parseInt(cBoard.canvas.width) / 13;
            cBoard.XR = parseInt(cBoard.canvas.width) / 13 * 12;
            cBoard.YT = parseInt(cBoard.canvas.height) / 13;
            cBoard.YB = parseInt(cBoard.canvas.height) / 13 * 12;
            cBoard.resetP(cBoard.XL, cBoard.XR, cBoard.YT, cBoard.YB);
            parentNode.style.top = parseInt(cBoard.canvas.height) + parentNode.offsetTop - h;

            cBoard.cleAllPointBorder();
            cBoard.hideCutDiv();
            ctx = null;
            if (generator) generator.next();
            /*
            cBoard.parentNode.appendChild(cBoard.bakCanvas);
            cBoard.bakCanvas.style.top = 2000;
            cBoard.parentNode.appendChild(cBoard.cutImg);
            cBoard.cutImg.style.top = 1500;
            */
          }
        }

      }

      cAutoPut = new button(imgCmdDiv, "button", w * 1.33, t, w, h);
      cAutoPut.show();
      cAutoPut.setColor("black");
      cAutoPut.setText(" 自动识别");
      cAutoPut.setontouchend(function() {
        generator = autoPut();
        if (!cLockImg.checked) {
          lockImg(generator);
          cLockImg.setChecked(1);
        }
        else {
          generator.next();
        }
      });

      function* autoPut() {
        let arr = getArr([], 0, cBoard.SLTX, cBoard.SLTY);
        let max = 0;
        let min = 255;
        let timeout = 120;
        let cNum;
        let rgb;
        let idx;
        let wBoard = true; // 默认白色棋盘
        let sTime;
        setTimeout(function() { generator.next(); }, 500);
        yield; //浏览器空闲再测速
        sTime = new Date().getTime();
        cBoard.getPointColor(0); // 测速
        if ((new Date().getTime() - sTime) > timeout) {
          msg("您使用的浏览器运行速度太慢，不适合使用自动扫描");
          return;
        }
        msg("正在扫描棋盘......", null, null, null, null, null, null, null, null, null, 0);
        for (let i = cBoard.SLTY - 1; i >= 0; i--) {
          for (let j = cBoard.SLTX - 1; j >= 0; j--) {
            idx = i * cBoard.SLTX + j;
            cBoard.P[idx].printLb("★", "green", cBoard.gW, cBoard.gH);
            rgb = cBoard.getPointColor(idx);
            //alert(rgb.r+"\n"+rgb.g+"\n"+rgb.b);
            cNum = (rgb.r + rgb.g + rgb.b) / 3;
            // 黑，白以外-1000，表示空子。
            if (Math.abs(rgb.r - rgb.g) < 60 && Math.abs(rgb.r - rgb.b) < 60 && Math.abs(rgb.g - rgb.b) < 60) {
              arr[i][j] = cNum;
              max = cNum > max ? cNum : max; // 设置最白，最黑
              min = cNum < min ? cNum : min;
            }
            else {
              arr[i][j] = -1000;
              wBoard = false;
            }
            setTimeout(function() { generator.next(); }, 0);
            yield;
            cBoard.P[idx].cle();
          }
        }
        closeMsg();
        nSetChecked(cAddwhite2); // 选定白棋按钮，方便修改
        for (let i = cBoard.SLTY - 1; i >= 0; i--) {
          for (let j = cBoard.SLTX - 1; j >= 0; j--) {
            idx = i * cBoard.SLTX + j;
            if (Math.abs(arr[i][j] - max) < (wBoard || max > 250 ? 20 : 50)) {
              //arr[i][j] = 2;
              cBoard.P[idx].printNb("★", "white", cBoard.gW, cBoard.gH);
            }
            else if (Math.abs(arr[i][j] - min) < (wBoard || min < 5 ? 30 : 60)) {
              //arr[i][j] = 1;
              cBoard.P[idx].printNb("★", "black", cBoard.gW, cBoard.gH);
            }
            else if (timeout > 1000) {
              cBoard.P[idx].printNb("▲", "black", cBoard.gW, cBoard.gH);
            }
          }
        }
      }

      cPutBoard = new button(imgCmdDiv, "button", w * 2.66, t, w, h);
      cPutBoard.show();
      cPutBoard.setColor("black");
      cPutBoard.setText(" 摆入棋盘");
      cPutBoard.setontouchend(function() {
        if (cBoard.SLTX == 15 && cBoard.SLTY == 15) {
          putBoard();
        }
        else {
          msg("小棋盘,长按 H8(天元) 定位到15路棋盘");
        }
      });
      putCheckerBoard = putBoard;

      function putBoard(idx) {
        if (idx < 0) return;
        let arr = cBoard.getPointArray([]);
        let h1 = parseInt(cBoard.width);
        let h2 = parseInt(cBoard.canvas.height);
        cBoard.cle();
        cBoard.printCheckerBoard();
        cBoard.hideCutDiv();
        parentNode.style.top = h1 + parentNode.offsetTop - h2;
        parentNode.removeChild(imgCmdDiv);
        parentNode.appendChild(renjuCmddiv);
        playModel = renjuModel;
        cBoard.unpackArray(changeCoordinate(arr, idx));
      }

      function changeCoordinate(arr, idx) {
        let nArr = getArr([]);
        idx = idx || 112;
        let l = 7 - parseInt(idx % arr[0].length);
        l = l < 0 ? 0 : l;
        l = l + arr[0].length > 15 ? 15 - arr[0].length : l;
        let t = 7 - parseInt(idx / arr.length);
        t = t < 0 ? 0 : t;
        t = t + arr.length > 15 ? 15 - arr.length : t;
        for (let i = 0; i < arr.length; i++) {
          for (let j = 0; j < arr[i].length; j++) {
            nArr[i + t][j + l] = arr[i][j];
          }
        }
        return nArr;
      }

      cCleAll = new button(imgCmdDiv, "button", w * 3.99, t, w, h);
      cCleAll.show();
      cCleAll.setColor("black");
      cCleAll.setText(" 清空棋盘");
      cCleAll.setontouchend(function() {
        for (let i = cBoard.SLTX * cBoard.SLTY - 1; i >= 0; i--) cBoard.P[i].cle();
      });


      t = t + h * 1.5;

      cAddblack2 = new button(imgCmdDiv, "radio", w * 0, t, w, h);
      cAddblack2.show();
      cAddblack2.setText("\b●\b棋");
      cAddblack2.setontouchend(function() {
        nSetChecked(cAddblack2);
      });

      cAddwhite2 = new button(imgCmdDiv, "radio", w * 1.33, t, w, h);
      cAddwhite2.show();
      cAddwhite2.setText("\b○\b棋");
      cAddwhite2.setontouchend(function() {
        nSetChecked(cAddwhite2);
      });


      cSLTY = new button(imgCmdDiv, "select", w * 2.66, t, w, h);
      for (let i = 15; i >= 5; i--) {
        cSLTY.addOption(i, i);
      }
      cSLTY.show();
      cSLTY.setText(cSLTY.input.value + "\b行");
      cSLTY.setonchange(function(but) {
        but.setText(but.input.value + "\b行");
        cBoard.SLTY = but.input.value;
        cBoard.resetP(cBoard.XL, cBoard.XR, cBoard.YT, cBoard.YB);
        if (!cLockImg.checked) {
          cBoard.cleAllPointBorder();
          cBoard.printBorder();
        }
        else {
          cLockImg.setChecked(0);
          putImg();
        }
      });

      cSLTX = new button(imgCmdDiv, "select", w * 3.99, t, w, h);
      for (let i = 15; i >= 5; i--) {
        cSLTX.addOption(i, i);
      }
      cSLTX.show();
      cSLTX.setText(cSLTX.input.value + "\b列");
      cSLTX.setonchange(function(but) {
        but.setText(but.input.value + "\b列");
        cBoard.SLTX = but.input.value;
        cBoard.resetP(cBoard.XL, cBoard.XR, cBoard.YT, cBoard.YB);
        if (!cLockImg.checked) {
          cBoard.cleAllPointBorder();
          cBoard.printBorder();
        }
        else {
          cLockImg.setChecked(0);
          putImg();
        }
      });


      function nSetChecked(chk) {
        cAddblack2.setChecked(0);
        cAddwhite2.setChecked(0);
        chk.setChecked(1);
        if (!cLockImg.checked) { lockImg();
          cLockImg.setChecked(1) }
      }
    }












    //返回参数确认 添加棋子 还是标签
    function getRenjuCmd() {

      log("getRenjuCmd");

      let isShow = cShownum.checked ? true : false;
      let idx;
      let code;
      let tcode;
      let txt;
      switch (true) {

        case cAutoadd.checked:
          return { type: tNum, cmd: "auto", showNum: isShow };
        case cAddblack.checked:
          return { type: tBlack, cmd: "black", showNum: isShow };
        case cAddwhite.checked:
          return { type: tWhite, cmd: "white", showNum: isShow };
        case cLba.checked:
          return { type: tLb, cmd: "■", showNum: isShow };
        case cLbb.checked:
          return { type: tLb, cmd: "◎", showNum: isShow };
        case cLbc.checked:
          return { type: tLb, cmd: "▲", showNum: isShow };
        case cLbd.checked:
          return { type: tLb, cmd: "×", showNum: isShow };
        case cLABC.checked:

          switch (cLABC.input.value * 1) {
            case 0:
              // 搜索棋盘上最大的字母;
              code = "A".charCodeAt(); // 65→90
              for (idx = 0; idx < cBoard.SLTX * cBoard.SLTY; idx++) {
                if (cBoard.P[idx].type == tLb && cBoard.P[idx].text.length == 1) {
                  let tcode = cBoard.P[idx].text.charCodeAt(0);
                  if (tcode >= code && tcode <= 90) {
                    code = tcode < 90 ? tcode + 1 : tcode;
                  }
                }
              }
              txt = String.fromCharCode(code);
              return { type: tLb, cmd: txt, showNum: isShow };

            case 1:

              // 搜索棋盘上最大的字母;
              code = "a".charCodeAt(); // 65→90
              for (idx = 0; idx < cBoard.SLTX * cBoard.SLTY; idx++) {
                if (cBoard.P[idx].type == tLb && cBoard.P[idx].text.length == 1) {
                  tcode = cBoard.P[idx].text.charCodeAt(0);
                  if (tcode >= code && tcode <= 122) {
                    code = tcode < 122 ? tcode + 1 : tcode;
                  }
                }
              }
              txt = String.fromCharCode(code);
              return { type: tLb, cmd: txt, showNum: isShow };

            case 2:
              // 搜索棋盘上最大的数字
              code = 1 // 1-225;
              for (idx = 0; idx < cBoard.SLTX * cBoard.SLTY; idx++) {
                if (cBoard.P[idx].type == tLb) {
                  tcode = cBoard.P[idx].text * 1;
                  if (tcode >= code && tcode <= 225) {
                    code = tcode < 225 ? tcode + 1 : tcode;
                  }
                }
              }
              txt = code;
              return { type: tLb, cmd: txt, showNum: isShow };
            case 3:
              return { type: tLb, cmd: "☆", showNum: isShow };
          }
      }
      log("getRenjuCmd err");
    }




    function getRenjuLbColor() {

      return lbColor[cLbColor.input.value];
    }



    function getRenjuSelColor() {
      return cSelBlack.checked ? 1 : 2;
    }




    let timerCancelKeepTouch = null; // 防止悔棋触发取消红色显示
    let cancelKeepTouck = function() {
      if (timerCancelKeepTouch) return true;
      timerCancelKeepTouch = setTimeout("timerCancelKeepTouch=null", 800);
    }



    function renjuClick(x, y) {

      let idx = cBoard.getPIndex(x, y);
      log("rennuClick idx=" + idx);

      if (idx > -1) {
        log("P[IDX].type=" + cBoard.P[idx].type);

        let cmds = getRenjuCmd();
        switch (cmds.type) {
          case tNum:
            cancelKeepTouck();
            if (cBoard.P[idx].type == tNum) {
              //点击棋子，触发悔棋
              cBoard.cleNb(idx, cmds.showNum);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加棋子  wNb(idx,color,showNum)
              cBoard.wNb(idx, "auto", cmds.showNum);
            }
            break;

          case tBlack:
            if (cBoard.P[idx].type == tWhite || cBoard.P[idx].type == tBlack) {
              //点击棋子，触发悔棋
              cBoard.clePoint(idx);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加棋子  wNb(idx,color,showNum)
              cBoard.wNb(idx, "black", cmds.showNum);
            }
            break;

          case tWhite:
            if (cBoard.P[idx].type == tWhite || cBoard.P[idx].type == tBlack) {
              //点击棋子，触发悔棋
              cBoard.clePoint(idx);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加棋子  wNb(idx,color,showNum)
              cBoard.wNb(idx, "white", cmds.showNum);
            }
            break;

          case tLb:
            if (cBoard.P[idx].type == tLb) {
              // 点击标记，删除标记
              cBoard.clePoint(idx);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加标记 wLb(idx,text,color, showNum:isShow) 
              cBoard.wLb(idx, cmds.cmd, getRenjuLbColor());
            }
            break;
        }

      }

    }




    function renjuDblClick(x, y) {

      let idx = cBoard.getPIndex(x, y);
      log("renjuDblClick  idx==" + idx);
      if (idx > -1) {
        // 触发快速悔棋
        if (cBoard.P[idx].type == tNum) {
          log("renjuDblClick 连续悔棋");
          if (idx != cBoard.MS[cBoard.MSindex]) {
            for (let i = cBoard.MSindex + 1; i > parseInt(cBoard.P[idx].text); i--) {
              cBoard.cleNb(idx, cShownum.checked);
            }
          }
          else { // 
            if (!cancelKeepTouck()) renjuKeepTouch(x, y);
          }
        } // 触发，手动输入标记
        else if ((cBoard.P[idx].type == tLb || cBoard.P[idx].type == tEmpty) && !cAutoadd.checked && !cAddblack.checked && !cAddwhite.checked) {
          let w = cBoard.width * 0.8;
          let h;
          let l = (dw - w) / 2;
          let t = dh / 7;
          // 设置弹窗，让用户手动输入标记
          msg("", "input", l, t, w, h, "输入标记", null, function(msgStr) {
              if (msgStr == "") return;
              cBoard.clePoint(idx); // 清除原来标记，打印用户选定的标记
              cBoard.wLb(idx, msgStr.substr(0, 3), getRenjuLbColor());
            },
            function(msgStr) { //用户取消，删除标记
              cBoard.clePoint(idx);
            });

        }

      }
    }




    function renjuKeepTouch(x, y) {

      let idx = cBoard.getPIndex(x, y);
      if (idx < 0) return;
      let w = cBoard.width * 0.8;
      let h;
      let l = (dw - w) / 2;
      let t = dh / 7;

      switch (cBoard.P[idx].type) {
        case tNum:
          if (idx == cBoard.MS[cBoard.MSindex]) {
            let str = cBoard.notShowLastNum ? "确认恢复 最后一手红色显示。" : "确认取消 最后一手红色显示。";
            msg(str, null, null, null, null, null, null, null, function() {

              if (cBoard.setNotShowLastNum(idx)) {
                if (cShownum.checked) {
                  cBoard.showNum();
                }
                else {
                  cBoard.hideNum();
                }
              }
            }, null, 2);
          }
          break;
        case tLb:
          // 设置弹窗，让用户手动输入标记
          msg("", "input", l, t, w, h, "输入标记", null, function(msgStr) {
            if (msgStr == "") return;
            cBoard.clePoint(idx); // 清除原来标记，打印用户选定的标记
            cBoard.wLb(idx, msgStr.substr(0, 3), getRenjuLbColor());
          });
          break;
        case tEmpty:
          // 设置弹窗，让用户手动输入标记
          msg("", "input", l, t, w, h, "输入标记", null, function(msgStr) {
            if (msgStr == "") return;
            cBoard.clePoint(idx); // 清除原来标记，打印用户选定的标记
            cBoard.wLb(idx, msgStr.substr(0, 3), getRenjuLbColor());
          });
          break;

      }

    }




    function renjucShownumClick() {

      if (cShownum.checked) {
        cBoard.showNum();
      }
      else {
        cBoard.hideNum();
      }
    }
  </script>
  <SCRIPT Language='JavaScript'>
    var tempp = new point(0, 0, null);

    const tEmpty = 0;
    const tLb = 1; // 用于point.type,表示当前点上面存在一个标签
    const tNum = 2; // 用于point.type,表示当前点上面存在一个数字
    const tBlack = 3; // 无序号 添加的黑棋
    const tWhite = 4; // 无序号 添加的黑棋


    //定义棋盘上的一个点
    function point(x, y, d) {

      this.x = x; // 棋盘一个点的坐标，相对于BODY
      this.y = y;
      this.d = d; // 对div标签的引用，null为空;
      this.type = 0; // 这个点是否有棋子，=tEmpty为空，棋子=tNum,bi标记=tLb
      this.text = "";
      this.color = null;

    }


    //清空这个点上面的棋子，数字，标记              
    point.prototype.cle = function() {
      if (this.d != null) {
        this.d.innerHTML = "";
        this.d.style.background = "";
        this.d.style.borderStyle = 'none';
        this.d.style.zIndex = -100;
      }
      // this.d = null;
      this.type = 0;
      this.text = "";
      this.color = null;
      //alert("p.cle")
    }

    point.prototype.printBorder = function(gW, gH) {
      var size;
      var temp;
      //if (isTest) log("printBorder x=" +this.x+ " y=" +this.y + " gW=" + gW + " gH=" + gH);
      if (this.x == null || this.y == null) { return };
      temp = (gW < gH) ? gW : gH;
      size = parseInt(temp / 4 * 3.6);
      this.d.style.position = 'absolute';
      this.d.style.width = size + "px";
      this.d.style.height = size + "px";
      this.d.style.left = this.x - parseInt(size / 2);
      this.d.style.top = this.y - parseInt(size / 2);
      this.d.style.borderStyle = 'dashed';
      this.d.style.borderWidth = "1px";
      this.d.style.borderColor = 'red';
      this.d.style.zIndex = 0;

    }


    //在这个点上记一个标记
    point.prototype.printLb = function(s, color, gW, gH) {
      // alert("printLb")
      var size;
      var temp;
      this.type = tLb;
      this.text = s;
      this.color = color;

      this.d.innerHTML = this.text;
      temp = (gW < gH) ? gW : gH;
      size = parseInt(temp / 4 * 3);
      this.d.style.fontSize = size;
      this.d.style.color = color;
      this.d.style.position = 'absolute';
      this.d.style.background = '';
      this.d.style.width = size + "px";
      this.d.style.height = size + "px";
      this.d.style.lineHeight = size + "px";
      this.d.style.left = this.x - parseInt(size / 2);
      this.d.style.top = this.y - parseInt(size / 2);
      this.d.style.zIndex = 0;

    }


    // 在这个点上放一个棋子or数字;
    point.prototype.printNb = function(n, color, gW, gH) {
      var size;
      var temp;

      this.color = color;
      this.type = tNum;
      this.text = String(n);
      this.d.innerHTML = this.text;
      temp = (gW < gH) ? gW : gH;
      size = (color == 'black' || color == 'white') ? parseInt(temp / 4 * 1.5) : parseInt(temp / 4 * 3);
      this.d.style.fontSize = size
      size = parseInt(temp / 4 * 2);
      this.d.style.color = color == "white" ? "black" : "pink";
      this.d.style.position = 'absolute';
      this.d.style.background = (color == 'white') ? 'white' : (color == 'black') ? 'black' : "";
      this.d.style.width = size + "px";
      this.d.style.height = size + "px";
      this.d.style.lineHeight = size + "px";
      this.d.style.left = this.x - parseInt(size / 2);
      this.d.style.top = this.y - parseInt(size / 2);
      this.d.style.borderStyle = '';
      this.d.style.zIndex = 0;
      if (color == 'black' || color == 'white')
      {
        this.d.style.borderStyle = 'solid';
        this.d.style.borderWidth = "1px";
        this.d.style.borderColor = this.color;
        if (this.color == 'white') this.d.style.borderColor = 'black';
      }
    }


    //改变一个棋子or数字颜色
    point.prototype.setcolor = function(color) {
      this.printNb(parseInt(this.text), color);
    }


    //设置一个div标签
    point.prototype.setd = function(d) { this.d = d; }


    point.prototype.setxy = function(x, y) {
      this.x = x;
      this.y = y;
    }







    //定义一个棋盘
    function checkerBoard(parentNode, left, top, width, height) {

      this.parentNode = parentNode;
      this.left = left;
      this.top = top;
      this.width = width;
      this.height = height;

      this.isShowNum = true; // 是否显示手顺

      this.P = new Array(225); //用来保存225个点
      this.DIV = new Array(225); //原来保存225 DIV 标签的引用
      this.MS = []; //保存落子顺序,index
      this.MS.length = 0;
      this.MSindex = -1; //  指针，指向当前棋盘最后一手在MS索引   
      this.Moves = ""; // 保存棋谱代码;
      this.resetNum = 0; //重置显示的手数，控制从第几手开始显示序号
      this.notShowLastNum = false; // = true ,取消最后一手高亮显示
      this.alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

      this.XL = 0; //棋盘落子范围，左右上下的4条边
      this.XR = 0;
      this.YT = 0;
      this.YB = 0;
      this.gW = 0; //棋盘格子宽度,浮点数
      this.gH = 0; //棋盘格子高度,浮点数
      this.SLTX = 15;
      this.SLTY = 15; //默认是15×15棋盘;
      this.searchIdx = -1; // 记录正在计算的点

      this.backgroundColor = "#f0f0f0";

      if (isTest) log("new checkerBoard", "red");
      //页面显示的棋盘
      this.canvas = d.createElement("canvas");
      this.canvas.style.position = "absolute";
      if (width == null || height == null) {
        this.canvas.style.width = dw < dh ? dw : dh;
        this.canvas.style.height = this.canvas.style.width;
      }
      else {
        this.canvas.style.width = width;
        this.canvas.style.height = height;
      }
      this.canvas.style.left = left;
      this.canvas.style.top = top;
      this.parentNode.appendChild(this.canvas);

      //后台保存的空棋盘
      this.bakCanvas = d.createElement("canvas");
      this.bakCanvas.style.position = "absolute";
      this.bakCanvas.style.width = this.canvas.style.width;
      this.bakCanvas.style.height = this.canvas.style.height;
      this.bakCanvas.style.left = this.canvas.offsetLeft;
      this.bakCanvas.style.top = this.canvas.offsetTop;

      //后台裁剪图片的canvas
      this.cutCanvas = d.createElement("canvas");

      //后台处理图片的img     
      this.bakImg = d.createElement("img");
      this.bakImg.style.position = "absolute";
      this.cutImg = d.createElement("img");
      this.cutImg.style.position = "absolute";


      this.cutDiv = document.createElement("div");
      this.parentNode.appendChild(this.cutDiv);
      this.cutDiv.ontouchend = function() { event.preventDefault(); }
      this.cutDiv.ontouchmove = function() { if (timerContinueSetCutDiv) event.preventDefault(); }
      log("cutDiv = " + this.cutDiv);

      if (isTest) log("creatP start");
      for (var i = 0; i < 225; i++) {
        this.DIV[i] = document.createElement("div");
        this.DIV[i].style.borderRadius = '50%';
        this.parentNode.appendChild(this.DIV[i]);
        this.DIV[i].ontouchend = function() { event.preventDefault(); }
        this.DIV[i].ontouchmove = function() { if (timerContinueSetCutDiv) event.preventDefault(); }
        this.P[i] = new point(0, 0, this.DIV[i]);
      }
      log("creatP end");

      //this.resetCutDiv();

      log("new checkerBoard end");
    }



    // 将传入的二维数组顺时针90°
    checkerBoard.prototype.CW = function(arrobj, count) {

      let x;
      let y;
      let nx;
      let ny;
      //复制二维数组
      let arrs = [];
      for (y = 0; y < this.SLTY; y++) {

        arrs[y] = [];
        for (x = 0; x < this.SLTX; x++) {
          arrs[y][x] = arrobj[y][x];
        }

      }
      //旋转
      for (y = 0; y < this.SLTY; y++) {

        for (x = 0; x < this.SLTX; x++) {
          nx = this.SLTX - 1 - x;
          arrobj[y][x] = arrs[nx][y];
        }

      }

    }



    // 将传入的二维数组逆时针90°
    checkerBoard.prototype.CCW = function(arrobj, count) {

      let x;
      let y;
      let nx;
      let ny;
      //复制二维数组
      let arrs = [];
      for (y = 0; y < this.SLTY; y++) {

        arrs[y] = [];
        for (x = 0; x < this.SLTX; x++) {
          arrs[y][x] = arrobj[y][x];
        }

      }
      //旋转
      for (y = 0; y < this.SLTY; y++) {

        for (x = 0; x < this.SLTX; x++) {
          ny = this.SLTY - 1 - y;
          arrobj[y][x] = arrs[x][ny];
        }

      }

    }



    // 顺时针 翻转棋盘90°
    checkerBoard.prototype.boardCW = function(isShowNum) {

      let tMS = [];
      let tMS1 = [];
      let wMS = [];
      let bMS = [];
      let tMSindex = this.MSindex;
      let idx;
      let x;
      let y;
      let nx;
      let ny;

      for (let idx = 0; idx < this.SLTX * this.SLTY; idx++) {

        if (this.P[idx].type == tWhite) {
          wMS.push(idx);
        }
        else if (this.P[idx].type == tBlack) {
          bMS.push(idx);
        }
      }

      for (let j = 0; j < 3; j++) {
        tMS = [];
        tMS1 = j == 0 ? wMS : j == 1 ? bMS : this.MS;
        for (let i = 0; i < tMS1.length; i++) {

          idx = tMS1[i];

          y = parseInt(idx / this.SLTX);
          nx = this.SLTY - 1 - y; // 新的 x坐标是原来 y坐标的翻转;
          ny = idx % this.SLTX; // 旋转后新的 y坐标是原来的 x坐标

          idx = ny * this.SLTX + nx;
          tMS[i] = idx;

        }
        if (j == 0) {
          wMS = tMS.slice();
        }
        else if (j == 1) {
          bMS = tMS.slice();
        }
      }

      this.cle(); // 清空棋盘
      this.MS = tMS;

      //  打印棋盘
      for (let i = 0; i <= tMSindex; i++) {
        this.toNext(isShowNum);
      }
      for (let i = 0; i < wMS.length; i++) {
        this.wNb(wMS[i], "white");
      }
      for (let i = 0; i < bMS.length; i++) {
        this.wNb(bMS[i], "black");
      }


    }




    // 逆时针 翻转棋盘90°
    checkerBoard.prototype.boardCCW = function(isShowNum) {

      let tMS = [];
      let tMS1 = [];
      let wMS = [];
      let bMS = [];
      let tMSindex = this.MSindex;
      let idx;
      let x;
      let y;
      let nx;
      let ny;

      for (let idx = 0; idx < this.SLTX * this.SLTY; idx++) {

        if (this.P[idx].type == tWhite) {
          wMS.push(idx);
        }
        else if (this.P[idx].type == tBlack) {
          bMS.push(idx);
        }
      }

      for (let j = 0; j < 3; j++) {
        tMS = [];
        tMS1 = j == 0 ? wMS : j == 1 ? bMS : this.MS;
        for (let i = 0; i < tMS1.length; i++) {

          idx = tMS1[i]; // 取得旧的index
          // 新的 x坐标是原来 y坐标;   
          nx = parseInt(idx / this.SLTX);
          // 旋转后新的 y坐标是原来的 x坐标翻转
          x = idx % this.SLTX;
          ny = this.SLTX - 1 - x;
          // 求得新的index，暂时保存
          idx = ny * this.SLTX + nx;
          tMS[i] = idx;

        }
        if (j == 0) {
          wMS = tMS.slice();
        }
        else if (j == 1) {
          bMS = tMS.slice();
        }
      }

      this.cle(); // 清空棋盘
      this.MS = tMS;

      //  打印棋盘
      for (let i = 0; i <= tMSindex; i++) {
        this.toNext(isShowNum);
      }
      for (let i = 0; i < wMS.length; i++) {
        this.wNb(wMS[i], "white");
      }
      for (let i = 0; i < bMS.length; i++) {
        this.wNb(bMS[i], "black");
      }


    }




    // 上下 翻转棋盘
    checkerBoard.prototype.boardFlipX = function(isShowNum) {

      let tMS = [];
      let tMS1 = [];
      let wMS = [];
      let bMS = [];
      let tMSindex = this.MSindex;
      let idx;
      let x;
      let y;
      let nx;
      let ny;

      for (let idx = 0; idx < this.SLTX * this.SLTY; idx++) {

        if (this.P[idx].type == tWhite) {
          wMS.push(idx);
        }
        else if (this.P[idx].type == tBlack) {
          bMS.push(idx);
        }
      }

      for (let j = 0; j < 3; j++) {
        tMS = [];
        tMS1 = j == 0 ? wMS : j == 1 ? bMS : this.MS;
        for (let i = 0; i < tMS1.length; i++) {

          idx = tMS1[i]; // 取得旧的index

          nx = idx % this.SLTX; // 新的 x坐标是原来 x坐标不变;
          y = parseInt(idx / this.SLTX);
          ny = this.SLTY - 1 - y; // 旋转后新的 y坐标是原来的 y坐标翻转;

          idx = ny * this.SLTX + nx;
          tMS[i] = idx;

        }
        if (j == 0) {
          wMS = tMS.slice();
        }
        else if (j == 1) {
          bMS = tMS.slice();
        }
      }

      this.cle(); // 清空棋盘
      this.MS = tMS;

      //  打印棋盘
      for (let i = 0; i <= tMSindex; i++) {
        this.toNext(isShowNum);
      }
      for (let i = 0; i < wMS.length; i++) {
        this.wNb(wMS[i], "white");
      }
      for (let i = 0; i < bMS.length; i++) {
        this.wNb(bMS[i], "black");
      }

    }




    // 左右 翻转棋盘90°
    checkerBoard.prototype.boardFlipY = function(isShowNum) {

      let tMS = [];
      let tMS1 = [];
      let wMS = [];
      let bMS = [];
      let tMSindex = this.MSindex;
      let idx;
      let x;
      let y;
      let nx;
      let ny;

      for (let idx = 0; idx < this.SLTX * this.SLTY; idx++) {

        if (this.P[idx].type == tWhite) {
          wMS.push(idx);
        }
        else if (this.P[idx].type == tBlack) {
          bMS.push(idx);
        }
      }

      for (let j = 0; j < 3; j++) {
        tMS = [];
        tMS1 = j == 0 ? wMS : j == 1 ? bMS : this.MS;
        for (let i = 0; i < tMS1.length; i++) {

          idx = tMS1[i]; // 取得旧的index              

          x = idx % this.SLTX;
          nx = this.SLTX - 1 - x; // 新的 x坐标是原来 x坐标的翻转;
          ny = parseInt(idx / this.SLTX); // 新的 y坐标是原来的 y坐标不变;

          idx = ny * this.SLTX + nx;
          tMS[i] = idx;

        }
        if (j == 0) {
          wMS = tMS.slice();
        }
        else if (j == 1) {
          bMS = tMS.slice();
        }
      }

      this.cle(); // 清空棋盘
      this.MS = tMS;

      //  打印棋盘
      for (let i = 0; i <= tMSindex; i++) {
        this.toNext(isShowNum);
      }
      for (let i = 0; i < wMS.length; i++) {
        this.wNb(wMS[i], "white");
      }
      for (let i = 0; i < bMS.length; i++) {
        this.wNb(bMS[i], "black");
      }


    }







    // 清空棋盘上每一个点的显示，和记录
    checkerBoard.prototype.cle = function() {

      this.MSindex = -1;
      this.MS.length = 0;
      for (let i = 0; i < 225; i++) {
        this.clePoint(i);
      }

    }



    // 取消虚线显示棋子位置
    checkerBoard.prototype.cleAllPointBorder = function() {

      for (let i = 0; i < 225; i++) {
        this.DIV[i].style.borderStyle = 'none';
      }

    }



    // 删除一个标记
    checkerBoard.prototype.cleLb = function(idx) {

      if (typeof(idx) == "string" && idx == "all") {
        for (let i = 0; i < this.SLTX * this.SLTY; i++) {
          if (this.P[i].type == tLb) this.clePoint(i);
        }
      }
      else {
        if (this.P[idx].type == tLb) {
          this.clePoint(idx);
        }
      }
    }






    // 删除一颗棋子,不删除MS的记录
    checkerBoard.prototype.cleNb = function(idx, showNum) {

      if (this.P[idx].type == tNum) {

        let i = this.MSindex;
        if (i < 0) return;
        this.clePoint(this.MS[i]);
        this.MSindex--;
        this.showLastNum(showNum);

      }
    }



    // 清空棋盘对象记录的棋谱
    checkerBoard.prototype.cleMoves = function() {

      this.Moves = "";
    }





    //棋盘上清空一个棋子,标记的显示
    checkerBoard.prototype.clePoint = function(idx) {

      this.P[idx].cle(); // 清除点的数据
      // 棋盘上打印空点
      let p = tempp;
      p.setxy(this.P[idx].x, this.P[idx].y);
      let ctx = this.canvas.getContext("2d");
      ctx.drawImage(this.bakCanvas, p.x - (this.gW / 2), p.y - (this.gH / 2), this.gW, this.gH, p.x - (this.gW / 2), p.y - (this.gH / 2), this.gW, this.gH);
      ctx = null;
      if (renjuSave) renjuSave();
    }



    //把后台空棋盘的一个点的图像剪下来备用;
    checkerBoard.prototype.cutBkPoint = function(idx) {

      let p = tempp;
      p.setxy(this.P[idx].x, this.P[idx].y);
      let c = this.cutCanvas;
      c.width = this.gW;
      c.height = this.gH;
      let ctx = c.getContext("2d");

      ctx.drawImage(this.bakCanvas, p.x - (this.gW / 2), p.y - (this.gH / 2), this.gW, this.gH, 0, 0, this.gW, this.gH);
      ctx = null;
      return true;

    }



    // 二维数组上下反转
    checkerBoard.prototype.flipX = function(arrobj) {

      let x;
      let y;
      let nx;
      let ny;

      let arrs = [];
      for (y = 0; y < this.SLTY; y++) {

        arrs[y] = [];
        for (x = 0; x < this.SLTX; x++) {
          arrs[y][x] = arrobj[y][x];
        }

      }

      for (y = 0; y < this.SLTY; y++) {

        for (x = 0; x < this.SLTX; x++) {
          ny = this.SLTY - 1 - y;
          arrobj[y][x] = arrs[ny][x];
        }

      }

    }



    // 二维数组左右翻转
    checkerBoard.prototype.flipY = function(arrobj) {

      let x;
      let y;
      let nx;
      let ny;
      // 复制二维数组
      let arrs = [];
      for (y = 0; y < this.SLTY; y++) {

        arrs[y] = [];
        for (x = 0; x < this.SLTX; x++) {
          arrs[y][x] = arrobj[y][x];
        }

      }
      // 翻转
      for (y = 0; y < this.SLTY; y++) {

        for (x = 0; x < this.SLTX; x++) {
          nx = this.SLTX - 1 - x;
          arrobj[y][x] = arrs[y][nx];
        }

      }
    }





    //判断用户点击了棋盘上面的哪一个点，在返回这个点的index
    checkerBoard.prototype.getPIndex = function(x, y) {

      let i;
      let j;

      if (cBoard.isOut(x, y, this.canvas)) return -1;

      let p = tempp;
      p.setxy(x, y); // page 坐标 转 canvas 坐标
      this.xyPageToObj(p, this.canvas);
      x = p.x + parseInt(this.gW / 2);
      y = p.y + parseInt(this.gH / 2);
      i = parseInt((x - this.XL) / this.gW);
      if (i == this.SLTX) i--;
      j = parseInt((y - this.YT) / this.gH);
      if (j == this.SLTY) j--;
      return parseInt(this.SLTX * j + i);

    }





    // 当前棋盘显示的棋子， 转成棋谱 返回
    checkerBoard.prototype.getMoves = function(type) {

      var ml = "";
      if (type == tWhite || type == tBlack) {
        for (let idx = 0; idx < this.SLTX * this.SLTY; idx++) {
          if (this.P[idx].type == type) {
            ml += this.indexToName(idx);
          }
        }
      }
      else {
        for (let i = 0; i <= this.MSindex; i++) {
          ml = ml + this.indexToName(this.MS[i]);
        }
      }

      return ml.toUpperCase();
    }





    // 传一个一维 空数组进来转成二维数组，把当前棋盘MS记录写入数组
    checkerBoard.prototype.getPointArray = function(arrobj) {

      arrobj.length = this.SLTY;
      for (let i = 0; i < arrobj.length; i++) {
        arrobj[i] = [];
      }

      log("getPointArray arrobj=" + arrobj)
      let x;
      let y;
      for (let idx = 0; idx < this.SLTX * this.SLTY; idx++) {
        x = idx % this.SLTX;
        y = parseInt(idx / this.SLTX);

        if (this.P[idx].type == tNum) {
          arrobj[y][x] = this.P[idx].color == "black" ? 1 : 2;
        }
        else if (this.P[idx].type == tWhite) {
          arrobj[y][x] = 2;
        }
        else if (this.P[idx].type == tBlack) {
          arrobj[y][x] = 1;
        }
        else {
          arrobj[y][x] = 0;
        }
      }
      return arrobj;
    }





    // 取得一个点的平均颜色
    checkerBoard.prototype.getPointColor = function(x, y) {

      let idx = y ? this.getPIndex(x, y) : x;
      let w = parseInt(this.gW / 2);
      let h = parseInt(this.gH / 2);
      let l = parseInt(this.P[idx].x + (this.gW - w) / 2 - this.gW / 2);
      let t = parseInt(this.P[idx].y + (this.gH - h) / 2 - this.gH / 2);
      let r = 0;
      let g = 0;
      let b = 0;
      let ctx = this.canvas.getContext("2d");
      let c;
      let arr = []; //  记录彩色
      let narr = []; // 记录黑白色
      for (let i = 0; i < w; i++) {
        arr[i] = [];
        for (let j = 0; j < h; j++) {
          c = ctx.getImageData(l + i, t + j, 1, 1).data;
          //let black = (i>w/4*1.5 && i<w/4*2.5 || j>h/4*1.5 && j<h/4*2.5) && c[0]<50 && c[1]<50 && c[2]<50 ? -38 : 0;
          arr[i][j] = c;
          r += c[0];
          g += c[1];
          b += c[2];
          c = null;
        }
      }
      ctx = null;

      if (isLine((r + g + b) / h / w / 3, this)) {
        //alert("line")
        return ({ r: 255, g: 125, b: 255 }); //网格
      }
      else if (isLine((r + g + b) / h / w / 3 + 18, this)) {
        return ({ r: 255, g: 125, b: 255 }); //网格
      }
      else if (isLine((r + g + b) / h / w / 3 - 18, this)) {
        return ({ r: 255, g: 125, b: 255 }); //网格
      }
      else {
        //alert("not Line")
        return ({ r: r / w / h, g: g / w / h, b: b / w / h }); //不是网格
      }



      function isLine(cnum, cboard) {
        let tx;
        let ty; //网格的x，y 线
        let count = 0; // 记录黑点
        for (let i = 0; i < w; i++) {
          narr[i] = [];
          for (let j = 0; j < h; j++) {
            c = arr[i][j];
            if (c[0] < cnum && c[1] < cnum && c[2] < cnum) {
              narr[i][j] = 1;
              count++;
            }
            else {
              narr[i][j] = 0;
            }
          }
        }
        if (count > w * h / 8 * 3) return false;
        /*
            // 测试
        let str = idx+"\n";
        for (let j=0; j<h; j++)  {
            for (let i=0; i<w; i++)  {
                str+=narr[i][j];
            }
            str+="\n"
        }
        alert(str)
        */
        // 针对白底棋盘，搜索棋盘网格线
        if (y == null) {
          x = idx % cboard.SLTX;
          y = parseInt(idx / cboard.SLTX);
        }

        if (x == 0) {
          if (idx == 0) {
            if (right() && buttom()) return true;
          }
          else if (idx == cboard.SLTX * (cboard.SLTY - 1)) {
            if (right() && top()) return true;
          }
          else {
            if (right() && buttom() && top()) return true;
          }
        }
        else if (x == cboard.SLTX - 1) {
          if (idx == cboard.SLTX - 1) {
            if (left() && buttom()) return true;
          }
          else if (idx == cboard.SLTX * cboard.SLTY - 1) {
            if (left() && top()) return true;
          }
          else {
            if (left() && top() && buttom()) return true;
          }
        }
        else if (y == 0) {
          if (left() && right() && buttom()) return true;
        }
        else if (y == cboard.SLTY - 1) {
          if (left() && right() && top()) return true;
        }
        else {
          if (left() && right() && top() && buttom()) return true;
        }

        function left() {
          let i;
          let j;
          for (i = 0; i < h; i++) {
            let c = narr[0][i];
            if (c == 1) {
              if (ty != null) {
                if (Math.abs(i - ty) > h * 0.3 || Math.abs(i - ty) == 0) { return false; }
              }
              else {
                ty = i;
              }
              for (j = 1; j < w / 5; j++) {
                c = narr[j][i];
                if (c == 0 && narr[j + 2][i] == 0 && !(narr[j + 3][i] == 1 && narr[j + 4][i] == 1 && narr[j + 5][i] == 1)) break;
              }
              if (j >= w / 5) return true;
              return false;
            }
          }
          //alert("__left")
        }

        function right() {
          let i;
          let j;
          for (i = h - 1; i >= 0; i--) {
            let c = narr[w - 1][i];
            if (c == 1) {
              if (ty != null) {
                if (Math.abs(i - ty) > h * 0.3 || Math.abs(i - ty) == 0) { return false; }
              }
              else {
                ty = i;
              }
              for (j = w - 2; j > w * 4 / 5; j--) {
                c = narr[j][i];
                if (c == 0 && narr[j - 2][i] == 0 && !(narr[j - 3][i] == 1 && narr[j - 4][i] == 1 && narr[j - 5][i] == 1)) break;
              }
              if (j <= w * 4 / 5) return true;
              return false;
            }
          }
          //alert("__right")
        }

        function top() {
          let i;
          let j;
          for (i = 0; i < w; i++) {
            let c = narr[i][0];
            if (c == 1) {
              if (tx != null) {
                if (Math.abs(i - tx) > w * 0.3 || Math.abs(i - tx) == 0) { return false; }
              }
              else {
                tx = i;
              }
              for (j = 1; j < h / 5; j++) {
                c = narr[i][j];
                if (c == 0 && narr[i][j + 2] == 0 && !(narr[i][j + 3] == 1 && narr[i][j + 4] == 1 && narr[i][j + 5] == 1)) break;
              }
              if (j >= h / 5) return true;
              return false;
            }
          }
          //alert("__top")
        }

        function buttom() {
          let i;
          let j;
          for (i = w - 1; i >= 0; i--) {
            let c = narr[i][h - 1];
            if (c == 1) {
              if (tx != null) {
                if (Math.abs(i - tx) > w * 0.3 || Math.abs(i - tx) == 0) { return false; }
              }
              else {
                tx = i;
              }
              for (j = h - 2; j > h * 4 / 5; j--) {
                c = narr[i][j];
                if (c == 0 && narr[i][j - 2] == 0 && !(narr[i][j - 3] == 1 && narr[i][j - 4] == 1 && narr[i][j - 5] == 1)) break;
              }
              if (j <= h * 4 / 5) return true;
              return false;
            }
          }
          //alert("__buttom")
        }
      }

    }





    // 把棋盘图片转成SVG,返回SVG代码
    checkerBoard.prototype.getSVG = function() {

      let showNum = this.isShowNum;
      let size = 2000 / this.canvas.width;
      let svgText = `
                <svg role="img" xmlns="http://www.w3.org/2000/svg" style ="width:100％;height:100％" version="1.1" viewBox="0 0  ${this.canvas.width*size}  ${this.canvas.height*size}" >
                `;
      // 划竖线
      let x1;
      let x2;
      let y1;
      let y2;
      let lineWidth;
      let canvas = this.canvas;
      for (let i = 0; i < this.SLTX; i++) {
        lineWidth = (i == 0 || i == (this.SLTX - 1)) ? parseInt(canvas.width) * 4 / 1000 * size : parseInt(canvas.width) / 1000 * 2 * size;
        x1 = this.P[i].x * size;
        y1 = this.P[i].y * size;
        x2 = this.P[i + (this.SLTY - 1) * this.SLTX].x * size;
        y2 = this.P[i + (this.SLTY - 1) * this.SLTX].y * size;
        svgText += ` <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke='black' stroke-width='${lineWidth}' />`;
      }
      // 划横线
      for (let j = 0; j < this.SLTY; j++) {
        lineWidth = (j == 0 || j == (this.SLTY - 1)) ? parseInt(canvas.width) * 4 / 1000 * size : parseInt(canvas.width) / 1000 * 2 * size;
        x1 = this.P[j * this.SLTX].x * size;
        y1 = this.P[j * this.SLTX].y * size;
        x2 = this.P[j * this.SLTX + this.SLTX - 1].x * size;
        y2 = this.P[j * this.SLTX + this.SLTX - 1].y * size;
        svgText += ` <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke='black' stroke-width='${lineWidth}' />`;
      }
      //画星位
      if (this.SLTX == 15 && this.SLTY == 15) {
        let r = parseInt(canvas.width) / 1000 * 6 * size;
        for (i = 48; i < 225; i += 120) {
          for (j = 0; j < 9; j += 8) {
            x1 = this.P[i + j].x * size;
            y1 = this.P[i + j].y * size;
            svgText += `<circle cx="${x1}" cy="${y1}" r="${r}" stroke="black" stroke-width="0" fill="black"/> `;
          }
        }
        x1 = this.P[112].x * size;
        y1 = this.P[112].y * size;
        svgText += `<circle cx="${x1}" cy="${y1}" r="${r}" stroke="black" stroke-width="0" fill="black"/> `;
      }

      //打印棋盘坐标
      let m;
      for (let i = 0; i < this.SLTX; i++) {
        for (let j = 0; j <= this.SLTX * (this.SLTY - 1); j += this.SLTX * (this.SLTY - 1)) {

          m = j == 0 ? -this.gH : this.gH;
          x1 = this.P[i + j].x * size;
          y1 = (this.P[i + j].y + m) * size;
          svgText += ` <text x="${x1}" y="${y1}" font-weight="bold" font-family="微软雅黑"  font-size="${this.gW*0.5*size}" text-anchor="middle" dominant-baseline="central">${this.alpha.charAt(i)}</text>`;

        }
      }
      for (let i = 0; i < this.SLTY; i++) {
        for (let j = 0; j <= this.SLTX - 1; j += this.SLTX - 1) {

          m = j == 0 ? -this.gW : this.gW;
          x1 = (this.P[i * this.SLTX + j].x + m) * size;
          y1 = this.P[i * this.SLTX + j].y * size;
          svgText += ` <text x="${x1}" y="${y1}" font-weight="bold" font-family="微软雅黑" font-size="${this.gW*0.5*size}" text-anchor="middle" dominant-baseline="central">${String(this.SLTY-i)}</text>`;

        }
      }

      // 打印棋子，和标记
      for (let i = 0; i < this.SLTY * this.SLTX; i++) {
        let w = this.gW < this.gH ? this.gW / 2 * 0.85 : this.gH / 2 * 0.85;
        if (this.P[i].type == tNum || this.P[i].type == tWhite || this.P[i].type == tBlack) {
          lineWidth = w / 25;
          svgText += ` <circle cx="${this.P[i].x*size}" cy="${this.P[i].y*size}" r="${w*size}" stroke="black" stroke-width="${lineWidth*size}" fill="${this.P[i].color}"/> `;
          /*
           if (this.P[i].type==tNum) {
               let color = this.P[i].color=="white" ? "black" : "white";
               svgText += ` <text x="${this.P[i].x*size}" y="${this.P[i].y*size}" stroke="${color}" fill="${color}" font-weight="bold" font-family="微软雅黑" font-size="${this.gW*0.5*size}" text-anchor="middle" dominant-baseline="central">${this.P[i].text}</text>`;
           }
          */
        }
        else if (this.P[i].type == tLb) {
          svgText += ` <circle cx="${this.P[i].x*size}" cy="${this.P[i].y*size}" r="${this.P[i].text.length>1 ? w*size : w/2*size}" stroke="White" stroke-width="${3*size}" fill="White"/> `;
          //svgText += ` <text x="${this.P[i].x*size}" y="${this.P[i].y*size}" stroke="${this.P[i].color}" fill="${this.P[i].color}" font-weight="bolder" font-family="微软雅黑" font-size="${this.gW*0.5*size}" text-anchor="middle" dominant-baseline="central">${this.P[i].text}</text>`;
        }

        let txt = this.P[i].text;
        let color = this.P[i].color;
        if (this.P[i].type == tNum) { //控制从第几手显示❶
          txt = parseInt(this.P[i].text) - this.resetNum;
          txt = parseInt(txt) < 1 ? "" : txt;
          txt = showNum ? txt : "";
          color = this.P[i].color == "white" ? "black" : "white";
          if (this.MSindex >= 0 && this.MS[this.MSindex] == i) {
            color = this.notShowLastNum ? color : "#ff6666";
            txt = !showNum && !this.notShowLastNum ? "◤" : txt;

          }
        }

        let fontsize = parseInt(w * 1.08);
        x1 = this.P[i].x;
        y1 = this.P[i].y;
        if (txt.length == 1) { // 两位数数数字不需要放大字体
          let code = txt.charCodeAt();
          // 再把一位数字排除
          if (code < "0".charCodeAt() || code > "9".charCodeAt()) {
            if (txt == "▲" || txt == "■" || txt == "☆" || txt == "◎" || txt == "✖") {
              fontsize = parseInt(w * 1.1);
            }
            else if (txt == "◤") {
              x1 -= w * 0.15;
              y1 -= w * 0.15;
            }
            else { // 把数字和特殊标记排除，其它一位字符统一放大字体
              fontsize = parseInt(w * 1.5);
            }
          }
        }
        svgText += ` <text x="${x1*size}" y="${y1*size}" stroke="${color}" fill="${color}" font-weight="bolder" font-family="微软雅黑" font-size="${fontsize*size}" text-anchor="middle" dominant-baseline="central">${txt}</text>`;
      }

      svgText += "</svg>";
      return svgText;
    }






    // 顺序棋盘上棋子，隐藏手数
    checkerBoard.prototype.hideNum = function() {

      let color;
      for (let i = 0; i <= this.MSindex; i++)
      {
        color = (i % 2) ? 'white' : 'black';
        this.printPoint(this.MS[i], "", color, tNum);
      }

    }




    checkerBoard.prototype.hideCutDiv = function() {

      this.cutDiv.style.borderStyle = 'none';
      this.cutDiv.style.zIndex = -100;
    }




    // P 数组的index ，转字母数字坐标
    checkerBoard.prototype.indexToName = function(idx) {

      let x = (idx % this.SLTX);
      let y = parseInt(idx / this.SLTY);
      return (this.alpha.charAt(x) + (15 - y)).toLowerCase();
    }






    //  判断坐标是否出界，出界返回 true
    checkerBoard.prototype.isOut = function(x, y, htmlObj) {
      let xL = 0;
      let xR = xL + parseInt(htmlObj.style.width);
      let yT = 0;
      let yB = yT + parseInt(htmlObj.style.height);
      let p = tempp;
      p.setxy(x, y);
      this.xyPageToObj(p, htmlObj);
      x = p.x;
      y = p.y;

      if (x < xL || x > xR || y < yT || y > yB)
      {
        return true;
      }
      return false;
    }




    // 字母数字坐标，返回 P数组的index
    checkerBoard.prototype.nameToIndex = function(name) {

      log("nameToIndex str......name=" + name);
      let x = name.toLowerCase().charCodeAt() - 'a'.charCodeAt();
      name = name.substr(1);
      let y = this.SLTY - name; //转换成第一行为0，依次为1,2,3...

      log("x=" + x + "   y=" + y);
      return x + y * this.SLTX;

    }


    // 平移棋盘
    checkerBoard.prototype.moveCheckerBoard = function(move) {

      let i;
      let j;
      let idx;
      switch (move) {
        case "left":
          for (i = 0; i < this.SLTX * this.SLTY; i += this.SLTX) {
            if (this.P[i].type != tEmpty) break;
          }
          if (i < this.SLTX * this.SLTY) return;
          // 转换MS数组
          for (i = 0; i < this.MS.length; i++) { this.MS.length = this.MSindex + 1;
            this.MS[i] = this.MS[i] - 1; }
          // 复制棋盘每个落子点
          for (i = 1; i < this.SLTX; i++) {
            for (j = 0; j < this.SLTY; j++) {
              idx = i + j * this.SLTX;
              copyP(this, idx - 1, idx);
            }
          }
          break;
        case "right":
          for (i = this.SLTX - 1; i < this.SLTX * this.SLTY; i += this.SLTX) {
            if (this.P[i].type != tEmpty) break;
          }
          if (i < this.SLTX * this.SLTY) return;
          for (i = 0; i < this.MS.length; i++) { this.MS.length = this.MSindex + 1;
            this.MS[i] = this.MS[i] + 1; }
          for (i = this.SLTX - 2; i >= 0; i--) {
            for (j = 0; j < this.SLTY; j++) {
              idx = i + j * this.SLTX;
              copyP(this, idx + 1, idx);
            }
          }
          break;
        case "top":
          for (i = 0; i < this.SLTX; i++) {
            if (this.P[i].type != tEmpty) break;
          }
          if (i < this.SLTX) return;
          for (i = 0; i < this.MS.length; i++) { this.MS.length = this.MSindex + 1;
            this.MS[i] = this.MS[i] - this.SLTX; }
          for (i = 1; i < this.SLTY; i++) {
            for (j = 0; j < this.SLTX; j++) {
              idx = i * this.SLTY + j;
              copyP(this, idx - this.SLTX, idx);
            }
          }
          break;
        case "bottom":
          for (i = this.SLTX * (this.SLTY - 1); i < this.SLTX * this.SLTY; i++) {
            if (this.P[i].type != tEmpty) break;
          }
          if (i < this.SLTX * this.SLTY) return;
          for (i = 0; i < this.MS.length; i++) { this.MS.length = this.MSindex + 1;
            this.MS[i] = this.MS[i] + this.SLTX; }
          for (i = this.SLTY - 2; i >= 0; i--) {
            for (j = 0; j < this.SLTX; j++) {
              idx = i * this.SLTY + j;
              copyP(this, idx + this.SLTX, idx);
            }
          }
          break;
      }

      this.MSToMoves();

      // 复制一个点，同时打印出来
      function copyP(board, idx, idx1) {
        board.P[idx].text = board.P[idx1].text;
        board.P[idx].type = board.P[idx1].type;
        board.P[idx].color = board.P[idx1].color;
        if (board.P[idx].type != tEmpty) {
          let txt = board.P[idx].text;
          if (board.P[idx].type == tNum) { //控制从第几手显示❶
            txt = parseInt(board.P[idx].text) - board.resetNum;
            txt = parseInt(txt) < 1 ? "" : txt;
            txt = board.isShowNum ? txt : "";
          }
          board.printPoint(idx, txt, board.P[idx].color, board.P[idx].type, board.isShowNum);
          board.clePoint(idx1);
        }
      }
    }




    // MS 数组记录 转成棋谱代码
    checkerBoard.prototype.MSToMoves = function() {

      this.Moves = "";
      for (let i = 0; i <= this.MSindex; i++) {
        this.Moves += this.indexToName(this.MS[i]);
      }
      log("MSToMoves()  Moves=" + this.Moves);
    }




    checkerBoard.prototype.printArray = function(arr, txt, color) {

      let idx = 0;
      for (let y = 0; y < this.SLTY; y++) {
        for (let x = 0; x < this.SLTX; x++) {

          if (arr[y][x] > 0) {
            this.wLb(y * this.SLTX + x, txt, color);
          }
        }
      }
    }




    //  用虚线表示棋子的位置
    checkerBoard.prototype.printBorder = function() {

      log('printBorder start');
      for (let i = 0; i < this.SLTX * this.SLTY; i++)
      {
        if (this.P[i] != null) this.P[i].printBorder(this.gW, this.gH);
      }
      log('printBorder end');
    }



    // 打印棋盘坐标
    checkerBoard.prototype.printCoordinate = function(t, r, d, l) {

      t = t == null ? true : Boolean(t);
      r = r == null ? true : Boolean(r);
      d = d == null ? true : Boolean(d);
      l = l == null ? true : Boolean(l);
      let alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let p = tempp;
      let m;
      let ctx = this.bakCanvas.getContext("2d");
      ctx.fillStyle = "#000";
      ctx.font = parseInt(this.gW * 0.5) + "px 微软雅黑";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (let i = 0; i < this.SLTX; i++) {
        for (let j = 0; j <= this.SLTX * (this.SLTY - 1); j += this.SLTX * (this.SLTY - 1)) {

          m = j == 0 ? -this.gH : this.gH;
          p.setxy(this.P[i + j].x, this.P[i + j].y + m);

          ctx.fillText(alpha.charAt(i), p.x, p.y);


        }
      }
      for (let i = 0; i < this.SLTY; i++) {
        for (let j = 0; j <= this.SLTX - 1; j += this.SLTX - 1) {

          m = j == 0 ? -this.gW : this.gW;
          p.setxy(this.P[i * this.SLTX + j].x + m, this.P[i * this.SLTX + j].y);

          ctx.fillText(String(this.SLTY - i), p.x, p.y);


        }
      }
      ctx = null;
    }




    // 画空棋盘
    checkerBoard.prototype.printCheckerBoard = function() {

      this.SLTX = 15;
      this.SLTY = this.SLTX;
      let canvas = this.bakCanvas; // 准备在后台画棋盘
      let siz = (this.SLTX - 1) * 9 / 14 + 2;
      this.XL = parseInt(parseInt(this.width) / siz);
      this.XR = parseInt(parseInt(this.width) / siz * (siz - 1));
      this.YT = parseInt(parseInt(this.height) / siz);
      this.YB = parseInt(parseInt(this.height) / siz * (siz - 1));

      this.resetP(this.XL, this.XR, this.YT, this.YB);
      log("xl=" + this.XL + " XR=" + this.XR + " YT=" + this.YT + " YB=" + this.YB)
      // 画图之前，设置画布大小
      canvas.width = parseInt(this.width);
      canvas.height = parseInt(this.height);
      let ctx = canvas.getContext("2d");
      ctx.fillStyle = this.backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000";
      let p = tempp;
      // 划竖线
      for (let i = 0; i < this.SLTX; i++) {
        ctx.lineWidth = (i == 0 || i == (this.SLTX - 1)) ? parseInt(canvas.width) * 4 / 1000 : parseInt(canvas.width) / 1000 * 2;
        p.setxy(this.P[i].x, this.P[i].y);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        p.setxy(this.P[i + (this.SLTY - 1) * this.SLTX].x, this.P[i + (this.SLTY - 1) * this.SLTX].y);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
      // 划横线
      for (let j = 0; j < this.SLTY; j++) {
        ctx.lineWidth = (j == 0 || j == (this.SLTY - 1)) ? parseInt(canvas.width) * 4 / 1000 : parseInt(canvas.width) / 1000 * 2;
        p.setxy(this.P[j * this.SLTX].x, this.P[j * this.SLTX].y);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        p.setxy(this.P[j * this.SLTX + this.SLTX - 1].x, this.P[j * this.SLTX + this.SLTX - 1].y);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
      ctx.stroke();
      //画星位
      if (this.SLTX == 15 && this.SLTY == 15) {

        for (i = 48; i < 225; i += 120) {
          for (j = 0; j < 9; j += 8) {
            p.setxy(this.P[i + j].x, this.P[i + j].y);
            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.arc(p.x, p.y, parseInt(canvas.width) / 1000 * 6, 0, 2 * Math.PI);
            ctx.fill();
            //ctx.stroke();
          }
        }
        p.setxy(this.P[112].x, this.P[112].y);
        ctx.beginPath();
        ctx.fillStyle = "#000";
        ctx.arc(p.x, p.y, parseInt(canvas.width) / 1000 * 6, 0, 2 * Math.PI);
        ctx.fill();
        //ctx.stroke();

      }

      this.printCoordinate(); // 打印棋盘坐标

      //把后台的图片显示出来
      let canvas2 = this.canvas;
      ctx = null;
      ctx = canvas2.getContext("2d");
      canvas2.width = canvas.width;
      canvas2.height = canvas.height;
      canvas2.style.width = canvas.width;
      canvas2.style.height = canvas.height;
      //图片转移后，重新设置每个点的坐标
      ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
      /*this.XL += canvas2.offsetLeft - canvas.offsetLeft ;
      this.XR += canvas2.offsetLeft - canvas.offsetLeft ;
      this.YT += canvas2.offsetTop - canvas.offsetTop ;
      this.YB += canvas2.offsetTop - canvas.offsetTop ;
      this.resetP();*/

      //this.printBorder();
    }




    // 在棋盘上面打印一个VCF手顺   
    checkerBoard.prototype.printMoves = function(moves, firstColor) {

      let idx = 0;
      for (let y = 0; y < this.SLTY; y++) {
        for (let x = 0; x < this.SLTX; x++) {
          idx = y * this.SLTX + x;
          if (this.P[idx].type == tLb) {
            this.clePoint(idx);
          }
        }
      }
      for (let i = 0; i < moves.length; i++) {
        let color;
        if (firstColor == 1) {
          color = i % 2 ? "#9e9999" : "black";
        }
        else {
          color = i % 2 ? "black" : "#9e9999";
        }
        this.wLb(moves[i], i + 1, color);
      }
    }



    // 在PDF文档画棋盘
    checkerBoard.prototype.printPDF = function(doc, fontName) {

      fontName = fontName || "arial";
      let showNum = this.isShowNum;
      let left = 594 * 0.0252525;
      let top = (840 - (594 - left * 2)) / 2;
      let size = (594 - left * 2) / this.canvas.width;

      // 划竖线
      let x1;
      let x2;
      let y1;
      let y2;
      let lineWidth;
      let canvas = this.canvas;
      for (let i = 0; i < this.SLTX; i++) {
        lineWidth = (i == 0 || i == (this.SLTX - 1)) ? parseInt(canvas.width) * 4 / 1000 * size : parseInt(canvas.width) / 1000 * 2 * size;
        x1 = left + this.P[i].x * size;
        y1 = top + this.P[i].y * size;
        x2 = left + this.P[i + (this.SLTY - 1) * this.SLTX].x * size;
        y2 = top + this.P[i + (this.SLTY - 1) * this.SLTX].y * size;

        doc.setLineWidth(lineWidth);
        doc.setDrawColor(0, 0, 0);
        doc.line(x1, y1, x2, y2);
        //svgText += ` <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke='black' stroke-width='${lineWidth}' />` ;
      }
      // 划横线
      for (let j = 0; j < this.SLTY; j++) {
        lineWidth = (j == 0 || j == (this.SLTY - 1)) ? parseInt(canvas.width) * 4 / 1000 * size : parseInt(canvas.width) / 1000 * 2 * size;
        x1 = left + this.P[j * this.SLTX].x * size;
        y1 = top + this.P[j * this.SLTX].y * size;
        x2 = left + this.P[j * this.SLTX + this.SLTX - 1].x * size;
        y2 = top + this.P[j * this.SLTX + this.SLTX - 1].y * size;

        doc.setLineWidth(lineWidth);
        doc.setDrawColor(0, 0, 0);
        doc.line(x1, y1, x2, y2);
        //svgText += ` <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke='black' stroke-width='${lineWidth}' />` ;
      }
      //画星位
      if (this.SLTX == 15 && this.SLTY == 15) {
        let r = parseInt(canvas.width) / 1000 * 6 * size;
        for (i = 48; i < 225; i += 120) {
          for (j = 0; j < 9; j += 8) {
            x1 = left + this.P[i + j].x * size;
            y1 = top + this.P[i + j].y * size;
            doc.setFillColor(0, 0, 0);
            doc.circle(x1, y1, r, "F");
            //svgText += `<circle cx="${x1}" cy="${y1}" r="${r}" stroke="black" stroke-width="0" fill="black"/> `;
          }
        }
        x1 = left + this.P[112].x * size;
        y1 = top + this.P[112].y * size;
        doc.setFillColor(0, 0, 0);
        doc.circle(x1, y1, r, "F");
        //	svgText += `<circle cx="${x1}" cy="${y1}" r="${r}" stroke="black" stroke-width="0" fill="black"/> `;
      }

      //打印棋盘坐标
      let m;
      for (let i = 0; i < this.SLTX; i++) {
        for (let j = 0; j <= this.SLTX * (this.SLTY - 1); j += this.SLTX * (this.SLTY - 1)) {

          m = j == 0 ? -this.gH : this.gH;
          x1 = left + this.P[i + j].x * size;
          y1 = top + (this.P[i + j].y + m) * size;
          y1 += (this.gW * 0.5 * 0.35) * size;
          doc.setFont(fontName);
          doc.setTextColor(0, 0, 0);
          doc.setFontSize(parseInt(this.gW * 0.5 * size));
          doc.setFontType("bold");
          doc.text(this.alpha.charAt(i), x1, y1, "center");

        }
      }
      for (let i = 0; i < this.SLTY; i++) {
        for (let j = 0; j <= this.SLTX - 1; j += this.SLTX - 1) {

          m = j == 0 ? -this.gW : this.gW;
          x1 = left + (this.P[i * this.SLTX + j].x + m) * size;
          y1 = top + this.P[i * this.SLTX + j].y * size;
          y1 += (this.gW * 0.5 * 0.35) * size;
          doc.setFont(fontName);
          doc.setTextColor(0, 0, 0);
          doc.setFontSize(parseInt(this.gW * 0.5 * size));
          doc.setFontType("bold");
          doc.text(String(this.SLTY - i), x1, y1, "center");

        }
      }

      // 打印棋子，和标记
      for (let i = 0; i < this.SLTY * this.SLTX; i++) {
        let w = this.gW < this.gH ? this.gW / 2 * 0.85 : this.gH / 2 * 0.85;
        if (this.P[i].type == tNum || this.P[i].type == tWhite || this.P[i].type == tBlack) {
          lineWidth = w / 25;
          doc.setLineWidth(lineWidth * size);
          doc.setDrawColor(0, 0, 0);
          if (this.P[i].color == "white") {
            doc.setFillColor(255, 255, 255);
          }
          else {
            doc.setFillColor(0, 0, 0);
          }
          x1 = left + this.P[i].x * size;
          y1 = top + this.P[i].y * size;
          doc.circle(x1, y1, w * size, "DF");
          //svgText += ` <circle cx="${this.P[i].x*size}" cy="${this.P[i].y*size}" r="${w*size}" stroke="black" stroke-width="${lineWidth*size}" fill="${this.P[i].color}"/> `;
        }
        else if (this.P[i].type == tLb) {
          doc.setLineWidth(3 * size);
          doc.setDrawColor(255, 255, 255);
          doc.setFillColor(255, 255, 255);
          x1 = left + this.P[i].x * size;
          y1 = top + this.P[i].y * size;
          doc.circle(x1, y1, this.P[i].text.length > 1 ? w * size : w / 2 * size, "FD");
          //svgText += ` <circle cx="${this.P[i].x*size}" cy="${this.P[i].y*size}" r="${this.P[i].text.length>1 ? w*size : w/2*size}" stroke="White" stroke-width="${3*size}" fill="White"/> `;
        }

        let txt = this.P[i].text;
        let color = this.P[i].color;
        if (this.P[i].type == tNum) { //控制从第几手显示❶
          txt = parseInt(this.P[i].text) - this.resetNum;
          txt = parseInt(txt) < 1 ? "" : txt;
          txt = showNum ? txt : "";
          color = this.P[i].color == "white" ? "black" : "white";
          if (this.MSindex >= 0 && this.MS[this.MSindex] == i) {
            color = this.notShowLastNum ? color : "#ff6666";
            txt = !showNum && !this.notShowLastNum ? "◤" : txt;

          }
        }

        let fontsize = w * 1.08;
        x1 = this.P[i].x;
        y1 = this.P[i].y;
        if (txt.length == 1) { // 两位数数数字不需要放大字体
          let code = txt.charCodeAt();
          // 再把一位数字排除
          if (code < "0".charCodeAt() || code > "9".charCodeAt()) {
            if (txt == "▲" || txt == "■" || txt == "☆" || txt == "◎" || txt == "✖") {
              fontsize = w * 1.1;
            }
            else if (txt == "◤") {
              x1 -= w * 0.15;
              y1 -= w * 0.15;
            }
            else { // 把数字和特殊标记排除，其它一位字符统一放大字体
              fontsize = w * 1.5;
            }
          }
        }

        switch (String(color)) {
          case "white":
            doc.setTextColor(255, 255, 255);
            break;
          case "black":
            doc.setTextColor(0, 0, 0);
            break;
          case "red":
            doc.setTextColor(255, 0, 0);
            break;
          case "green":
            doc.setTextColor(0, 180, 0);
            break;
          case "#ff6666":
            doc.setTextColor(255, 0, 0);
            break;
          case "#9e9999":
            doc.setTextColor(157, 153, 153);
            break;
          case "blue":
            doc.setTextColor(0, 0, 255);
            break;
        }
        if (txt == "❌") { // 不支持的字符
          txt = "×";
          doc.setTextColor(150, 0, 0);
        }
        doc.setFont(fontName);
        doc.setFontSize(parseInt(fontsize * size));
        doc.setFontType("bold");
        x1 = left + x1 * size;
        y1 = top + y1 * size;
        y1 += (fontsize / 2 - fontsize * 0.15) * size; // 垂直居中
        doc.text(String(txt), x1, y1, "center");
        //svgText += ` <text x="${x1*size}" y="${y1*size}" stroke="${color}" fill="${color}" font-weight="bolder" font-family="微软雅黑" font-size="${fontsize*size}" text-anchor="middle" dominant-baseline="central">${txt}</text>`;
      }

    }





    // 在棋盘上打印一个点
    checkerBoard.prototype.printPoint = function(idx, text, color, type, showNum) {
      let p = tempp;
      let w = this.gW < this.gH ? this.gW / 2 * 0.85 : this.gH / 2 * 0.85;
      let ctx = this.canvas.getContext("2d");
      p.setxy(this.P[idx].x, this.P[idx].y);
      // 打印棋子
      if (type == tNum || type == tWhite || type == tBlack) {
        ctx.lineWidth = w / 25;
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.arc(p.x, p.y, w, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill(); // 填充
        ctx.stroke(); // 描边
        ctx.fillStyle = color == "white" ? "black" : color == "black" ? "white" : color;
        ctx.font = "bolder " + parseInt(w * 1.08) + "px  微软雅黑";
      }
      else { //  打印标签
        ctx.beginPath();
        ctx.fillStyle = this.backgroundColor;
        ctx.arc(p.x, p.y, text.length > 1 ? w : w / 2, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = color;
        ctx.font = "bolder " + parseInt(w * 1.1) + "px  微软雅黑";
      }

      ctx.font = "bolder " + parseInt(w * 1.08) + "px  微软雅黑";
      if (text.length == 1) { // 两位数数数字不需要放大字体
        let code = text.charCodeAt();
        // 再把一位数字排除
        if (code < "0".charCodeAt() || code > "9".charCodeAt()) {
          if (text == "▲" || text == "■" || text == "☆" || text == "◎" || text == "✖") {
            ctx.font = "bolder " + parseInt(w * 1.1) + "px  微软雅黑";
          }
          else { // 把数字和特殊标记排除，其它一位字符统一放大字体
            ctx.font = "bolder " + parseInt(w * 1.5) + "px  微软雅黑";
          }
        }
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, p.x, p.y);

      if (type == tNum) {
        this.showLastNum(showNum);
      }
      ctx = null;
      if (renjuSave) renjuSave();
      return true;
    }




    // 在棋盘上打印当前正在计算的点
    checkerBoard.prototype.printSearchPoint = function(idx, text, color) {

      //清除旧标记
      if (this.searchIdx > -1 && this.searchIdx != idx) {
        this.cleLb(this.searchIdx);
        this.searchIdx = -1;
      }
      //写入新标记
      if (idx > -1) {
        this.searchIdx = idx;
        this.wLb(idx, text, color);
      }
    }



    // 涂鸦模式，边框初始化
    checkerBoard.prototype.resetCutDiv = function() {
      log("resetCut start");
      canvas = this.canvas;
      let w = parseInt(canvas.width);
      let h = parseInt(canvas.height);
      let XL = w / 3;
      let XR = w / 3 * 2;
      let YT = h / 3;
      let YB = h / 3 * 2;
      let div = this.cutDiv;
      let s = this.cutDiv.style;
      s.position = 'absolute';
      s.borderStyle = 'dashed';
      s.borderWidth = '3px';
      s.borderColor = 'red';
      s.zIndex = 0;
      s.width = XR - XL;
      s.height = YB - YT;
      s.left = XL;
      s.top = YT;

      /*
      if (XR == 0  || YB == 0)  {
          s.width = '300px';
          s.height = '300px';
          s.left = canvas.offsetLeft;
          log ("div_left=" + s.left);
          s.top = canvas.offsetTop;
      }
      */

      this.XL = div.offsetLeft;
      this.XR = XL + parseInt(s.width);
      this.YT = div.offsetTop;
      this.YB = YT + parseInt(s.height);
      this.resetP(this.XL, this.XR, this.YT, this.YB);
      this.printBorder();
      log("resetCut end");
    }

    // 后台设置棋盘所有点的坐标。不会改变棋盘的显示
    checkerBoard.prototype.resetP = function(xL, xR, yT, yB) {
      let i;
      let j;
      let l;
      let x;
      let y;
      if (xL == null || xR == null || yT == null || yB == null) {
        xL = this.XL;
        xR = this.XR;
        yT = this.YT;
        yB = this.YB;
      }
      let SLTY = this.SLTY;
      let SLTX = this.SLTX;
      log("resetP STA");
      //cleP();
      this.gW = (xR - xL) / (SLTX - 1);
      this.gH = (yB - yT) / (SLTY - 1);

      for (j = 0; j < SLTY; j++)
      {
        y = j == (SLTY - 1) ? yB : parseInt(this.gH * j) + yT;
        for (i = 0; i < SLTX; i++)
        {
          x = i == (SLTX - 1) ? xR : parseInt(this.gW * i) + xL;
          l = j * SLTX + i;
          this.P[l].setxy(x, y);
        }
      }
      log(xL + "-" + xR + "-" + yT + "-" + yB)
      log("resetP end gW=" + String(this.gW) + "gH=" + String(this.gH));

    }




    checkerBoard.prototype.saveAsImage = function(type) {

      let canvas = this.canvas;
      let downloadMime = 'image/octet-stream'; // 强制下载

      let d = new Date();
      let filename = d.getFullYear() + "_" + (d.getMonth() + 1) + "_" + d.getDate() + " " + d.getHours() + "-" + d.getMinutes() + "-" + d.getSeconds();
      //保存
      canvas.toBlob(function(blob) {

        let save_link = document.createElement('a');
        save_link.href = URL.createObjectURL(blob);
        save_link.download = filename;
        let event = document.createEvent('MouseEvents');
        event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        save_link.dispatchEvent(event);
        URL.revokeObjectURL(save_link.href);
      }, 'image/' + type, 0.1);


    }



    // 棋盘保存PDF文件
    checkerBoard.prototype.saveAsPDF = function(fontName) {

      if (typeof(jsPDF) != "function") {
        msg("❌❌❌ 缺少 jsPDF 插件");
        return;
      }
      msg("创建PDF文档......", null, null, null, null, null, null, null, null, null, 0);
      let board = this;
      setTimeout(function() {

        //新建文档
        let doc = new jsPDF("p", "pt", "a4"); // 594.3pt*840.51pt
        msgTextarea.value = "添加中文字体......";

        setTimeout(function() {
          //doc.addFont("msyh-bold.ttf", "msyh", "normal");
          //doc.addFont("msyh-bold.ttf", "msyh", "bold");
          msgTextarea.value = "写入PDF数据......";

          setTimeout(function() {
            board.printPDF(doc, fontName); // 写入文档
            let d = new Date();
            let name = d.getFullYear() + "_" + (d.getMonth() + 1) + "_" + d.getDate() + " " + d.getHours() + "-" + d.getMinutes() + "-" + d.getSeconds();
            closeMsg();
            doc.save(name + '.pdf'); //保存文档
            delete doc;
          }, 50);
        }, 50);
      }, 50);

    }




    checkerBoard.prototype.saveAsSVG = function(type) {

      let save_link = document.createElement('a');
      let d = new Date();
      let name = d.getFullYear() + "_" + (d.getMonth() + 1) + "_" + d.getDate() + " " + d.getHours() + "-" + d.getMinutes() + "-" + d.getSeconds();
      let mimetype = type == "html" ? "text/html" : "image/svg+xml";
      let blob = new Blob([this.getSVG()], { type: mimetype });
      save_link.href = URL.createObjectURL(blob);
      save_link.download = name;
      let event = document.createEvent('MouseEvents');
      event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      save_link.dispatchEvent(event);
      URL.revokeObjectURL(save_link.href);

    }





    //涂鸦模式 手动调整选择棋盘边框
    checkerBoard.prototype.setCutDiv = function(x, y, passResetP) { //调整棋盘的边框范围，用 mdiv 实时显示效果
      let xL;
      let xM;
      let xR;
      let yT;
      let yM;
      let yB;
      let cutDiv = this.cutDiv;
      let s = cutDiv.style;
      let tempx;
      let tempy;

      x = parseInt(x);
      y = parseInt(y);

      // log("setCutDiv");
      xL = cutDiv.offsetLeft;
      xR = xL + parseInt(s.width);
      xM = xL + parseInt((xR - xL) / 2);
      yT = cutDiv.offsetTop;
      yB = yT + parseInt(s.height);
      yM = yT + parseInt((yB - yT) / 2);

      // log("x = " +x+ " y = " +y+ " xl = " +xL+ " xr = " +xR+ " yt = " +yT+ " yb = " +yB);
      let l;
      let t;
      let w;
      let h;

      if (x < xM)
      {
        if (y < yM)
        {
          l = x;
          t = y;
          w = xR - x;
          h = yB - y;
        }
        else
        {
          l = x;
          t = yT;
          w = xR - x;
          h = y - yT;
        }
      }
      else
      {

        if (y < yM)
        {
          l = xL;
          t = y;
          w = x - xL;
          h = yB - y;
        }
        else
        {
          l = xL;
          t = yT;
          w = x - xL;
          h = y - yT;
        }

      }

      // log ("l=" +l+ " t=" +t+ " w=" +w+ " h=" +h);
      let canvas = this.canvas;
      s.position = 'absolute';
      s.left = canvas.offsetLeft < l ? l : canvas.offsetLeft;
      s.top = canvas.offsetTop < t ? t : canvas.offsetTop;
      s.width = w > parseInt(canvas.style.width) - l ? parseInt(canvas.style.width) - l : w;
      s.height = h > parseInt(canvas.style.height) - t ? parseInt(canvas.style.height) - t : h;
      // log ("CutDiv w=" +s.width+ " h=" +s.height);
      this.XL = l;
      this.XR = this.XL + w;
      this.YT = t;
      this.YB = this.YT + h;

      if (passResetP) return;
      this.resetP(this.XL, this.XR, this.YT, this.YB);

    }


    // 设置最后一手是否高亮显示
    checkerBoard.prototype.setNotShowLastNum = function(idx) {

      if (this.MSindex >= 0 && this.MS[this.MSindex] == idx) {
        this.notShowLastNum = !this.notShowLastNum;
        return true;
      }
      else {
        return false;
      }

    }

    //设置棋谱
    checkerBoard.prototype.setMoves = function(codeStr) {

      // 对传入的棋谱代码排错;
      let m = codeStr.toUpperCase();
      codeStr = "";
      let d;
      let a;
      let n;
      while (m.length) {
        a = "";
        n = "";
        while (m.length) {

          a = m.substr(0, 1);
          m = m.substr(1);
          d = a.charCodeAt() - 'A'.charCodeAt();

          if (d >= 0 && d <= 14) break; // 找到英文字母为止;
        }
        if (d < 0 && d > 14) break; //没有找到英文字母，退出

        while (m.length) {

          n = m.substr(0, 1);
          m = m.substr(1);
          d = n.charCodeAt() - '0'.charCodeAt();
          if (d >= 0 && d <= 9) break; // 找到一个数字为止;

        }
        if (d < 0 && d > 9) break; //没有找到数字，退出


        //每个棋子落点横坐标用A-O表示，纵坐标用1-15来表
        //判断棋子纵坐标是否是2位，是则继续截取，补足3位。
        d = m.charCodeAt() - '0'.charCodeAt();
        if (d >= 0 && d <= 9) {
          n += m.substr(0, 1);
          m = m.substr(1);
        }
        // 排除不存在的坐标，同时去掉重复的坐标
        if (parseInt(n) <= 15 && parseInt(n) > 0) {

          let index = codeStr.indexOf(a + n);
          if (index < 0) {
            // 没有重复
            codeStr = codeStr + a + n;
          }
          else if (parseInt(n) <= 9) { // 如果Y坐标是一位数字，再确认是否重复
            let r = codeStr.substr(index + 2, 1).charCodeAt() - '0'.charCodeAt();
            // 没有重复
            if (r >= 0 && r <= 9) codeStr = codeStr + a + n;
          }
        }

      }
      if (codeStr != "") {
        this.Moves = codeStr;
        return codeStr;
      }
      else {
        return false;
      }

    }


    // 设置从第几手开始显示序号， 默认==0 时第一手开始显示，==1 时第二手显示❶
    checkerBoard.prototype.setResetNum = function(num) {

      this.resetNum = parseInt(num);
      this.showNum();
    }



    // 选取棋盘边框模式，设置一个移动的坐标点
    checkerBoard.prototype.setxy = function(p, speed) { //返回一个xy坐标，用来 调整棋盘边框位置，支持微调

      let s = this.cutDiv.style;
      let n = this.cutDiv;
      let xL = n.offsetLeft;
      let xR = xL + parseInt(s.width);
      let xM = xL + parseInt((xR - xL) / 2);
      let yT = n.offsetTop;
      let yB = yT + parseInt(s.height);
      let yM = yT + parseInt((yB - yT) / 2);
      let tempx;
      let tempy;
      let w = parseInt(s.width) < parseInt(s.height) ? parseInt(s.width) : parseInt(s.height);
      w /= (5 - 0.99);
      this.xyPageToObj(p, this.canvas);
      let x = parseInt(p.x);
      let y = parseInt(p.y);

      if (x < xM)
      {
        if (y < yM)
        {
          tempx = xL;
          tempy = yT;
        }
        else
        {
          tempx = xL;
          tempy = yB;
        }
      }
      else
      {

        if (y < yM)
        {
          tempx = xR;
          tempy = yT;
        }
        else
        {
          tempx = xR;
          tempy = yB;
        }

      }
      // 微调//////
      //alert("微调");
      if (speed != 1) {
        if (Math.abs(x - tempx) < w && Math.abs(y - tempy) < w)
        {
          var temps = Math.pow((x - tempx) / w, 2);
          x = parseInt((x - tempx) * speed * temps);
          x = x ? x : (x - tempx) < 0 ? -1 : 1;
          x += tempx;
          temps = Math.pow((y - tempy) / w, 2);
          y = parseInt((y - tempy) * speed * temps);
          y = y ? y : (y - tempy) < 0 ? -1 : 1;
          y += tempy;
          p.x = x;
          p.y = y;
          return;
        }
      }
      else {
        if (Math.abs(x - tempx) < parseInt(w / 3) && Math.abs(y - tempy) < parseInt(w / 3))
        {
          x = parseInt((x - tempx) / 10 * speed);
          x += tempx;
          y = parseInt((y - tempy) / 10 * speed);
          y += tempy;
          p.x = x;
          p.y = y;
          return;
        }

        if (Math.abs(x - tempx) < parseInt(w / 3 * 2) && Math.abs(y - tempy) < parseInt(w / 3 * 2))
        {
          x = parseInt((x - tempx) / 8 * speed);
          x += tempx;
          y = parseInt((y - tempy) / 8 * speed);
          y += tempy;
          p.x = x;
          p.y = y;
          return;
        }

        if (Math.abs(x - tempx) < w && Math.abs(y - tempy) < w)
        {
          x = parseInt((x - tempx) / 6 * speed);
          x += tempx;
          y = parseInt((y - tempy) / 6 * speed);
          y += tempy;
          p.x = x;
          p.y = y;
          return;
        }
      }

    }




    // 根据用户设置 决定是否高亮显示 最后一手棋
    checkerBoard.prototype.showLastNum = function(showNum) {

      let p = tempp;
      let idx;
      if (this.MSindex >= 0) { // 存在倒数第1手，特殊标记
        idx = this.MS[this.MSindex];
      }
      else { // 不存在倒数第1手，退出
        return;
      }
      // 取得棋子颜色
      let color = this.P[idx].color;
      let w = this.gW < this.gH ? this.gW / 2 * 0.85 : this.gH / 2 * 0.85;
      let ctx = this.canvas.getContext("2d");
      p.setxy(this.P[idx].x, this.P[idx].y);
      // 画棋子
      ctx.beginPath();
      ctx.lineWidth = "2px";
      ctx.fillStyle = "black";
      ctx.arc(p.x, p.y, w, 0, 2 * Math.PI);
      ctx.fillStyle = color
      ctx.fill();
      ctx.stroke();

      // 设置字体
      ctx.font = "bolder " + parseInt(w * 1.08) + "px  微软雅黑";
      // 由棋子颜色决定字体颜色
      ctx.fillStyle = this.notShowLastNum ? color == "white" ? "black" : "white" : "#ff6666";
      if (showNum) { // 显示数字
        // 判断最后一手是否高亮显示
        let txt = parseInt(this.P[idx].text) - this.resetNum;
        txt = parseInt(txt) < 1 ? "" : txt;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(txt, p.x, p.y);

      }
      else { // 隐藏数字
        // 判断最后一手是否高亮显示
        if (!this.notShowLastNum) {
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("◤", p.x - w * 0.15, p.y - w * 0.15);
        }
      }


      if (this.MSindex > 0) { // 存在倒数第二手，恢复正常标记
        idx = this.MS[this.MSindex - 1];
      }
      else { // 不存在倒数第二手，退出
        return;
      }
      //画倒数第二棋子
      color = this.P[idx].color;
      p.setxy(this.P[idx].x, this.P[idx].y);
      ctx.beginPath();
      ctx.lineWidth = "2px";
      ctx.fillStyle = "black";
      ctx.arc(p.x, p.y, w, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.stroke();

      txt = parseInt(this.P[idx].text) - this.resetNum;
      txt = parseInt(txt) < 1 ? "" : txt;
      if (showNum) {
        ctx.font = "bolder " + parseInt(w * 1.08) + "px  微软雅黑";
        ctx.fillStyle = color == "white" ? "black" : color == "black" ? "white" : color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(txt, p.x, p.y);
      }

      ctx = null;
      return true;

    }




    // 刷新棋盘上棋子显示手数
    checkerBoard.prototype.showNum = function() {

      let color;
      let txt;
      for (let i = 0; i <= this.MSindex; i++)
      {
        color = (i % 2) ? 'white' : 'black';
        //从设定的手数开始显示序号
        txt = parseInt(this.P[this.MS[i]].text) - this.resetNum;
        txt = parseInt(txt) < 1 ? "" : txt;
        this.printPoint(this.MS[i], txt, color, tNum, true);
      }

    }



    //跳到最后一手
    checkerBoard.prototype.toEnd = function(isShowNum) {

      while (this.MSindex < this.MS.length - 1) {
        this.toNext(isShowNum);
      }
    }


    // 跳到下一手
    checkerBoard.prototype.toNext = function(isShowNum) {

      if (this.MS.length - 1 > this.MSindex) {

        this.wNb(this.MS[this.MSindex + 1], "auto", isShowNum);
      }
    }


    // 返回上一手
    checkerBoard.prototype.toPrevious = function(isShowNum) {

      if (this.MSindex >= 0) {

        this.cleNb(this.MS[this.MSindex], isShowNum);
      }

    }



    // 跳到第 0 手。
    checkerBoard.prototype.toStart = function(isShowNum) {

      while (this.MSindex > 0) {
        this.toPrevious(isShowNum);
      }
    }



    //解析棋谱,摆棋盘
    checkerBoard.prototype.unpackMoves = function(showNum, color, moves) {

      color = color || "auto";
      if (color == "auto") {
        this.MS.length = 0; //清空数组
        this.MSindex = -1;
      }
      let m = moves || this.Moves;
      log("unpackMoves moves=" + m, "red");

      while (m.length) {
        log("m=" + m);
        let a = m.substr(0, 2); //取前两个字符
        m = m.substr(2); //去掉前两个字符
        //每个棋子落点横坐标用A-O表示，纵坐标用1-15来表
        //判断棋子纵坐标是否是2位，是则继续截取，补足3位。

        let d = m.charCodeAt() - '0'.charCodeAt();
        if (d >= 0 && d <= 9) {
          a += m.substr(0, 1);
          m = m.substr(1);
        }
        // 棋谱坐标转成 index 后添加棋子
        this.wNb(this.nameToIndex(a), color, showNum)
        log("name=" + a + "   to   index =" + this.MS[this.MS.length - 1]);
      }
    }


    // 解析二维数组后，摆棋
    checkerBoard.prototype.unpackArray = function(arrobj, isShowNum) {

      let bNarr = [];
      let wNarr = [];
      log("unpackArray  =" + arrobj)
      this.MS.length = 0; //清空数组
      this.MSindex = -1;
      this.resetNum = 0;
      for (let y = 0; y < this.SLTY; y++) {
        for (let x = 0; x < this.SLTX; x++) {
          let idx = x + this.SLTX * y;
          switch (String(arrobj[y][x])) {
            case "0":
              this.clePoint(idx);
              break;
            case "1":
              bNarr.push(idx);
              break;
            case "2":
              wNarr.push(idx);
              break;
          }
        }
      }
      if (bNarr.length - wNarr.length == 1 || bNarr.length - wNarr.length == 0) {
        for (let i = 0; i < wNarr.length; i++) {
          bNarr.splice((i + 1) * 2 - 1, 0, wNarr[i]);
        }
        this.resetNum = bNarr.length;
        for (let i = 0; i < bNarr.length; i++) {
          this.wNb(bNarr[i], "auto", isShowNum, tNum);
        }
      }
      else {
        for (let i = 0; i < bNarr.length; i++) {
          this.wNb(bNarr[i], "black", isShowNum, tBlack);
        }
        for (let i = 0; i < wNarr.length; i++) {
          this.wNb(wNarr[i], "white", isShowNum, tWhite);
        }
      }
    }




    //  在棋盘的一个点上面，打印一个标记
    checkerBoard.prototype.wLb = function(idx, text, color) {

      if (this.P[idx].type != tEmpty) this.clePoint(idx);
      this.P[idx].color = color;
      this.P[idx].type = tLb;
      this.P[idx].text = text;
      this.printPoint(idx, this.P[idx].text, this.P[idx].color);
    }



    // 在棋盘的一个点上面，摆一颗棋子
    checkerBoard.prototype.wNb = function(idx, color, showNum, type) {

      log("checkerBoard.wNb", "red");
      let i = this.MSindex + 1;

      if (color == "auto" || type == tNum) { // 顺序添加棋子

        this.MSindex++;
        // 如果当前添加的点和历史记录不一样，就把后面没用的记录删除
        if (this.MS.length >= i && this.MS[i] != idx) {
          this.MS.length = i;
        }

        this.MS[i] = idx; //顺序添加的棋子 记录下来

      }

      this.P[idx].color = color != "auto" ? color : (i % 2) ? 'white' : 'black';
      this.P[idx].type = type == null ? color == "auto" ? tNum : color == "white" ? tWhite : tBlack : type;
      this.P[idx].text = this.P[idx].type == tNum ? String(i + 1) : "";
      let txt = this.P[idx].text;
      if (this.P[idx].type == tNum) { //控制从第几手显示❶
        txt = parseInt(this.P[idx].text) - this.resetNum;
        txt = parseInt(txt) < 1 ? "" : txt;
        txt = showNum ? txt : "";
      }
      this.printPoint(idx, txt, this.P[idx].color, this.P[idx].type, showNum);
    }





    // 把 page 坐标 转成 canvas 坐标
    checkerBoard.prototype.xyPageToObj = function(p, canvas) {

      let l = canvas.offsetLeft;
      let t = canvas.offsetTop;
      let parentNode = canvas.parentNode;
      while (parentNode != document.body && parentNode != null) {

        l += parentNode.offsetLeft;
        t += parentNode.offsetTop;
        parentNode = parentNode.parentNode;
      }
      p.x = p.x - l;
      p.y = p.y - t;
    }

    // 把 canvas 坐标 转成 page 坐标
    checkerBoard.prototype.xyObjToPage = function(p, canvas) {

      let l = canvas.offsetLeft;
      let t = canvas.offsetTop;
      let parentNode = canvas.parentNode;
      while (parentNode != document.body && parentNode != null) {

        l += parentNode.offsetLeft;
        t += parentNode.offsetTop;
        parentNode = parentNode.parentNode;
      }
      p.x = p.x + l;
      p.y = p.y + t;
    }
  </script>
  <script language="javascript">
    "use strict";
    var timerSave = null; // 保存,定时器

    function renjuSave() {

      if (timerSave) { // 如果之前的保存计划还没开始 取消计划。
        clearTimeout(timerSave);
      }
      // 预定保存点击，
      timerSave = setTimeout(function() {

        let moves = cBoard.getMoves();
        let whiteMoves = cBoard.getMoves(tWhite);
        let blackMoves = cBoard.getMoves(tBlack);
        if (moves != "" || whiteMoves != "" || blackMoves != "") {
          localStorage.setItem("moves", moves);
          localStorage.setItem("whiteMoves", whiteMoves);
          localStorage.setItem("blackMoves", blackMoves);
          localStorage.setItem("resetNum", cBoard.resetNum);
          timerSave = null;
          //log("保存棋谱:" + moves);
        }

      }, 5000);
    }




    function renjuLoad() {

      setTimeout(function() {
        let resetNum = localStorage.getItem("resetNum");
        let moves = localStorage.getItem("moves");
        let whiteMoves = localStorage.getItem("whiteMoves");
        let blackMoves = localStorage.getItem("blackMoves");
        if (parseInt(resetNum) > 0) cBoard.resetNum = parseInt(resetNum);
        if (cBoard.setMoves(moves)) cBoard.unpackMoves(true);
        if (whiteMoves != "") cBoard.unpackMoves(true, "white", whiteMoves);
        if (blackMoves != "") cBoard.unpackMoves(true, "black", blackMoves);

      }, 300);
    }
  </script>
  <script language="javascript">
    "use strict";
    const Cmodel = new Array("x", "y", "d", "u"); // 米字线
    const Onlyfree = 1; // 只找活3，活4
    const Onlynfree = 2; // 只找眠3，眠4
    const OnlyVCF = 1; // 只找做VCF点
    const OnlySimpleWin = 2; // 只找43级别做杀点

    let generator;
    let vcfcount = 0;
    let vcfarr = []; // 保存棋盘初始状态
    let vcfBakArr = []; // vcfarr 备份
    let vcfnewarr = []; // 临时保存计算结果

    let vcfcolor = 0; // 自己棋子颜色
    let vcfnColor = 0; // 对手棋子颜色
    let vcffs = []; // 递归栈
    let vcfmoves = []; // 当前正在计算的分支
    let vcfFailMoves = []; // 保存失败节点,已经地毯的节点
    let vcfWinMoves = []; // 保存成立的VCF分支;
    let countFailMoves = 0;
    let vcfFinding = -1; // 计算状态
    let timerVCF = null; // 连续计算计时器
    let vcfFindDepth = 0; // 计算深度
    let vcfStartTimer = 0;
    let vcfnLevel = null;
    //let vcfFourLevelPoint = null;
    let stopFind = false;
    let vcfContinueStart; // 首次循环;
    let vcfMaxCount = 0; // 记录上次查找VCF设置的搜索最大个数
    let vcfMaxDepth = 0; // 记录上次VCF最大搜索深度

    let vcfWhiteWinMoves = [];
    let vcfBlackWinMoves = [];
    let vcfFinishEvent = function() {};


    //，保存周围点的坐标
    let aroundPoint = [];
    // 创建二维数组，保存 0-224 个点周围点的坐标信息。
    // 以H8 为例，H8周围的点坐标 保存在 aroundPoint[112]
    // aroundPoint[112].index  ，aroundPoint[112].point,保存坐标信息
    // aroundPoint[112].radius 搜索半径内 点 的个数。
    for (let i = 0; i < 225; i++) {
      aroundPoint[i] = { index: [], point: [], radius: [] };
      setAroundPoint(aroundPoint[i].index, aroundPoint[i].point, aroundPoint[i].radius, i);
    }




    // 设置idx为中心，保存周围点的坐标
    function setAroundPoint(index, point, radius, idx) {

      let r = 1;
      let x = idx % 15;
      let y = parseInt(idx / 15);
      let left;
      let top;
      let right;
      let under;
      index[0] = idx;
      point[0] = { "x": x, "y": y };
      radius[0] = 1;
      let count = 1;

      // 从里到外，绕圈搜索
      while (r <= 14) {
        // 搜索左右两边;
        left = x - r;
        right = x + r;
        top = (y - r) < 0 ? 0 : y - r;
        under = (y + r) > 14 ? 14 : y + r;

        if (left >= 0) {
          for (let i = top; i <= under; i++) {
            index[count] = i * 15 + left;
            point[count] = { x: left, y: i };
            count += 1;
          }
        }
        if (right < 15) {
          for (let i = top; i <= under; i++) {
            index[count] = i * 15 + right;
            point[count] = { x: right, y: i };
            count += 1;
          }
        }
        // 搜索上下两边;
        left = left < 0 ? 0 : left + 1;
        right = right > 14 ? 14 : right - 1;
        top = y - r;
        under = y + r;

        if (top >= 0) {
          for (let i = left; i <= right; i++) {
            index[count] = top * 15 + i;
            point[count] = { x: i, y: top };
            count += 1;
          }
        }
        if (under < 15) {
          for (let i = left; i <= right; i++) {
            index[count] = under * 15 + i;
            point[count] = { x: i, y: under };
            count += 1;
          }
        }

        radius[r] = count;
        r += 1;
      }

    }



    // 复制一个维数组
    function copyMoves(moves) {

      let m = [];
      let len = moves.length
      for (let i = 0; i < len; i++) {
        m[i] = moves[i];
      }
      return m;
    }



    // 复制一个arr数组
    function copyArr(arr, arr2) {

      getArr(arr);
      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          arr[y][x] = arr2[y][x];
        }
      }
      return arr;
    }





    // 连续查找,VCF
    //color 设置棋子颜色， timeout 设置超时毫秒单位， 
    // depth 计算深度， backStage 后台模式, count VCF个数上限
    function* continueFindVCF(color, timeOut, depth, count, backStage, arr) {

      try {
        if (timerVCF) return;
        vcfFinishEvent = function() {};
        timeOut = timeOut == null ? 1800000 : timeOut;
        depth = depth == null ? 225 : depth;
        count = count == null ? 225 : count * 1;
        backStage = backStage ? true : false;
        vcfcount = 0;
        vcfFinding = -1;
        vcfContinueStart = true;

        vcfarr = arr;
        copyArr(vcfBakArr, vcfarr);
        vcffs.length = 0;
        vcfmoves.length = 0;
        vcfcolor = color;
        vcfnColor = color == 1 ? 2 : 1;
        vcfFinding = 0;
        vcfFindDepth = 0;
        vcfFailMoves.length = 0;
        for (let i = 0; i < 225; i++) { vcfFailMoves[i] = []; }
        vcfWinMoves.length = 0;
        countFailMoves = 0;
        vcfnLevel = null;
        /*
        if (color==2) vcfWhiteWinMoves = [];
        if (color==1) vcfBlackWinMoves = [];
        */
        vcfMaxDepth = vcfMaxDepth < depth ? depth : vcfMaxDepth;

        getArr(vcfnewarr);

        // alert(vcfFinding)
        timerVCF = setInterval(function() {
          continueVCF(timeOut, depth, count, backStage);
        }, 0);
        vcfStartTimer = new Date().getTime();
        yield;
        return vcfWinMoves.length;
      }
      catch (err) {
        alert("continueFindVCF err=" + err.message);
      }
    }


    // 停止查找
    function cancelFind() {

      vcfFinding = -1;
      stopFind = true;
      setTimeout("stopFind = false;", 2500);
    }


    // 定时器调用，实现搜索VCF
    function continueVCF(timeOut, depth, count, backStage) {

      try { //

        let movess = [];
        let x;
        let y;
        let len;
        switch (vcfFinding) {
          case 0:
            vcfFinding = 100;
            vcfcount++;
            /*
            if (vcfContinueStart) {
                vcfContinueStart = false;
                let winMoves = vcfcolor==1 ?vcfBlackWinMoves : vcfWhiteWinMoves;
                let len = winMoves.length;
                    //alert("winMove.len="+winMoves.length + "color="+vcfcolor+"\n"+winMoves)
                for (let i=0; i<len; i++) {
                    if (isVCF(vcfcolor,vcfarr,winMoves[i])) {
                        
                        pushWinMoves(vcfWinMoves,winMoves[i]);
                        if (count==1) {  // 快速查找VCF,找到一个退出
                                //alert("kuai")
                            vcfFinding = -1;
                            return;
                        }
                        pushFailMoves(vcfFailMoves,winMoves[i].slice(0,winMoves[i].length-1));
                    }
                        // getLevelB 模式只验证前面几个
                    if (count==1 && i>3) {
                        break;
                    }
                }
        
            }
            */

            if (!backStage && vcfcount % 30 == 0) {
              log("失败结点数=" + countFailMoves);
              cBoard.printMoves(vcfmoves, vcfcolor);
            }
            vcfFinding = findVCF(timeOut, depth);
            break;
          case 1:
            // -1 分支地毯完， 0 继续地毯后面分支
            vcfMaxCount = vcfWinMoves.length;
            vcfFinding = vcffs.length ? (vcfWinMoves.length < count) ? 0 : -1 : -1;
            break;
          case -1:
            clearInterval(timerVCF);
            timerVCF = null;
            /*
            if (vcfWinMoves.length) {
                let VCF = vcfcolor==1 ? vcfBlackWinMoves : vcfWhiteWinMoves;
                let len=vcfWinMoves.length;
                for (let i=0; i<len; i++ ) {
                    pushVCF(VCF,vcfWinMoves[i]);
                }
            }
            */

            vcfFinishEvent();
            generator.next();
            if (backStage) {
              break;
            }
            //if (vcffs.length>0) vcfMaxCount = 1;
            cBoard.printMoves([]);
            break;
        }
        //log (vcfFinding)
      }
      catch (err) {
        alert("continueVCF err=" + err.message);
      }
    }



    // 给ps数组添加一个值，重复的会忽略
    function pushPoint(ps, point) {

      let len = ps.length;
      for (let i = 0; i < len; i++) {
        if (ps[i] == point) return;
      }
      ps[len] = point;
    }



    // 会改变moves
    // 添加失败分支
    function pushFailMoves(FailMoves, moves) {

      let mv = moves;
      let len = moves.length;
      let sum = 0; // 对单色棋子索引求和，保存到数组最后位置。
      for (let i = len - 1; i >= 0; i -= 2) {
        sum += mv[i];
      }
      mv.push(sum);
      // 四维数组保存失败分支;
      if (FailMoves[len][sum] == null) {
        FailMoves[len][sum] = [];
      }
      FailMoves[len][sum].push(mv); // 保存失败分支   
      countFailMoves += 1;
    }





    function pushVCF(VCF, moves) {

      let i;
      let j;
      let k;
      let l = moves.length;
      let len = VCF.length;
      // alert(moves+"  对比")
      // 确认是否重复
      if (l > 20) return;
      for (i = len - 1; i >= 0; i--) {
        if (l == VCF[i].length) {
          for (k = l - 1; k >= 0; k -= 2) {
            for (j = l - 1; j >= 0; j -= 2) {
              if (VCF[i][j] == moves[k] * 1) {
                break; //找到相同数据
              }
            }
            if (j < 0) break; // 没有找到相同数据;
          }
          if (k >= 0) continue; // 没有找到相同数据;

          // 判断另一个颜色
          for (k = l - 2; k >= 0; k -= 2) {
            for (j = l - 2; j >= 0; j -= 2) {
              if (VCF[i][j] == moves[k] * 1) {
                break; //找到相同数据
              }
            }
            if (j < 0) break; // 没有找到相同数据;
          }
          if (k < 0) {
            return;
          }

        }
      }

      for (i = 0; i < VCF.length; i++) {
        if (VCF[i].length >= l) break;
      }
      // alert("准备添加"+VCF)
      VCF.splice(i, 0, copyMoves(moves)); // 
      // alert("添加后"+VCF)
      return true;
    }





    // 添加一个成立的VCF分支
    function pushWinMoves(WinMoves, moves) {

      try {
        let i;
        let j;
        let k;
        let l = moves.length;
        let len = WinMoves.length;
        // alert(moves+"  对比")
        // 确认是否重复

        for (i = len - 1; i >= 0; i--) {
          if (l < WinMoves[i].length) {
            // 判断一个颜色,最后一手活四级忽略
            for (k = l < 3 ? l - 1 : l - 3; k >= 0; k -= 2) {
              for (j = WinMoves[i].length - 1; j >= 0; j -= 2) {
                if (WinMoves[i][j] == moves[k] * 1) {
                  break; //找到相同数据
                }
              }
              if (j < 0) break; // 没有找到相同数据;
            }
            if (k >= 0) continue; // 没有找到相同数据;
            /*
                 // 判断另一个颜色
            for ( k=l-2; k>=0; k-=2) {
                for (j=WinMoves[i].length-2; j>=0; j-=2) {
                    if(WinMoves[i][j]==moves[k]*1) {
                        break;  //找到相同数据
                    }
                }
                if (j<0) break; // 没有找到相同数据;
            }
            */
            if (k < 0) { // 把所有重复的替换掉
              //alert("准备替换"+WinMoves)
              WinMoves.splice(i, 1); // 找到后续相同数据,删除
              // alert("替换后"+WinMoves)
            }

          }
          else {

            // 判断一个颜色
            for (k = WinMoves[i].length < 3 ? WinMoves[i].length - 1 : WinMoves[i].length - 3; k >= 0; k -= 2) {
              for (j = l - 1; j >= 0; j -= 2) {
                if (WinMoves[i][k] == moves[j] * 1) {
                  break; //找到相同数据
                }
              }
              if (j < 0) break; // 没有找到相同数据;
            }
            //alert (moves +"move")
            //alert (WinMoves[i] + "winmov")
            if (k >= 0) continue; // 没有找到相同数据;
            /*
                 // 判断另一个颜色
            for ( k=WinMoves[i].length-2; k>=0; k-=2) {
                for (j=l-2; j>=0; j-=2) {
                    if(WinMoves[i][k]==moves[j]*1) {
                        break;  //找到相同数据
                    }
                }
                if (j<0) break; // 没有找到相同数据;
            }
            */
            if (k < 0) {
              return false;
            }
          }
        }

        for (i = 0; i < WinMoves.length; i++) {
          if (WinMoves[i].length >= l) break;
        }
        // alert("准备添加"+WinMoves)
        WinMoves.splice(i, 0, copyMoves(moves)); // 找到相同数据;
        // alert("添加后"+WinMoves)
        return true;
      }
      catch (err) {
        alert("pushWinMoves err=" + err.message);
      }
    }





    // 对比VCF手顺是否相等
    function findMoves(FailMoves, moves) {

      try {
        let i;
        let j;
        let k;
        let rt = 0;
        let l = moves.length;
        let sum = 0; // 对每一手棋索引求，保存到数组最后位置。
        for (let i = l - 1; i >= 0; i -= 2) {
          sum += moves[i];
        }
        if (FailMoves[l][sum] == null) return false;
        let len = FailMoves[l][sum].length;
        for (i = len - 1; i >= 0; i--) {
          /*
              // 连续冲4没有44点,对手防点不需要判断
              // 判断一个颜色
          for ( k=moves.length-1; k>=0; k-=2) {
              for (j=FailMoves[l][sum][i].length-2; j>=0; j-=2) {
                  if(FailMoves[l][sum][i][j]==moves[k]*1) {
                      break;  //找到相同数据
                  }
              }
              if (j<0) break; // 没有找到相同数据;
          }
          
          if (k >= 0) continue; // 没有找到相同数据;
          */
          // 判断另一个颜色
          for (k = moves.length - 2; k >= 0; k -= 2) {
            for (j = FailMoves[l][sum][i].length - 3; j >= 0; j -= 2) {
              if (FailMoves[l][sum][i][j] == moves[k] * 1) {
                break; //找到相同数据
              }
            }
            if (j < 0) break; // 没有找到相同数据;
          }

          if (k < 0) break; // 找到相同数据;
          //if (k < 0)  { rt = k<0 ? 1 :0.1; break; } // 找到相同数据;
        }
        /*
        if (i>=0 && moves.length>=4 && moves[0]==100 && moves[1]==102 && moves[2]==97 && moves[3]==98) {
            alert("重复\n"+moves + "\n" + FailMoves[l][i])
        }
        */
        return (i >= 0) ? true : false;
      }
      catch (err) {
        alert("findMoves err=" + err.message);
      }
    }





    // 判断是否，已经五连胜
    function isWin(color, arr) {

      try {

        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            for (let i = 0; i < 4; i++) {
              let pw = getPower(x, y, arr, Cmodel[i], color);
              if (pw == 5) {
                if (color == 2) {
                  return true;
                }
                else if (getArrValue(x, y, -1, Cmodel[i], arr) != color) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
      catch (err) {
        alert("isWin ERR=" + err.message);
      }
    }



    // 不判断对手是否五连
    // 判断是否活四级别胜
    function isFFWin(x, y, color, arr) {

      if (isFour(x, y, color, arr, true)) {
        return true;
      }
      if (color == 2) {
        if (isFF(x, y, 2, arr) || isCatchFoul(x, y, arr)) {
          return true;
        }
      }
      return false;
    }



    // 判断是否活三级别胜
    function* isTTWin(x, y, color, arr, timeout, depth, gDepth) {

      timeout = timeout || 30000;
      depth = depth || 1000;
      gDepth = gDepth || 2;
      // 判断对手进攻级别
      let nLevel = yield* getLevelB(arr, color == 1 ? 2 : 1, getArr([]), timeout, depth, true);
      let winLevel;
      //alert("对手进攻级别="+nLevel.level)
      if (nLevel.level == 5) { // 对手已胜
        return 2;
      }
      else if (nLevel.level >= 3) { // 对手有攻,没五连就败了
        winLevel = getLevel(arr, color);
        return winLevel.level == 5 ? 5 : 2;
      }
      else { // 对方没有V
        winLevel = getLevel(arr, color);
        if (winLevel.level >= 4.5) {
          return winLevel.level; //==5 or ==4.5
        }
        else if (winLevel.level == 4) {
          let y = winLevel.p.y;
          let x = winLevel.p.x;
          arr[y][x] = color == 1 ? 2 : 1;
          let num = yield* continueFindVCF(color, timeout, depth, 1, true, copyArr([], arr));
          arr[y][x] = 0;
          if (num) return 4.4;
        }

        //continueFindVCF(color,timeOut,depth,count,backStage,arr) 
        let fNum = yield* continueFindVCF(color, timeout, depth, 1, true, copyArr([], arr));
        if (fNum >= 1) { // 有(一套以上)两套V，判断双杀是否成立

          let notWin = false; //后续计算，如果双杀不成立==true
          let bPoint = getBlockVCF(vcfWinMoves, color, arr, true, true);
          if (bPoint) { //排除直接防
            if (!(yield* excludeBP(arr, color == 1 ? 2 : 1, bPoint, timeout, depth))) {
              //排除失败，双杀不成立
              notWin = true;
            }
          }

          if (!notWin && gDepth >= 2) { // 没有找到直接共防，继续寻找先手防
            //处理先手防
            let fMoves = []; //  保存先手连续冲四分支
            continueFour(arr, color == 1 ? 2 : 1, 6, fMoves, getArr([]));
            let j;

            for (j = fMoves.length - 1; j >= 0; j--) {
              //alert("gDepth="+gDepth+"\nj="+j);

              // 摆棋
              for (let k = fMoves[j].length - 1; k >= 0; k--) {
                let x = fMoves[j][k] % 15;
                let y = parseInt(fMoves[j][k] / 15);
                arr[y][x] = k % 2 ? color : color == 1 ? 2 : 1;
              }
              /*
               let str = "";
               for (let l=0;l<=j;l++)  {
                   str+="\n"+fMoves[l];
               }
               alert(j+"\n"+str)
              */
              winLevel = yield* getWinLevel(arr, color, timeout, depth, gDepth - 1);
              //alert("_____"+winLevel)
              if (winLevel < 3.5) notWin = true;

              // 复原棋子
              for (let k = fMoves[j].length - 1; k >= 0; k--) {
                let x = fMoves[j][k] % 15;
                let y = parseInt(fMoves[j][k] / 15);
                arr[y][x] = 0;
              }
              if (notWin) j = -1;
            }
          }

          return notWin ? 2 : 3.5;
        }
        return 2;
      }

    }






    // moves.length 为单数
    function isVCF(color, arr, moves) {

      let pnt = aroundPoint[112];
      let nColor = color == 1 ? 2 : 1;
      let OV = [];
      let newarr = [];
      let l = moves.length;
      let i;
      for (i = 0; i < l; i += 2) {
        getArr(newarr);
        let level = getLevel(arr, nColor);
        if (level.level < 4) { // 对方进攻级别小于冲4
          let x = moves[i] % 15;
          let y = parseInt(moves[i] / 15);
          // 先手会判断禁手
          if ((arr[y][x] == 0 && isFour(x, y, color, arr)) && (color == 2 || !isFoul(x, y, arr))) {
            OV.push({ "x": x, "y": y, "v": arr[y][x] * 1 });
            arr[y][x] = color;
            if (i + 1 >= l) break;
            //后手不判断禁手
            let idx = getBlockFour(x, y, arr);
            x = idx % 15;
            y = parseInt(idx / 15);
            if (idx == moves[i + 1] && arr[y][x] == 0) {
              OV.push({ "x": x, "y": y, "v": arr[y][x] * 1 });
              arr[y][x] = nColor;
            }
            else {
              break;
            }
          }
          else {
            break;
          }
        }
        else if (level.level == 4) { //对手进攻级别等于冲4

          let x = level.p.x;
          let y = level.p.y;
          // 先手会判断禁手
          if ((y * 15 + x) == moves[i] && isFour(x, y, color, arr) && (color == 2 || !isFoul(x, y, arr))) {
            OV.push({ "x": x, "y": y, "v": arr[y][x] * 1 });
            arr[y][x] = color;
            if (i + 1 >= l) break;
            //后手不判断禁手
            let idx = getBlockFour(x, y, arr);
            x = idx % 15;
            y = parseInt(idx / 15);
            if (idx == moves[i + 1] && arr[y][x] == 0) {
              OV.push({ "x": x, "y": y, "v": arr[y][x] * 1 });
              arr[y][x] = nColor;
            }
            else {
              break;
            }
          }
          else {
            break;
          }
        }
        else { //对手进攻级别大于冲4
          break;
        }
      }
      //所有手走完，判断是否出现胜形 (活4，44，冲4抓)
      //VCF的最后一手为44级别，如果是五连会出错
      let isV = false;
      getArr(newarr);
      let fP = findFivePoint(arr, color, newarr);
      if (fP) {
        if (fP.length >= 2) {
          isV = true;
        }
        else {
          let x = fP[0] % 15;
          let y = parseInt(fP[0] / 15);
          if (color == 2 && isFoul(x, y, arr)) isV = true;

        }
      }

      // 还原改动的棋子
      // moves.length 为单数i不会下标越界
      for (i = OV.length - 1; i >= 0; i--) {
        arr[OV[i].y][OV[i].x] = OV[i].v;
      }

      return isV;
    }



    //判断冲四点是否抓禁，不判断黑棋是否有五连点
    //x,y是白棋冲四点
    function isCatchFoul(x, y, arr) {

      if (arr[y][x] != 0) return false;
      arr[y][x] = 2;
      let ch = false;
      let idx = getBlockFour(x, y, arr);
      if (idx != -1) {
        let tx = idx % 15;
        let ty = parseInt(idx / 15);
        if (isFoul(tx, ty, arr)) ch = tx + ty * 15;
      }
      arr[y][x] = 0;
      return ch;

    }




    // 不会验证x,y是否有棋子
    //判断指定点，是否为禁点
    function isFoul(x, y, arr) {

      if (arr[y][x] != 0) return false;
      if (isSix(x, y, 1, arr)) return true;
      if (isFF(x, y, 1, arr)) return true;
      if (isTT(x, y, arr)) return true;
      return false;
    }



    // 不会验证x,y是否有棋子
    // 判断 x，y是否长连
    function isSix(x, y, color, arr) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let count = 0;

      for (let i = 0; i < 4; i++) { // 分别从4个方向判断
        if (count < 0 || (color == 2 && count > 0)) break;
        for (let j = 0; j > -5; j--) { // 分别判断这个点相关的5个 五
          let pw = getPower(x, y, arr, Cmodel[i], color, j);
          if (color == 2) { // 白棋判断
            if (pw > 5) {
              count = 1;
              break;
            }
            // 五连 否定长连
            if (pw == 5 && getArrValue(x, y, j - 1, Cmodel[i], arr) != color) {
              count = -1;
              break;
            }
          }
          else {
            if (pw > 5) {
              count = 1;
              continue;
            }
            if (pw == 5) {
              if (getArrValue(x, y, j - 1, Cmodel[i], arr) == color) {
                count = 1;
                continue;
              }
              else { // 五连 否定长连
                count = -1;
                break;
              }
            }
          }
        }
      }
      arr[y][x] = ov;
      return count > 0 ? true : false;
    }



    // 不会验证x,y是否有棋子
    function isLineSix(x, y, model, color, arr) {

      let ov = arr[y][x];
      arr[y][x] = color;

      for (let i = -5; i < 1; i++) {
        let pw = getPower(x, y, arr, model, color, i);
        if (pw == 6) { arr[y][x] = ov; return true; }
      }

      arr[y][x] = ov;
      return false;
    }




    // 不会验证x,y是否有棋子
    // 判断x,y,点是否五连
    function isFive(x, y, color, arr) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let count = 0;

      for (let i = 0; i < 4; i++) {
        if (count > 0) break;
        for (let j = 0; j > -5; j--) {
          let pw = getPower(x, y, arr, Cmodel[i], color, j);
          if (color == 2) { // 白棋
            if (pw >= 5) {
              count = 1;
              break;
            }
          }
          else { //黑棋
            if (pw == 5 && getArrValue(x, y, j - 1, Cmodel[i], arr) != color) {
              count = 1;
              break;
            }
          }
        }
      }
      arr[y][x] = ov;
      return count > 0 ? true : false;
    }




    // 不会验证x,y是否有棋子
    function isFour(x, y, color, arr, free) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let count = 0;
      let isfree = false;

      for (let i = 0; i < 4; i++) {
        if (count < 0) break;
        let isf = false;
        for (let j = 0; j > -5; j--) {
          let pw = getPower(x, y, arr, Cmodel[i], color, j);
          if (color == 2) { //白棋

            if (pw == 4) {
              if ((getArrValue(x, y, j, Cmodel[i], arr) == 0 && getArrValue(x, y, j + 5, Cmodel[i], arr) == 0) || (getArrValue(x, y, j + 4, Cmodel[i], arr) == 0 && getArrValue(x, y, j - 1, Cmodel[i], arr) == 0)) {
                isfree = true;
              }
              count = 1;
              continue;
            }
            if (pw >= 5) { // 五连排除4
              count = -1;
              break;
            }

          }
          else { //黑棋

            if (pw == 4 && getArrValue(x, y, j - 1, Cmodel[i], arr) != color && getArrValue(x, y, j + 5, Cmodel[i], arr) != color) {
              if (isLineFF(x, y, Cmodel[i], color, arr)) {
                count = -1;
                break;
              }
              else { // 确认是黑 ，4连点
                if ((getArrValue(x, y, j, Cmodel[i], arr) == 0 && getArrValue(x, y, j + 5, Cmodel[i], arr) == 0 && getArrValue(x, y, j + 6, Cmodel[i], arr) != color) || (getArrValue(x, y, j + 4, Cmodel[i], arr) == 0 && getArrValue(x, y, j - 1, Cmodel[i], arr) == 0 && getArrValue(x, y, j - 2, Cmodel[i], arr) != color)) {
                  isfree = true;
                }
                isf = true;
              }
            }
            if (pw >= 5) { // 五连，长连排除4
              count = -1;
              break;
            }
          }

        }
        count = isf ? count + 1 : count;

      }
      arr[y][x] = ov;

      if (count == 1 && color == 1) { //黑棋
        count = isFoul(x, y, arr) ? 0 : 1; // 禁手排除4
      }

      if (free == true) {
        return (count == 1 && isfree == true) ? true : false;
      }
      else if (free == false) {
        return (count == 1 && isfree == false) ? true : false;
      }
      else {
        return count == 1 ? true : false;
      }
    }


    // 不会验证x,y是否有棋子
    // 辅助判断33禁，x,y,点在 model指定这条线上是不是一个冲4点,活4
    function isLineFour(x, y, model, color, arr, free, pass) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let isf = 0;

      if (color == 2) { // 判断白棋
        for (let i = 0; i > -5; i--) {
          let pw = getPower(x, y, arr, model, color, i);
          if (pw == 4) {
            if ((getArrValue(x, y, i, model, arr) == 0 && getArrValue(x, y, i + 5, model, arr) == 0) || (getArrValue(x, y, i + 4, model, arr) == 0 && getArrValue(x, y, i - 1, model, arr) == 0)) {
              isf += free == false ? 0 : 1;
            }
            else {
              isf += free == true ? 0 : 1;
            }

          }
          if (pw > 4) { isf -= 99; break; }
        }
      }
      else { // 判断黑棋
        for (let i = 0; i > -5; i--) {
          let pw = getPower(x, y, arr, model, color, i);
          if (pw == 4 && getArrValue(x, y, i - 1, model, arr) != color && getArrValue(x, y, i + 5, model, arr) != color) {
            if ((getArrValue(x, y, i, model, arr) == 0 && getArrValue(x, y, i + 5, model, arr) == 0 && getArrValue(x, y, i + 6, model, arr) != color) || (getArrValue(x, y, i + 4, model, arr) == 0 && getArrValue(x, y, i - 1, model, arr) == 0 && getArrValue(x, y, i - 2, model, arr) != color)) {
              isf += free == false ? 0 : 1;
            }
            else {
              isf += free == true ? 0 : 1;
            }
          } // 五连以上否定冲4
          if (pw > 4) { isf -= 99; break; }
        }
      }
      arr[y][x] = ov;

      if (isf && !pass) { //五连，禁手排除4
        if (isFive(x, y, color, arr)) { isf -= 99; }
        if (color == 1) {
          if (isFoul(x, y, arr)) { isf -= 99; }
        }
      }
      return isf > 0;
    }



    // 不会验证x,y是否有棋子
    //判断 x,y 是否44
    function isFF(x, y, color, arr) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let count = 0;

      for (let j = 0; j < 4; j++) {

        if (count < 0) break; // 五连排除了44，退出
        let isf = false;
        if (color == 2) { // 判断白棋
          for (let i = 0; i > -5; i--) {
            let pw = getPower(x, y, arr, Cmodel[j], color, i);
            //if (Cmodel[j]=="u") alert (pw)
            if (pw == 4) {
              if (isLineFF(x, y, Cmodel[j], color, arr)) {
                count = 2;
              }
              else {
                isf = true;
              }
            } // 五连以上否定冲44
            if (pw > 4) { count = -2; break; }
          }
        }
        else { // 判断黑棋
          for (let i = 0; i > -5; i--) {
            let pw = getPower(x, y, arr, Cmodel[j], color, i);
            if (pw == 4 && getArrValue(x, y, i - 1, Cmodel[j], arr) != color && getArrValue(x, y, i + 5, Cmodel[j], arr) != color) {
              if (isLineFF(x, y, Cmodel[j], color, arr)) {
                count = 2;
              }
              else {
                isf = true;
              }
            } // 五连否定冲44
            if (pw == 5 && getArrValue(x, y, i - 1, Cmodel[j], arr) != color) {
              count = -2;
              break;
            }
          }
        }

        count += isf ? 1 : 0;
      }
      arr[y][x] = ov;
      return count > 1 ? true : false;
    }




    // 不会验证x,y是否有棋子
    function isThree(x, y, color, arr, free) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let count = 0; // 任意3计数
      let countf = 0; // 活3计数
      let isf = false;

      for (let i = 0; i < 4; i++) {
        if (count < 0) break;
        isf = false;
        for (let j = 0; j > -5; j--) {
          let pw = getPower(x, y, arr, Cmodel[i], color, j)
          if (color == 2) {
            if (pw == 3) {
              count++;
              if (getArrValue(x, y, j, Cmodel[i], arr) == 0) {
                if (getArrValue(x, y, j + 4, Cmodel[i], arr) == 0 && (getArrValue(x, y, j + 5, Cmodel[i], arr) == 0 || getArrValue(x, y, j - 1, Cmodel[i], arr) == 0)) {
                  isf = true;
                }
                else if (getArrValue(x, y, j + 5, Cmodel[i], arr) == 0) {
                  isf = true;
                }
              }
              else if (getArrValue(x, y, j + 4, Cmodel[i], arr) == 0 && getArrValue(x, y, j - 1, Cmodel[i], arr) == 0) {
                isf = true;
              }
              continue;
            } // 四连以上排除

            if (pw >= 4) {
              count = -1;
              break;
            }
          }
          else {
            if (pw == 3) {
              count++;
              if (getArrValue(x, y, j, Cmodel[i], arr) == 0) {
                if (getArrValue(x, y, j + 4, Cmodel[i], arr) == 0) {
                  let p = getNextEmpty(x, y, arr, Cmodel[i], 1, j);
                  if (isLineFour(p.x, p.y, Cmodel[i], color, arr, true)) {
                    isf = true;
                  }
                  p = getNextEmpty(x, y, arr, Cmodel[i], 1, j + 4);
                  if (isLineFour(p.x, p.y, Cmodel[i], color, arr, true)) {
                    isf = true;
                  }
                }
                else {
                  let p = getNextEmpty(x, y, arr, Cmodel[i], 1, j + 1);
                  if (isLineFour(p.x, p.y, Cmodel[i], color, arr, true)) {
                    isf = true;
                  }
                }
              }
              else if (getArrValue(x, y, j + 4, Cmodel[i], arr) == 0) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], j + 1);
                if (isLineFour(p.x, p.y, Cmodel[i], color, arr, true)) {
                  isf = true;
                }
              }
            } // 四连以上排除

            if ((pw >= 5) || (pw == 4 && getArrValue(x, y, j - 1, Cmodel[i], arr) != color && getArrValue(x, y, j + 5, Cmodel[i], arr) != color)) {
              count = -1;
              break;
            }
          }
        }
        countf += isf ? 1 : 0;
      }
      arr[y][x] = ov;
      if (color == 1) { // 黑棋33，否定3连
        count = countf > 1 ? -1 : count;
        //alert("countf=" + countf)
      }
      //alert("count=" +count + "   countf=" +countf)
      return free === true ? (count > 0 && countf > 0) : free === false ? (count > 0 && countf == 0) : count > 0;
    }



    // 不会验证x,y是否有棋子
    // x,y,点是否形成33
    function isTT(x, y, arr) {

      let color = 1;
      //五连否定33
      if (isFive(x, y, color, arr)) return false;

      let ov = arr[y][x];
      arr[y][x] = color;
      let count = 0;
      // 先搜索33形状
      for (let i = 0; i < 4; i++) {
        if (count < 0) break;
        for (let j = 0; j > -5; j--) {
          let pw = getPower(x, y, arr, Cmodel[i], color, j)

          if (pw == 3) {
            if (getArrValue(x, y, j, Cmodel[i], arr) == 0 || getArrValue(x, y, j, Cmodel[i], arr) == 0) {
              if (getArrValue(x, y, j - 1, Cmodel[i], arr) != color && getArrValue(x, y, j + 5, Cmodel[i], arr) != color) {
                count++;
                continue;
              }
            }
          } // 五连排除33
          if (pw == 5 && getArrValue(x, y, j - 1, Cmodel[i], arr) != color && getArrValue(x, y, j + 5, Cmodel[i], arr) != color) {
            count = -1;
            break;
          }
        }
      }

      if (count < 2) {
        arr[y][x] = ov;
        return false;
      }
      else {
        count = 0; // 确认有了33形状，进一步判断是否是活3，count累计活3个数
        for (let i = 0; i < 4; i++) {
          // 从4个方向判断是否活3，是就计数
          if (isLineThree(x, y, Cmodel[i], 1, arr, true)) {
            count++;
          }
          if (count > 1) break;
        }
        arr[y][x] = ov;
        // 累计够两个活3，确认是33
        return count > 1 ? true : false;
      }
    }


    // 不会验证x,y是否有棋子
    // x,y,点在model指定这条线上面是否为3
    function isLineThree(x, y, model, color, arr, free) {

      let ov = arr[y][x];
      arr[y][x] = color;
      let isf = false;
      let isfree = false;

      if (color == 2) { // 判断白棋
        for (let i = 0; i > -5; i--) {
          let pw = getPower(x, y, arr, model, color, i);
          if (pw == 3) {
            isf = true;
            if (getArrValue(x, y, i, model, arr) == 0) {
              if (getArrValue(x, y, i + 4, model, arr) == 0 && (getArrValue(x, y, i + 5, model, arr) == 0 || getArrValue(x, y, i - 1, model, arr) == 0)) {
                isfree = true;
              }
              else if (getArrValue(x, y, i + 5, model, arr) == 0) {
                isfree = true;
              }
            }
            else if (getArrValue(x, y, i + 4, model, arr) == 0 && getArrValue(x, y, i - 1, model, arr) == 0) {
              isfree = true;
            }

          }
          if (pw >= 4) { isf = false; break; }
        }
      }
      else { // 判断黑棋
        for (let i = 0; i > -5; i--) {
          let pw = getPower(x, y, arr, model, color, i);
          if (pw == 3 && getArrValue(x, y, i - 1, model, arr) != color && getArrValue(x, y, i + 5, model, arr) != color) {
            isf = true;
            if (getArrValue(x, y, i, model, arr) == 0) {
              if (getArrValue(x, y, i + 4, model, arr) == 0) {
                let p = getNextEmpty(x, y, arr, model, 1, i);
                if (isLineFour(p.x, p.y, model, color, arr, true)) {
                  isfree = true;
                  break;
                }
                p = getNextEmpty(x, y, arr, model, 1, i + 4);
                if (isLineFour(p.x, p.y, model, color, arr, true)) {
                  isfree = true;
                  break;
                }
              }
              else {
                let p = getNextEmpty(x, y, arr, model, 1, i + 1);
                if (isLineFour(p.x, p.y, model, color, arr, true)) {
                  isfree = true;
                  break;
                }
              }
            }
            else if (getArrValue(x, y, i + 4, model, arr) == 0) {
              let p = getNextEmpty(x, y, arr, model, 1, i + 1);
              if (isLineFour(p.x, p.y, model, color, arr, true)) {
                isfree = true;
                break;
              }
            }
          } // 4以上否定活3
          if (pw >= 4) { isf = false; break; }
        }
      }
      arr[y][x] = ov;

      return free === true ? (isfree && isf) : (!isfree && isf);

    }




    // 不会验证x,y是否有棋子
    // 判断是否是一条线上的44,不判断x，y是否五连
    function isLineFF(x, y, model, color, arr) {

      let st = 0;
      let ed = 0;
      var i;
      for (i = -1; i > -4; i--) {
        if (getArrValue(x, y, i, model, arr) != color) {
          break;
        }
      }
      st = i + 1;

      for (i = 1; i < 4 + st; i++) {
        if (getArrValue(x, y, i, model, arr) != color) {
          break;
        }
      }
      ed = i - 1;
      //alert("st="+ st + "   ed=" + ed)
      switch (ed - st) {
        case 0:
          if (getArrValue(x, y, -4, model, arr) == color && getArrValue(x, y, 4, model, arr) == color && getArrValue(x, y, -3, model, arr) == color && getArrValue(x, y, 3, model, arr) == color && getArrValue(x, y, -2, model, arr) == color && getArrValue(x, y, 2, model, arr) == color && getArrValue(x, y, -1, model, arr) == 0 && getArrValue(x, y, 1, model, arr) == 0) {
            if (color == 2) return true;
            if (getArrValue(x, y, -5, model, arr) != color && getArrValue(x, y, 5, model, arr) != color) {
              return true;
            }
          }
          break;
        case 1:
          if (getArrValue(x, y, -3 + st, model, arr) == color && getArrValue(x, y, 3 + ed, model, arr) == color && getArrValue(x, y, -2 + st, model, arr) == color && getArrValue(x, y, 2 + ed, model, arr) == color && getArrValue(x, y, -1 + st, model, arr) == 0 && getArrValue(x, y, 1 + ed, model, arr) == 0) {
            if (color == 2) return true;
            if (getArrValue(x, y, -4 + st, model, arr) != color && getArrValue(x, y, 4 + ed, model, arr) != color) {
              return true;
            }
          }
          break;
        case 2:
          if (getArrValue(x, y, -2 + st, model, arr) == color && getArrValue(x, y, 2 + ed, model, arr) == color && getArrValue(x, y, -1 + st, model, arr) == 0 && getArrValue(x, y, 1 + ed, model, arr) == 0) {
            if (color == 2) return true;
            if (getArrValue(x, y, -3 + st, model, arr) != color && getArrValue(x, y, 3 + ed, model, arr) != color) {
              return true;
            }
          }
          break;
        case 3:
          /*
              if (color==2) {
                  for ( i=0;i>st;i--)  {
                     if(getPower(x,y,arr,model,color,i)==4) return true;
                  }
                  for ( i=0;i<ed;i++)  {
                     if(getPower(x,y,arr,model,color,i-4)==4) return true;
                  }
              }
              break;
          */
      }

      return false;
    }



    // 找出能让x，y 成长连的点
    function createSixPoint(x, y, arr, newarr) {

      if (isFive(x, y, 1, arr)) return; // 五连排除禁手
      let ov = arr[y][x];
      arr[y][x] = 1;
      for (let i = 0; i < 4; i++) {
        if (isLineSix(x, y, Cmodel[i], 1, arr)) continue; // x,y在这条线已经长连，跳到下一条线
        for (let j = -5; j < 1; j++) {
          let pw = getPower(x, y, arr, Cmodel[i], 1, j, 6);
          if (pw == 5) {
            let p = getNextEmpty(x, y, arr, Cmodel[i], 1, j, 6);
            arr[y][x] = ov;
            if (!isFive(p.x, p.y, 1, arr) && !isFoul(p.x, p.y, arr)) {
              newarr[p.y][p.x] += 1;
            }
            arr[y][x] = 1;
          }
        }
      }
      arr[y][x] = ov;
    }





    function undoSixPoint(x, y, arr, newarr) {

      if (!isSix(x, y, 1, arr)) return;

      for (let i = 0; i < 4; i++) {
        let j;
        for (j = 0; j < 5; j++) {
          if (getPower(x, y, arr, Cmodel[i], 1, -j) == 3) break;
        }
        if (j == 5) continue;

        for (j = 1; j < 5; j++) {
          let p;
          if (getArrValue(x, y, -j, Cmodel[i], arr) == 0) {
            p = getNextEmpty(x, y, arr, Cmodel[i], 1, -j);
            arr[p.y][p.x] = 1;
            if (isFive(x, y, 1, arr) && !isFoul(p.x, p.y, arr) && !isFive(p.x, p.y, 1, arr)) {
              newarr[p.y][p.x] += 1;
            }
            arr[p.y][p.x] = 0;
          }
          if (getArrValue(x, y, j, Cmodel[i], arr) == 0) {
            p = getNextEmpty(x, y, arr, Cmodel[i], 1, j);
            arr[p.y][p.x] = 1;
            if (isFive(x, y, 1, arr) && !isFoul(p.x, p.y, arr) && !isFive(p.x, p.y, 1, arr)) {
              newarr[p.y][p.x] += 1;
            }
            arr[p.y][p.x] = 0;
          }
        }
      }
    }



    //  找出，x，y，的反防解禁点,返回的点可能包含禁点
    function getThreeUndoFail(x, y, arr) {

      let ps = [];
      for (let i = 0; i < 4; i++) {
        for (let j = 1; j < 5; j++) {
          let p = getArrPoint(x, y, j, Cmodel[i], arr);
          let ov;
          if (p.x != -1 && arr[p.y][p.x] == 0) {
            ov = arr[p.y][p.x];
            arr[p.y][p.x] = 1;
            if (isLineFour(x, y, Cmodel[i], 1, arr, null, true)) {
              ps.push(getArrIndex(x, y, j, Cmodel[i], arr) * 1);
              //cBoard.wLb(ps[ps.length-1],"6","red");
            }
            arr[p.y][p.x] = ov;
          }
          p = getArrPoint(x, y, -j, Cmodel[i], arr);
          if (p.x != -1 && arr[p.y][p.x] == 0) {
            ov = arr[p.y][p.x];
            arr[p.y][p.x] = 1;
            if (isLineFour(x, y, Cmodel[i], 1, arr, null, true)) {
              ps.push(getArrIndex(x, y, -j, Cmodel[i], arr) * 1);
              //cBoard.wLb(ps[ps.length-1],"6","red");
            }
            arr[p.y][p.x] = ov;
          }
        }
      }
      return ps;
    }





    // 找出x，y，活三的六腐 防点,返回的点可能包含禁点
    function getSixFramePoint(x, y, arr) {

      let ps = [];
      let ov = arr[y][x];
      arr[y][x] = 1
      for (let i = 0; i < 4; i++) {
        if (isLineThree(x, y, Cmodel[i], 1, arr, true)) {
          let count = 0;
          let p;
          let fp;
          for (let j = 1; j < 4; j++) { // 找活四点计数
            if (getArrValue(x, y, j, Cmodel[i], arr) == 0) {
              p = getArrPoint(x, y, j, Cmodel[i], arr);
              if (isFour(p.x, p.y, 1, arr, true)) {
                count += 1;
                fp = p;
              }
            }
            if (getArrValue(x, y, -j, Cmodel[i], arr) == 0) {
              p = getArrPoint(x, y, -j, Cmodel[i], arr);
              if (isFour(p.x, p.y, 1, arr, true)) {
                count += 2;
                fp = p;
              }
            }
          }
          // alert("count="+count)
          let tx;
          let ty;
          let idx;
          if (count == 1 || count == 2) { // 存在唯一活四点
            for (let j = 1; j < 5; j++) { // 找六腐防点
              if (getArrValue(fp.x, fp.y, j, Cmodel[i], arr) == 0) {
                if (getArrValue(fp.x, fp.y, j + 1, Cmodel[i], arr) == 0) {
                  idx = getArrIndex(fp.x, fp.y, j + 1, Cmodel[i], arr);
                  tx = idx % 15;
                  ty = parseInt(idx / 15);
                  if (!isLineFour(tx, ty, Cmodel[i], 1, arr)) ps.push(idx);
                }
                break;
              }
            }
            for (let j = 1; j < 5; j++) { //找六腐防点
              if (getArrValue(fp.x, fp.y, -j, Cmodel[i], arr) == 0) {
                if (getArrValue(fp.x, fp.y, -j - 1, Cmodel[i], arr) == 0) {
                  idx = getArrIndex(fp.x, fp.y, -j - 1, Cmodel[i], arr);
                  tx = idx % 15;
                  ty = parseInt(idx / 15);
                  if (!isLineFour(tx, ty, Cmodel[i], 1, arr)) ps.push(idx);
                }
                break;
              }
            }
          }
        }
      }
      arr[y][x] = ov;

      //alert("ps="+ps)
      return ps;
    }




    // 找防冲4抓禁，防点
    function* blockCatchFoul(arr) {

      let fp = [];
      let fPoint = []; //二维数组，抓禁冲四点
      let FOULP = [];
      let notBlock = true; // 假设没有防点
      for (let y = 0; y < 15; y++) { // 找出所有冲四抓
        for (let x = 0; x < 15; x++) {
          let p = isCatchFoul(x, y, arr);
          if (p) {
            fPoint.push([y * 15 + x]);
            FOULP.push(p); // 保存禁点
          }
          else if (arr[y][x] == 0 && isFour(x, y, 2, arr)) {
            fp.push([y * 15 + x]); // 保存白棋其它冲四点，避免黑解禁同时造抓禁。
          }
        }
      }
      if (!fPoint.length) {
        return -1;
      }
      // 合并数组
      for (let i = fp.length - 1; i >= 0; i--) {
        fPoint.push(fp[i]);
      }
      //alert(fPoint)

      // 找出这些抓的防点，排除先手防
      let bPoint = getBlockVCF(fPoint, 2, arr, true, true);
      //alert("bPoint"+bPoint)
      if (bPoint) {
        cBoard.cleLb("all");
        let fourP = fPoint[0]; // 冲四点
        let x = fourP % 15;
        let y = parseInt(fourP / 15);
        arr[y][x] = 2;
        let foulP = getBlockFour(x, y, arr); //禁点
        arr[y][x] = 0;
        x = foulP % 15;
        y = parseInt(foulP / 15);
        let threeP = getThreeUndoFail(x, y, arr); // 三三 潜在反防点
        let tx = fPoint[0][0] % 15;
        let ty = parseInt(fPoint[0][0] / 15);
        arr[ty][tx] = 2; // 先填白棋冲4点，再找六腐框架，避免多层禁手漏算
        let sixFrameP = getSixFramePoint(x, y, arr); // 六腐解禁点
        arr[ty][tx] = 0;
        for (let i = bPoint.length - 1; i >= 0; i--) {
          let s;
          let color;
          if (fPoint.length - fp.length == 1) { // 单抓防点
            if (bPoint[i] == fourP || bPoint[i] == foulP) {
              s = "A";
            }
            else if (sixFrameP.indexOf(bPoint[i]) > -1) {
              s = "×";
            }
            else {
              x = bPoint[i] % 15;
              y = parseInt(bPoint[i] / 15);
              arr[y][x] = 1; // 反防 : 禁解禁;
              s = isFour(getX(foulP), getY(foulP), 1, arr) && (threeP.indexOf(bPoint[i]) > -1) ? "■" : "◎";
              arr[y][x] = 0;
            }
            color = "black";
          }
          else { // 双防点
            s = "●";
            color = "#3333ff";
          }
          notBlock = false;
          cBoard.wLb(bPoint[i], s, color);
        }
      }
      else {
        bPoint = []; // 没有防点，bPoint 从false改为空数组
      }


      let fMoves = []; //  保存先手连续冲四分支
      continueFour(arr, 1, 4, fMoves, getArr([]));
      if (fMoves.length) {
        // fMoves 排序
        let len = fMoves.length;
        for (let i = len - 2; i >= 0; i--) {
          for (let j = len - 1; j > i; j--) {
            if (fMoves[i].length <= fMoves[j].length) {
              let m = fMoves[i]; // 不能用 splice 返回的指针赋值给m，会变三维数组
              fMoves.splice(i, 1);
              fMoves.splice(j, 0, m);
            }
          }
        }
      }


      // 分析先手增加防点，(先手直接解禁&先手用白子解禁,必增加防点)
      let len = fMoves.length;
      let x;
      let y;
      let idx; // 保存先手防第一手的idx

      for (let k = len - 1; k >= 0; k--) {
        idx = -1;
        // 摆棋
        for (let i = fMoves[k].length - 1; i >= 0; i--) {
          x = fMoves[k][i] % 15;
          y = parseInt(fMoves[k][i] / 15);
          arr[y][x] = i % 2 ? 2 : 1;
        }

        // 打印正在计算的点
        cBoard.printSearchPoint(fMoves[k][0], "⊙", "green");
        // 扫描防点
        let lvl = getLevel(arr, 2)
        let blk = [];
        if (lvl.level == 4) {
          if (!isFoul(lvl.p.x, lvl.p.y, arr)) {
            blk.push(lvl.p.y * 15 + lvl.p.x);
          }
        }
        else if (lvl.level < 4) {
          blk = getBlockVCF(fPoint, 2, arr, true, true);
        }
        //bPoint = bPoint==false ? [] : bPoint;
        for (let i = blk.length - 1; i >= 0; i--) {
          let j;
          for (j = bPoint.length - 1; j >= 0; j--) {
            if (bPoint[j] == blk[i]) break; // 没有先手增加的防点
          }
          // 白棋占禁点
          for (let n = FOULP.length - 1; n >= 0; n--) {
            if (fMoves[k][fMoves[k].length - 1] == FOULP[n]) {
              j = -1;
              n = -1;
            }
          }
          if (j < 0) { // 找到新防点,或者白占禁点
            x = blk[i] % 15;
            y = parseInt(blk[i] / 15);
            let narr = copyArr([], arr);
            narr[y][x] = 1;
            // 需要判断对手是否有攻，搜索VCF不严谨
            lvl = yield* continueFindVCF(2, 10000, 10, 1, true, narr);
            if (lvl == 0) { // 白棋没有新的VCF,新防点成立
              idx = fMoves[k][0];
              cBoard.printSearchPoint(); // 清空刚才计算的点
              cBoard.wLb(idx, "◎", "red");
              i = -1;
            }
            notBlock = false;
          }

        }

        // 复原棋子
        for (let i = fMoves[k].length - 1; i >= 0; i--) {
          x = fMoves[k][i] % 15;
          y = parseInt(fMoves[k][i] / 15);
          arr[y][x] = 0;
        }

        if (idx > -1) { // 有新增加的防点
          for (let i = k - 1; i >= 0; i--) { // 排除 idx 冲四的分支
            for (let j = fMoves[i].length - 2; j >= 0; j -= 2) {
              if (fMoves[i][j] == idx) {
                fMoves.splice(i, 1);
                k--;
                break;
              }
            }
          }
        }

        fMoves.length--;


      }
      cBoard.printSearchPoint(); // 清空刚才计算的点
      if (notBlock) {
        return 0;
      }
      else {
        return 1;
      }

    }




    function findFoulPoint(arr, newarr, setnum) {

      findSixPoint(arr, 1, newarr, setnum);
      findFFPoint(arr, 1, newarr, setnum);
      findTTPoint(arr, 1, newarr, setnum);

    }




    function findSixPoint(arr, color, newarr, setnum) {

      let count = 0;
      let nx;
      let ny;
      // 五连否定六连
      findFivePoint(arr, color, newarr, -10000);

      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          for (let i = 0; i < 4; i++) {
            let pw = getPower(x, y, arr, Cmodel[i], color)

            if (pw == 4) {

              let p = getNextEmpty(x, y, arr, Cmodel[i], color);
              if (getArrValue(x, y, -1, Cmodel[i], arr) == color || getArrValue(x, y, 5, Cmodel[i], arr) == color) {
                newarr[p.y][p.x] += Math.pow(10, i);
                count++;
              }

            }
          }
        }
      }

      if (setnum != null) {
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] != 0) {
              newarr[y][x] = setnum;
            }
          }
        }
      }

      return count;
    }






    function findFivePoint(arr, color, newarr, setnum) {

      let count = 0;
      let fP = [];
      let nx;
      let ny;

      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          for (let i = 0; i < 4; i++) {
            let pw = getPower(x, y, arr, Cmodel[i], color);
            if (color == 2) {
              if (pw == 4) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                newarr[p.y][p.x] += Math.pow(10, i);
                if (fP.indexOf(p.y * 15 + p.x) == -1) fP.push(p.y * 15 + p.x);
                count++;
              }

            }
            else {

              if (pw == 4) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                newarr[p.y][p.x] += Math.pow(10, i);
                count++;

                if (getArrValue(x, y, -1, Cmodel[i], arr) == color || getArrValue(x, y, 5, Cmodel[i], arr) == color) {
                  newarr[p.y][p.x] -= Math.pow(10, i);
                  count--;
                }
                else {
                  if (fP.indexOf(p.y * 15 + p.x) == -1) fP.push(p.y * 15 + p.x);
                }
              }
            }
          }
        }
      }

      if (setnum != null) {
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] != 0) {
              newarr[y][x] = setnum;
            }
          }
        }
      }

      return count ? fP : false;
    }



    // 以 idx 为中心查找 周围的五连,判断棋盘是否有 maxCount 个五连点。
    function findFivePointB(idx, arr, color, maxCount) {

      let count = 0;
      let x;
      let y;
      maxCount = maxCount || 1;
      // idx为中心搜索
      for (let i = 0; i < 225; i++) {
        x = aroundPoint[idx].point[i].x;
        y = aroundPoint[idx].point[i].y;
        if (arr[y][x] == 0 && isFive(x, y, color, arr)) {
          count += 1;
          if (count == maxCount) {
            return true;
          }
        }
      }

      return false;
    }




    // 找出可能的4连点
    function findFour(arr, color, newarr) {
      try {

        let count = 0;
        let nx;
        let ny;

        for (let y = 0; y < 15; y++) {

          for (let x = 0; x < 15; x++) {
            for (let i = 0; i < 4; i++) {

              let pw = getPower(x, y, arr, Cmodel[i], color);

              if (color == 2) {
                if (pw == 3) {
                  let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                  newarr[p.y][p.x] += Math.pow(10, i);
                  p = getNextEmpty(p.x, p.y, arr, Cmodel[i], color, 1);
                  newarr[p.y][p.x] += Math.pow(10, i);
                }

                if (pw == 4) {
                  let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                  newarr[p.y][p.x] = -9999;
                }

              }
              else {

                if (pw == 3 && getArrValue(x, y, -1, Cmodel[i], arr) != color && getArrValue(x, y, 5, Cmodel[i], arr) != color) {
                  let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                  newarr[p.y][p.x] += Math.pow(10, i);
                  p = getNextEmpty(p.x, p.y, arr, Cmodel[i], color, 1);
                  newarr[p.y][p.x] += Math.pow(10, i);

                }
                if (pw == 4 && getArrValue(x, y, -1, Cmodel[i], arr) != color && getArrValue(x, y, 5, Cmodel[i], arr) != color) {
                  let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                  newarr[p.y][p.x] = -9999;

                }
              }
            }
          }
        }

      }
      catch (err)
      {
        alert(err.message);
      }

    }



    // 找四连点
    function findFourPoint(arr, color, newarr, ftype, setnum) {

      let count = 0;
      let fP = [];
      let free = ftype == Onlyfree ? true : ftype == Onlynfree ? false : null;
      findFour(arr, color, newarr);
      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          if (newarr[y][x] > 0) {
            if (isFour(x, y, color, arr, free)) {
              newarr[y][x] = 1;
              fP.push(y * 15 + x);
              count++;
            }
            else {
              newarr[y][x] = 0;
            }
          }
        }
      }

      if (setnum != null) {
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] != 0) {
              newarr[y][x] = setnum;
            }
          }
        }
      }

      return count ? fP : false;
    }





    function findFFPoint(arr, color, newarr, setnum) {

      let count = 0;

      findFour(arr, color, newarr);
      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          if (newarr[y][x] > 0) {
            if (isFF(x, y, color, arr)) {
              newarr[y][x] = 1;
              count++;
            }
            else {
              newarr[y][x] = 0;
            }
          }
        }
      }

      if (setnum != null) {
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] != 0) {
              newarr[y][x] = setnum;
            }
          }
        }
      }

      return count;

    }






    // 找出可能的3连点
    function findThree(arr, color, newarr) {

      let count = 0;
      let nx;
      let ny;

      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          for (let i = 0; i < 4; i++) {

            let pw = getPower(x, y, arr, Cmodel[i], color);

            if (color == 2) {
              if (pw == 2) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                newarr[p.y][p.x] += Math.pow(10, i);
                p = getNextEmpty(p.x, p.y, arr, Cmodel[i], color, 1);
                newarr[p.y][p.x] += Math.pow(10, i);
                p = getNextEmpty(p.x, p.y, arr, Cmodel[i], color, 1);
                newarr[p.y][p.x] += Math.pow(10, i);
              }
              if (pw == 4) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                newarr[p.y][p.x] = -9999;
              }

            }
            else {

              if (pw == 2 && getArrValue(x, y, -1, Cmodel[i], arr) != color && getArrValue(x, y, 5, Cmodel[i], arr) != color) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                newarr[p.y][p.x] += Math.pow(10, i);
                p = getNextEmpty(p.x, p.y, arr, Cmodel[i], color, 1);
                newarr[p.y][p.x] += Math.pow(10, i);
                p = getNextEmpty(p.x, p.y, arr, Cmodel[i], color, 1);
                newarr[p.y][p.x] += Math.pow(10, i);

              }
              if (pw == 4 && getArrValue(x, y, -1, Cmodel[i], arr) != color && getArrValue(x, y, 5, Cmodel[i], arr) != color) {
                let p = getNextEmpty(x, y, arr, Cmodel[i], color);
                newarr[p.y][p.x] = -9999;

              }
            }
          }
        }
      }

    }



    // 找出正确的3连点
    function findThreePoint(arr, color, newarr, ftype, setnum) {

      let count = 0;
      let P = [];
      findThree(arr, color, newarr);
      //alert(newarr)
      let free = ftype == Onlyfree ? true : ftype == Onlynfree ? false : null;
      for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
          if (newarr[y][x] > 0) {
            if (isThree(x, y, color, arr, free)) {
              newarr[y][x] = 1;
              P.push(y * 15 + x);
              count++;
            }
            else {
              newarr[y][x] = 0;
            }
          }
        }
      }

      if (setnum != null) {
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] != 0) {
              newarr[y][x] = setnum;
            }
          }
        }
      }
      // alert(newarr)
      return count ? P : false;
    }



    //let testarr = false;
    // 找活3级别攻击点
    function* findLevelThreePoint(arr, color, newarr, fType, idx, backstage) {

      backstage = backstage == null ? true : backstage;
      let threeP = []; // 保存活3点，包括复活3
      let simpleP = []; // 保存坐杀点
      let vcfP = []; // 保存做V点
      let pnt = aroundPoint[idx || 112];
      // 先判断对手进攻级别,快速选点     
      yield* selectPoint(arr, color, newarr, null, null, backstage, { level: 2 });

      for (let i = 0; i < 225; i++) {

        let x = pnt.point[i].x;
        let y = pnt.point[i].y;

        if (!stopFind && newarr[y][x] == 0) {
          arr[y][x] = color;
          if (!backstage) cBoard.printSearchPoint(pnt.index[i], "⊙", "green");
          let level = yield* getLevelB(arr, color, newarr, null, fType == OnlySimpleWin ? 1 : null);
          let nColor = color == 1 ? 2 : 1;
          if (level.level < 4 && level.level >= 3) {
            let l = level.moves.length; // 保存手数，待后面判断43杀
            // 已经确认对手低于活三级别
            if (!backstage) cBoard.clePoint(pnt.index[i]);
            if ((color == 1 && l == 1) || isThree(x, y, color, arr, true)) {
              if (fType == null) {
                if (!backstage) {
                  cBoard.printSearchPoint();
                  cBoard.wLb(pnt.index[i], "③", color == 1 && !isThree(x, y, color, arr, true) ? "black" : "red");
                }
                threeP.splice(0, 0, pnt.index[i]);
              }

            }
            else {

              if (fType == null) {
                if (!backstage) {
                  cBoard.printSearchPoint();
                  cBoard.wLb(pnt.index[i], "V", l > 3 ? "black" : "red");
                }
                if (l > 3) {
                  vcfP.splice(0, 0, pnt.index[i]);
                }
                else {
                  simpleP.splice(0, 0, pnt.index[i]);
                }
              }
              else { // 进一步判断是否做V
                if ((fType == OnlyVCF && l > 3) || (fType == OnlySimpleWin && l == 3)) {
                  if (!backstage) {
                    cBoard.printSearchPoint();
                    cBoard.wLb(pnt.index[i], "V", l > 3 ? "black" : "red");
                  }
                  if (l > 3) {
                    vcfP.splice(0, 0, pnt.index[i]);
                  }
                  else {
                    simpleP.splice(0, 0, pnt.index[i]);
                  }
                }
              }
            }
          }
          arr[y][x] = 0;
        }
        else {
          if (!backstage) cBoard.cleLb(pnt.index[i]);
        }
      }
      if (!backstage) cBoard.printSearchPoint();
      return vcfP.concat(simpleP, threeP);


    }



    // 计算先手防 查找连续冲四，经过的点存入newarr,所有冲四分支存入fMoves。
    // 连续冲四方，必须没有VCF，如果有VCF可能影响计算结果
    function continueFour(arr, color, depth, fMoves, newarr, FailMoves, moves) {

      if (stopFind) return;
      if (depth < 0) return;
      if (FailMoves == null) {
        FailMoves = [];
        for (let i = 0; i < 225; i++) { FailMoves[i] = []; }
        moves = [];
      }
      //冲四方不存在VCF,不验证五连
      let level = getLevel(arr, color == 1 ? 2 : 1);
      if (level.level < 4) {
        let narr = getArr([]);
        if (findFourPoint(arr, color, narr)) {
          for (let y = 0; y < 15; y++) {
            for (let x = 0; x < 15; x++) {
              if (narr[y][x] > 0) {
                arr[y][x] = color;
                moves.push(y * 15 + x);
                let idx = getBlockFour(x, y, arr);
                let tx = idx % 15;
                let ty = parseInt(idx / 15);
                arr[ty][tx] = color == 1 ? 2 : 1;
                //冲四方不存在VCF,不验证禁手
                moves.push(ty * 15 + tx);
                if (findMoves(FailMoves, moves)) {
                  moves.length -= 2;
                  arr[ty][tx] = 0;
                  arr[y][x] = 0;
                }
                else {
                  continueFour(arr, color, depth - 1, fMoves, newarr, FailMoves, moves);
                  pushFailMoves(FailMoves, moves.slice(0));
                  fMoves.push(moves.slice(0));
                  moves.length -= 2;
                  arr[ty][tx] = 0;
                  arr[y][x] = 0;
                  newarr[y][x] = color;
                  newarr[ty][tx] = color;
                }
              }
            }
          }
        }
      }
      else if (level.level == 4) {
        let x = level.p.x;
        let y = level.p.y;
        if (isFour(x, y, color, arr)) {
          arr[y][x] = color;
          moves.push(y * 15 + x);
          let idx = getBlockFour(x, y, arr);
          let tx = idx % 15;
          let ty = parseInt(idx / 15);
          arr[ty][tx] = color == 1 ? 2 : 1;
          //冲四方不存在VCF,不验证禁手
          moves.push(ty * 15 + tx);

          if (findMoves(FailMoves, moves)) {
            moves.length -= 2;
            arr[ty][tx] = 0;
            arr[y][x] = 0;
          }
          else {
            continueFour(arr, color, depth - 1, fMoves, newarr, FailMoves, moves);
            pushFailMoves(FailMoves, moves.slice(0));
            fMoves.push(moves.slice(0));
            moves.length -= 2;
            arr[ty][tx] = 0;
            arr[y][x] = 0;
            newarr[y][x] = color;
            newarr[ty][tx] = color;
          }
        }
      }
      //alert("fMoves.length=\n"+fMoves.length+"\n"+fMoves)
    }




    // 找出正确的33点
    function findTTPoint(arr, color, newarr, setnum) {

      try {
        let count = 0;
        findThree(arr, color, newarr);
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] > 0) {
              if (isTT(x, y, arr)) {
                newarr[y][x] = 1;
                count++;
              }
              else {
                newarr[y][x] = 0;
              }
            }
          }
        }

        if (setnum != null) {
          for (let y = 0; y < 15; y++) {
            for (let x = 0; x < 15; x++) {
              if (newarr[y][x] != 0) {
                newarr[y][x] = setnum;
              }
            }
          }
        }

        return count;
      }
      catch (err) {
        alert("findTTpoint err=" + err.message);
      }
    }



    // 搜索米字线,半径内是否有棋子，不判断中心点
    function around(arr, idx, radius) {

      let x = idx % 15;
      let y = parseInt(idx / 15);
      for (let i = 0; i < 4; i++) {
        for (let j = 1; j <= radius; j++) {
          let v = getArrValue(x, y, j, Cmodel[i], arr);
          if (v == 1 || v == 2) return true;
          v = getArrValue(x, y, -j, Cmodel[i], arr);
          if (v == 1 || v == 2) return true;
        }
      }
      return false;
    }




    // 围绕 idx 查找四周的点(包括idx),color=查找颜色，radius=辐射半径
    function aroundFindPoint(arr, idx, radius) {

      try {

        let P = [];
        radius = radius == null ? 7 : radius;

        // 从里到外，绕圈搜索
        let Pnt = aroundPoint[idx];
        let max = Pnt.radius[radius] - 1;
        let x = idx % 15;
        let y = parseInt(idx / 15);
        for (let i = 0; i < 225; i++) {
          if (arr[Pnt.point[i].y][Pnt.point[i].x] > 0) {
            /*
            if ((x==Pnt.point[i].x || y==Pnt.point[i].y || Math.abs(x-Pnt.point[i].x)==Math.abs(y-Pnt.point[i].y))&&i<Pnt.radius[4])  {
                P.splice(0,0,Pnt.index[i]);
            }
            else  {
            */
            P.unshift(Pnt.index[i]);
            //}
          }
          if (i == max && P.length > 2) { break; }
        }
        return P;

      }
      catch (err) {
        alert("aroundPoinr err=" + err.message);
      }
    }




    // 找VCF 级别双杀点
    function* findTwoVCF(arr, color, newarr, count, backstage) {

      let pnt = aroundPoint[112];
      let pNum = 0; //双杀点计数
      let timeout = 30000;
      let depth = 1000;
      count = count || 10000;
      // 确定双杀选点范围
      // 先判断对手进攻级别,快速选点
      yield* selectPoint(arr, color, newarr, timeout, depth, false);
      findThreePoint(arr, color, newarr, Onlyfree, -9999); //排除活三


      for (let i = 0; i < 225; i++) {
        let x = pnt.point[i].x;
        let y = pnt.point[i].y;

        if (!stopFind && newarr[y][x] == 0) {
          // 处理直接防
          arr[y][x] = color;
          if (!backstage) cBoard.printSearchPoint(pnt.index[i], "⊙", "green");
          // 对手准备落子，判断对手是否有攻。
          let nLevel = yield* getLevelB(arr, color == 1 ? 2 : 1, getArr([]), timeout, depth, true);
          //continueFindVCF(color,timeOut,depth,count,backStage,arr) 
          let fNum = nLevel.level >= 3 ? 0 : yield* continueFindVCF(color, timeout, depth, 2, true, copyArr([], arr));
          if (fNum >= 2 || (fNum == 1 && vcfWinMoves[0].length == 1)) { // 有两套V，判断双杀是否成立

            let notWin = false; //后续计算，如果双杀不成立==true
            let bPoint = getBlockVCF(vcfWinMoves, color, arr, true, true);
            //alert(bPoint)
            if (bPoint) { //排除直接防
              if (!(yield* excludeBP(arr, color == 1 ? 2 : 1, bPoint, timeout, depth))) {
                //排除失败，双杀不成立
                notWin = true;
              }
            }

            if (!notWin) { // 没有找到直接共防，继续寻找先手防
              //处理先手防
              let fMoves = []; //  保存先手连续冲四分支
              continueFour(arr, color == 1 ? 2 : 1, 6, fMoves, getArr([]));
              let j;
              for (j = fMoves.length - 1; j >= 0; j--) {
                // 摆棋
                for (let k = fMoves[j].length - 1; k >= 0; k--) {
                  let x = fMoves[j][k] % 15;
                  let y = parseInt(fMoves[j][k] / 15);
                  arr[y][x] = k % 2 ? color : color == 1 ? 2 : 1;
                }
                /*
                let str = "";
                for (let l=0;l<=j;l++)  {
                    str+="\n"+fMoves[l];
                }
                alert(j+"\n"+str)
                */
                let winLevel = yield* getWinLevel(arr, color, timeout, depth, 1);
                //alert("winLevel="+winLevel)
                if (winLevel < 3.5) notWin = true; // 复原棋子

                for (let k = fMoves[j].length - 1; k >= 0; k--) {
                  let x = fMoves[j][k] % 15;
                  let y = parseInt(fMoves[j][k] / 15);
                  arr[y][x] = 0;
                }
                if (notWin) j = -1;
              }
            }
            if (!notWin) { // 双杀成立
              if (!backstage) {
                cBoard.printSearchPoint();
                cBoard.wLb(pnt.index[i], "◎", "red");
              }
              pNum++;
              if (pNum == count) i = 10000;
            }
          }
          arr[y][x] = 0;
        }
        else { // 清空选点范围外的点
          if (!backstage) cBoard.cleLb(pnt.index[i]);
        }
      }
      if (!backstage) cBoard.printSearchPoint();
      return pNum;

    }




    // 排除直接防
    function* excludeBP(arr, color, bPoint, timeout, depth) {

      let i;
      let x;
      let y;
      let fNum;
      let fMoves = []; // 临时保存找到的VCF
      for (i = bPoint.length - 1; i >= 0; i--) {
        x = bPoint[i] % 15;
        y = parseInt(bPoint[i] / 15);
        arr[y][x] = color;
        let j;
        for (j = fMoves.length - 1; j >= 0; j--) {
          if (isVCF(color == 1 ? 2 : 1, arr, fMoves[j])) break;
        }
        fNum = j >= 0 ? 1 : yield* continueFindVCF(color == 1 ? 2 : 1, timeout, depth, 1, true, copyArr([], arr));
        arr[y][x] = 0;
        if (fNum == 0) {
          return false;
        }
        else if (j < 0) { // 新的V
          fMoves.push(vcfWinMoves[0].slice(0));
        }

      }
      return true;
    }





    //限珠题
    function* findSimpleWin(arr, color, newarr, num) {

      let rt = false;
      if (num == 4) {
        let pnt = aroundPoint[112];
        let timeout = 30000;
        let depth = 1;
        // 确定双杀选点范围
        // 先判断对手进攻级别,快速选点
        yield* selectPoint(arr, color, newarr, timeout, depth, false);

        for (let i = 0; i < 225; i++) {
          let x = pnt.point[i].x;
          let y = pnt.point[i].y;

          if (!stopFind && newarr[y][x] == 0) {
            // 处理直接防
            arr[y][x] = color;
            if (true) cBoard.printSearchPoint(pnt.index[i], "⊙", "green");
            let winLevel = yield* getWinLevel(arr, color, timeout, depth, 2, 2);
            if (winLevel > 3) {
              cBoard.printSearchPoint();
              cBoard.wLb(pnt.index[i], "◎", "red");
              rt = true;
            }
            arr[y][x] = 0;
          }
          else { // 清空选点范围外的点
            if (true) cBoard.cleLb(pnt.index[i]);
          }
        }
        if (true) cBoard.printSearchPoint();
      }
      return rt;
    }





    // 搜索VCF,递归计算到深度10，返回给浏览器，等待定时器下一次调用。
    function findVCF(timeOut, depth) {

      try {
        noSleepTime = new Date().getTime(); // 自动防锁屏
        let moves = vcfmoves;
        let arr = vcfarr;
        let newarr = vcfnewarr;
        let fs = vcffs;
        let FailMoves = vcfFailMoves;
        let WinMoves = vcfWinMoves;
        let color = vcfcolor;
        let nColor = vcfnColor;
        let dp = moves.length / 2;

        // 读取对手进攻级别
        let cfLevel = vcfnLevel;

        let tx = 0;
        let ty = 0;
        //首次循环，需要计算对手进攻级别
        if (cfLevel == null) {
          getArr(newarr);
          cfLevel = getLevel(arr, nColor);

        }

        // alert(cfLevel.level)
        if (cfLevel.level < 4 && dp <= depth) { //如果对手进攻级别低于  冲4
          getArr(newarr);
          if (findFourPoint(arr, color, newarr)) {

            fs.push(-1);
            vcfFindDepth++;
            let st = fs.length;
            let ed;

            // 上一手棋为中心，查找周围的点。
            if (fs.length > 1) {
              fs = fs.concat(aroundFindPoint(newarr, moves[moves.length - 2]));
              vcffs = fs; // concat方法改变了内存地址， 重新设置两个变量
            }
            else { // 如果是第一手，就以h8为中心
              fs = fs.concat(aroundFindPoint(newarr, 112));
              vcffs = fs;
            }

            ed = fs.length - 1;
            let idx; // 优先选择活4,再43
            if (ed > st) { // 两个以上冲四点，优先选择活4,再43
              for (idx = ed; idx >= st; idx--) { //找到一个活4级的点可以排除其它点
                let x = fs[idx] % 15;
                let y = parseInt(fs[idx] / 15);
                // 如果没有活4，白棋继续找44，冲4抓
                if (isFFWin(x, y, color, arr)) {
                  let v = fs.splice(idx, 1);
                  fs.splice(st - 1, ed - st + 1);
                  let wMoves = moves.concat(v);
                  if (WinMoves.length == 0) simpleVCF(color, vcfBakArr, wMoves);
                  pushWinMoves(WinMoves, wMoves);
                  pushFailMoves(FailMoves, moves.slice(0, moves.length));
                  backFindVCF();
                  return 1;
                }
              }
              //排序
              for (idx = ed - 1; idx >= st; idx--) {
                let x = fs[idx] % 15;
                let y = parseInt(fs[idx] / 15);
                // 把所有活3排到栈顶
                //判断是否活3，最后一个参数五连，冲4不否定活3
                for (let i = 0; i < 4; i++) {
                  if (isLineThree(x, y, Cmodel[i], color, arr, true)) {
                    let v = fs.splice(idx, 1);
                    fs.push(v);
                    break;
                  }
                }
              }
            }

            // alert(fs)

            tx = fs[ed] % 15;
            ty = parseInt(fs[ed] / 15);
            moves.push(fs[ed]);
            arr[ty][tx] = color;

            moves.push(getBlockFour(tx, ty, arr));
            tx = moves[moves.length - 1] % 15;
            ty = parseInt(moves[moves.length - 1] / 15);

            arr[ty][tx] = nColor;
            // 为下次调用保存进攻级别
            vcfSaveLevel(tx, ty, nColor, arr);

            // 重复了错误分支，再退一手，递归退到合适位置
            let fm = findMoves(FailMoves, moves);
            if (fm) backFindVCF();
          }
          else {
            backFindVCF();
          }

        }
        else if (cfLevel.level == 4 && dp <= depth) { // 如果对手有冲4

          tx = cfLevel.p.x;
          ty = cfLevel.p.y;
          // alert(printArr(arr)+"\n"+cfLevel.p.x+"-"+cfLevel.p.y+"-")
          if (isFour(tx, ty, color, arr)) { // 有反4，继续计算
            if (isFFWin(tx, ty, color, arr)) {
              let wMoves = moves.concat(ty * 15 + tx);
              if (WinMoves.length == 0) simpleVCF(color, vcfBakArr, wMoves);
              pushWinMoves(WinMoves, wMoves);
              pushFailMoves(FailMoves, moves.slice(0, moves.length));
              backFindVCF();
              return 1;
            }
            fs.push(-1);
            vcfFindDepth++;
            fs.push(ty * 15 + tx);
            moves.push(fs[fs.length - 1]);
            arr[ty][tx] = color;

            moves.push(getBlockFour(tx, ty, arr));
            tx = moves[moves.length - 1] % 15;
            ty = parseInt(moves[moves.length - 1] / 15);
            arr[ty][tx] = nColor;
            // 为下次调用保存进攻级别
            vcfSaveLevel(tx, ty, nColor, arr);

            // 重复了错误分支，再退一手，递归退到合适位置
            let fm = findMoves(FailMoves, moves);
            if (fm) backFindVCF();
          }
          else { // 没有反4，计算后续分支
            backFindVCF();
          }

        }
        else { // 对手进攻级别太高，计算后续分支
          backFindVCF();
        }
        if (fs.length == 0) return -1; // 地毯完，VCF失败
        if (new Date().getTime() - vcfStartTimer > timeOut) return -1;
        if (vcfFindDepth % 8) return findVCF(timeOut, depth);
        return 0; //未完，等待定时器调用


        //当前分支不存在VCF,退回。return== true 表示白棋抓禁了
        function backFindVCF() {
          let x;
          let y;
          if (moves.length) { // 退一手
            let l = moves.length;
            x = moves[l - 1] % 15;
            y = parseInt(moves[l - 1] / 15);
            arr[y][x] = 0;
            x = moves[l - 2] % 15;
            y = parseInt(moves[l - 2] / 15);
            arr[y][x] = 0;
            moves.length = l - 2;
            fs.length--;
          }
          // 子分支地毯完，返回上一级
          while (fs.length && fs[fs.length - 1] == -1) {
            fs.length--;
            vcfFindDepth--;
            if (fs.length < 1) continue;
            // 保存失败分支;
            pushFailMoves(FailMoves, moves.slice(0));
            //FailMoves.push(copyMoves(moves));
            let l = moves.length;
            x = moves[l - 1] % 15;
            y = parseInt(moves[l - 1] / 15);
            arr[y][x] = 0;
            x = moves[l - 2] % 15;
            y = parseInt(moves[l - 2] / 15);
            arr[y][x] = 0;
            moves.length = l - 2;
            fs.length--;
          }

          if (fs.length > 1) { // 退到下一分支
            let l = fs.length;
            moves.push(fs[l - 1]);
            x = fs[l - 1] % 15;
            y = parseInt(fs[l - 1] / 15);
            arr[y][x] = color;
            moves.push(getBlockFour(x, y, arr));
            l = moves.length;
            x = moves[l - 1] % 15;
            y = parseInt(moves[l - 1] / 15);

            arr[y][x] = nColor;
            // 为下次调用保存进攻级别
            vcfSaveLevel(x, y, nColor, arr);
            // 重复了错误分支，再退一手
            let fm = findMoves(FailMoves, moves);
            if (fm) backFindVCF();
          }

        }

        // 为findVCF 保存进攻级别
        function vcfSaveLevel(x, y, nColor, arr) {
          // 不用getLevelB,加快计算速度
          if (isFour(x, y, nColor, arr)) { //有冲4
            // 找两个五连点
            if (findFivePointB(y * 15 + x, arr, nColor, 2)) {
              vcfnLevel = { level: 4.5, p: null };
            }
            else { // 一个五连点是冲4
              let idx = getBlockFour(x, y, arr);
              let tx = idx % 15;
              let ty = parseInt(idx / 15);
              // p 保存冲4防点
              vcfnLevel = { level: 4, p: { x: tx, y: ty } };
            }

          }
          else {
            vcfnLevel = { level: 3, p: null };
          }
        }


        // 去掉VCF无谓冲四
        function simpleVCF(color, arr, moves) {

          let nColor = color == 1 ? 2 : 1;
          for (let j = moves.length - 6; j >= 0; j--) { // 摆棋子
            let x = moves[j] % 15;
            let y = parseInt(moves[j] / 15);
            arr[y][x] = j % 2 == 0 ? color : nColor;
          }

          for (let i = moves.length - 5; i >= 0; i -= 2) {

            let VCF = moves.slice(i + 2); // 判断是否无谓冲四      
            if (isVCF(color, arr, VCF)) moves.splice(i, 2); //删除无谓冲四
            for (let j = 1; j < 3; j++) { // 复原两步
              if (i - 1 < 0) break;
              let x = moves[i - j] % 15;
              let y = parseInt(moves[i - j] / 15);
              arr[y][x] = 0;
            }
          }

        }

      }
      catch (err) {
        alert("findVCF err=" + err.message);
      }
    }







    // 
    function* findVCT(arr, color, idx, timeOut, depth, count, backStage) {

      let pnt = aroundPoint[idx];
      let fourP = findFourPoint(arr, color, getArr([])) || [];
      let threeP = yield* findLevelThreePoint(arr, color, getArr([]), null, 224, true);
      alert(threeP.concat(fourP));

      function* findVCTPoint(arr, color, newarr, fType, idx) {

        let threeP = []; // 保存活3点，包括复活3
        let simpleP = []; // 保存坐杀点
        let vcfP = []; // 保存做V点
        let pnt = aroundPoint[idx || 112];
        // 先判断对手进攻级别,快速选点     
        yield* selectPoint(arr, color, newarr, null, null, true);

        for (let i = 0; i < 225; i++) {

          let x = pnt.point[i].x;
          let y = pnt.point[i].y;

          if (!stopFind && newarr[y][x] == 0) {
            arr[y][x] = color;
            let level = yield* getLevelB(arr, color, newarr, null, depth);
            let nColor = color == 1 ? 2 : 1;
            if (level.level > 4) { //冲四,
            }
            else if (level.level < 4 && level.level >= 3) {
              let l = level.moves.length; // 保存手数，待后面判断43杀
              // 已经确认对手低于活三级别
              if ((color == 1 && l == 1) || isThree(x, y, color, arr, true)) {
                if (fType == null) {
                  threeP.splice(0, 0, pnt.index[i]);
                }

              }
              else {

                if (fType == null) {
                  if (l > 3) {
                    vcfP.splice(0, 0, pnt.index[i]);
                  }
                  else {
                    simpleP.splice(0, 0, pnt.index[i]);
                  }
                }
                else { // 进一步判断是否做V
                  if ((fType == OnlyVCF && l > 3) || (fType == OnlySimpleWin && l == 3)) {
                    if (l > 3) {
                      vcfP.splice(0, 0, pnt.index[i]);
                    }
                    else {
                      simpleP.splice(0, 0, pnt.index[i]);
                    }
                  }
                }
              }
            }
            arr[y][x] = 0;
          }
        }
        return vcfP.concat(simpleP, threeP);

      }
    }







    // 返回冲4的防点
    function getBlockFour(x, y, arr) {

      let color = arr[y][x] == 1 ? 2 : 1;
      let nColor = arr[y][x];
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j > -5; j--) {
          let pw = getPower(x, y, arr, Cmodel[i], nColor, j);
          if (pw == 4) {
            if (nColor == 2) {
              let p = getNextEmpty(x, y, arr, Cmodel[i], nColor, j);
              return p.y * 15 + p.x;
            }
            else if (getArrValue(x, y, j - 1, Cmodel[i], arr) != nColor && getArrValue(x, y, j + 5, Cmodel[i], arr) != nColor) {
              let p = getNextEmpty(x, y, arr, Cmodel[i], nColor, j);
              return p.y * 15 + p.x;
            }
          }
        }
      }
      return -1;
    }






    // 找VCF(活三级别)防点，返回一个数组,不存在防点返回 false
    // VCF 二维数组保存保存了 n 套color色VCF,
    function getBlockVCF(VCF, color, arr, backStage, passFour) {

      backStage = backStage == null ? true : backStage;
      let p = [];
      let pnt = aroundPoint[112];
      let len = VCF.length;
      let nColor = color == 1 ? 2 : 1;
      for (let i = 0; i < 225; i++) {
        let x = pnt.point[i].x;
        let y = pnt.point[i].y;
        // color是进攻方颜色
        if (arr[y][x] == 0 && (color == 1 || !isFoul(x, y, arr))) {
          let j;
          arr[y][x] = color == 1 ? 2 : 1;
          for (j = 0; j < len; j++) { // 验证之前VCF是否成立
            if (isVCF(color, arr, VCF[j])) break;
          }
          arr[y][x] = 0;
          // 防住所有VCF,记录防点,过滤掉先手防
          if (j >= len && (!passFour || !isFour(x, y, nColor, arr))) {
            p.push(pnt.index[i]);
            if (!backStage) cBoard.wLb(pnt.index[i], "b", "blue");
          }
        }

      }
      return p.length ? p : false;
    }




    // 找出成立的VCF(活三级别)防点
    function* getBlockVCFb(VCF, color, arr, backStage, passFour) {

      backStage = backStage == null ? true : backStage;
      let p = getBlockVCF(VCF, color, arr, true, passFour);
      if (!p) return false;
      for (let i = p.length - 1; i >= 0; i--) {
        let x = p[i] % 15;
        let y = parseInt(p[i] / 15);
        arr[y][x] = color == 1 ? 2 : 1;
        // 确保没有新的VCF
        let fNum = yield* continueFindVCF(color, 60000, null, 1, true, copyArr([], arr));
        arr[y][x] = 0;
        if (fNum) {
          p.splice(i, 1);
          // 用新VCF排除剩下防点
          for (let j = i - 1; j >= 0; j--) {
            x = p[j] % 15;
            y = parseInt(p[j] / 15);
            arr[y][x] = color == 1 ? 2 : 1;
            if (isVCF(color, arr, vcfWinMoves[0])) {
              p.splice(j, 1);
              i--;
            }
            arr[y][x] = 0;
            if (stopFind) j = -1;
          }
        }
        else {
          if (!backStage) cBoard.wLb(y * 15 + x, "b", "blue");
        }
        if (stopFind) i = -1;
      }

      return p.length ? p : false;
    }





    // 返回进攻级别,调用之前必须清空newarr,完成后newarr保存有五连点的信息
    function getLevel(arr, color, pass) {

      if (isWin(color == 1 ? 2 : 1, arr)) return { level: 0, p: null };
      if (isWin(color, arr)) return { level: 5, p: null };
      let newarr = getArr([]);
      if (findFivePoint(arr, color, newarr)) {
        let count = 0;
        let p;
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] > 0) {
              count++;
              if (count == 2) {
                // p 保存冲4防点
                return { level: 4.5, p: p }; // 44 || 活4
              }
              p = { "x": x, "y": y };
            }
          }
        }
        if (color == 2 && isFoul(p.x, p.y, arr)) return { level: 4.5, p: p }; //冲4抓
        return { level: 4, p: p }; // 单冲4
      }

      return { level: 0, p: null };

    }




    // 计算进攻级别，
    // level =={level:level,p:{x:x,y:y} || moves:moves};
    // level.level==4 ,level =={level:level,p:{x:x,y:y} ,p保存冲4防点
    // level.level==3,level =={level:level,moves:moves} moves保存一套成立的VCF手顺
    function* getLevelB(arr, color, newarr, timeout, depth, backstage) {

      timeout = timeout || 10000;
      depth = depth || 100;
      backstage = backstage !== false ? true : false;
      // 判断是否有在冲4以上进攻级别
      let level = getLevel(arr, color);
      if (level.level >= 4) {
        return level;
      }
      // 判断是否有活3 级别
      /*        // 快速对比之前的计算结果，快速判断VCF
      let winMoves = color==1 ? vcfBlackWinMoves : vcfWhiteWinMoves;
      let len = winMoves.length;
      for (let i=0; i<len; i++) {
          if (winMoves[i].length<=depth*2+1) {
              if (isVCF(color,arr,winMoves[i])) {
                  return {level:3,moves:winMoves[i]} ;
              }
          }
          else {
              i = 10000;
          }
      }
      */

      // 快速搜索VCF
      //(color,timeout,depth,count,backstage,arr)
      let temparr = []; // 复制arr,避免 continueFindVCF 改变数值
      copyArr(temparr, arr);
      let n = yield* continueFindVCF(color, timeout, depth, 1, backstage, temparr);
      if (n > 0) {
        return ({ level: 3, moves: vcfWinMoves[0] });
      }
      else {
        return ({ level: 2, moves: null });
      }

    }


    // 轮到对手落子
    // 判断必胜级别 depth==vcf深度，gDepth==递归深度, maxNum==最大手数，单色手数
    function* getWinLevel(arr, color, timeout, depth, gDepth, maxNum) {

      timeout = timeout || 30000;
      depth = depth || 1000;
      gDepth = gDepth || 2;
      maxNum = maxNum || 1000;
      // 判断对手进攻级别
      let nLevel = yield* getLevelB(arr, color == 1 ? 2 : 1, getArr([]), timeout, depth, true);
      let winLevel;
      //alert("对手进攻级别="+nLevel.level)
      if (nLevel.level == 5) { // 对手已胜
        return 2;
      }
      else if (nLevel.level >= 3) { // 对手有攻,没五连就败了
        winLevel = getLevel(arr, color);
        return winLevel.level == 5 ? 5 : 2;
      }
      else { // 对方没有V
        winLevel = getLevel(arr, color);
        if (winLevel.level >= 4.5) {
          return winLevel.level; //==5 or ==4.5
        }
        else if (winLevel.level == 4) {
          let y = winLevel.p.y;
          let x = winLevel.p.x;
          arr[y][x] = color == 1 ? 2 : 1;
          let num = yield* continueFindVCF(color, timeout, depth, 1, true, copyArr([], arr));
          arr[y][x] = 0;
          if (num) return 4.4;
        }

        //continueFindVCF(color,timeOut,depth,count,backStage,arr) 
        let fNum = yield* continueFindVCF(color, timeout, depth, 1, true, copyArr([], arr));
        if (fNum >= 1) { // 有(一套以上)两套V，判断双杀是否成立

          let notWin = false; //后续计算，如果双杀不成立==true
          let bPoint = getBlockVCF(vcfWinMoves, color, arr, true, true);
          if (bPoint) { //排除直接防
            if (!(yield* excludeBP(arr, color == 1 ? 2 : 1, bPoint, timeout, depth))) {
              //排除失败，双杀不成立
              notWin = true;
            }
          }

          if (!notWin && gDepth >= 2) { // 没有找到直接共防，继续寻找先手防
            //处理先手防
            let fMoves = []; //  保存先手连续冲四分支
            continueFour(arr, color == 1 ? 2 : 1, 6, fMoves, getArr([]));
            for (let i = fMoves.length - 1; i >= 0; i--) {
              if (fMoves[i].length / 2 >= maxNum) {
                notWin = true;
                fMoves = [];
                break;
              }
            }
            let j;

            for (j = fMoves.length - 1; j >= 0; j--) {
              //alert("gDepth="+gDepth+"\nj="+j);

              // 摆棋
              for (let k = fMoves[j].length - 1; k >= 0; k--) {
                let x = fMoves[j][k] % 15;
                let y = parseInt(fMoves[j][k] / 15);
                arr[y][x] = k % 2 ? color : color == 1 ? 2 : 1;
              }
              /*
               let str = "";
               for (let l=0;l<=j;l++)  {
                   str+="\n"+fMoves[l];
               }
               alert(j+"\n"+str)
              */
              winLevel = yield* getWinLevel(arr, color, timeout, depth, gDepth - 1, maxNum - fMoves[j].length / 2);
              //alert("_____"+winLevel)
              if (winLevel < 3.5) notWin = true;

              // 复原棋子
              for (let k = fMoves[j].length - 1; k >= 0; k--) {
                let x = fMoves[j][k] % 15;
                let y = parseInt(fMoves[j][k] / 15);
                arr[y][x] = 0;
              }
              if (notWin) j = -1;
            }
          }

          return notWin ? 2 : 3.5;
        }
        return 2;
      }

    }




    // 确定选点范围
    function* selectPoint(arr, color, newarr, timeout, depth, backstage, level) {

      timeout = timeout || 30000;
      depth = depth || 1000;
      backstage = backstage == null ? true : backstage;
      // 确定活三级选点范围
      // 先判断对手进攻级别,快速选点

      if (!level) level = yield* getLevelB(arr, color == 1 ? 2 : 1, getArr([]), timeout, depth);
      if (level.level >= 5) {
        return getArr(newarr, -9999);
      }
      else if (level.level >= 4.5) {
        let narr = getArr([]);
        findFivePoint(arr, color == 1 ? 2 : 1, narr);
        for (let y = 0; y < 15; y++) {
          for (let x = 0; x < 15; x++) {
            newarr[y][x] = narr[y][x] != 0 ? 0 : -9999;
          }
        }
        return newarr;
      }
      else if (level.level >= 4) {

        // 对手冲四，选点唯一
        getArr(newarr, -9999);
        // p保存的是防点
        newarr[level.p.y][level.p.x] = 0;

      }
      else if (level.level >= 3) {

        // 对手有V，选点范围在V的防点内
        let mv = []; //转二维数组
        mv.push(level.moves);
        let p = yield* getBlockVCFb(mv, color == 1 ? 2 : 1, arr, true);
        getArr(newarr, -9999);

        for (let i = p.length - 1; i >= 0; i--) {
          let x = p[i] % 15;
          let y = parseInt(p[i] / 15);
          newarr[y][x] = 0;
        }

      }
      else { // level.level<3

        let narr = getArr([]);
        let narr1 = getArr([]);
        findFour(arr, color == 1 ? 2 : 1, narr1, null); // 保存对手冲四点
        continueFour(arr, color, depth < 4 ? depth : 4, [], narr); //分析连续冲四
        for (let y = 0; y < 15; y++) { // 把 arr 的数据合并到 narr;
          for (let x = 0; x < 15; x++) {
            if (arr[y][x] == color) narr[y][x] = color;
          }
        }
        for (let y = 0; y < 15; y++) { // 把 arr 的数据合并到 narr;
          for (let x = 0; x < 15; x++) {
            newarr[y][x] = (arr[y][x] == 0 && (around(narr, y * 15 + x, 3) || narr1[y][x] > 0)) ? 0 : -9999;
          }
        }

      }

      // 再排除黑禁手
      findFourPoint(arr, color, newarr, null, -9999); //排除冲4
      //findThreePoint (arr,color,newarr,Onlyfree,-9999); //排除活三
      if (color == 1) findFoulPoint(arr, newarr, -9999); //排除禁手

      if (!backstage) printNewarr(newarr);

      return newarr;

      function printNewarr(newarr) {
        for (let y = 0; y < 15; y++) { // 
          for (let x = 0; x < 15; x++) {
            if (newarr[y][x] == 0) cBoard.wLb(y * 15 + x, "●", "#888888");
          }
        }
      }

    }





    function getNextEmpty(x, y, arr, model, color, move, maxLen) {

      try {

        let nx = -1;
        let ny = -1;
        move = move == null ? 0 : move;
        maxLen = maxLen == null ? 5 : maxLen;
        switch (String(model)) {

          case "x":

            for (let i = 0; i < maxLen; i++) {
              if (x + i + move > 14 || x + i + move < 0) break;
              if (arr[y][x + i + move] == 0) { nx = x + i + move;
                ny = y; break; }
            }
            break;
          case "y":

            for (let i = 0; i < maxLen; i++) {
              if (y + i + move > 14 || y + i + move < 0) break;
              if (arr[y + i + move][x] == 0) { nx = x;
                ny = y + i + move; break; }
            }
            break;
          case "d":

            for (let i = 0; i < maxLen; i++) {
              if (y + i + move > 14 || y + i + move < 0 || x + i + move > 14 || x + i + move < 0) break;
              if (arr[y + i + move][x + i + move] == 0) { nx = x + i + move;
                ny = y + i + move; break; }
            }
            break;
          case "u":

            for (let i = 0; i < maxLen; i++) {
              if (y - i - move < 0 || y - i - move > 14 || x + i + move > 14 || x + i + move < 0) break;
              if (arr[y - i - move][x + i + move] == 0) { nx = x + i + move;
                ny = y - i - move; break; }
            }
            break;
        }

        return { 'x': nx, 'y': ny };
      }
      catch (err) {
        alert("getNextEmpty err=" + err.message);
      }

    }






    // x,y,坐标代表第一个点和后面的4个点成五格。返回在这五格内的子力。
    function getPower(x, y, arr, model, color, move, maxLen) {

      try {
        let count = 0;
        let thisColor = color;
        let nColor = thisColor == 1 ? 2 : 1;
        move = move == null ? 0 : move;
        maxLen = maxLen == null ? 5 : maxLen;

        switch (String(model)) {

          case "x":
            for (let i = 0; i < maxLen; i++) {
              if ((x + i + move) < 0 || (x + i + move) > 14) {
                return -1;
              }
              if (arr[y][x + i + move] == nColor) return -1;
              if (arr[y][x + i + move] == thisColor) count++;
            }
            break;
          case "y":
            for (let i = 0; i < maxLen; i++) {
              if ((y + i + move) < 0 || (y + i + move) > 14) {
                return -1;
              }
              if (arr[y + i + move][x] == thisColor) count++;
              if (arr[y + i + move][x] == nColor) return -1;
            }
            break;
          case "d":
            for (let i = 0; i < maxLen; i++) {
              if ((y + i + move) < 0 || (y + i + move) > 14 || (x + i + move) < 0 || (x + i + move) > 14) {
                return -1;
              }
              if (arr[y + i + move][x + i + move] == thisColor) count++;
              if (arr[y + i + move][x + i + move] == nColor) return -1;
            }
            break;
          case "u":
            for (let i = 0; i < maxLen; i++) {
              if ((y - i - move) < 0 || (y - i - move) > 14 || (x + i + move) < 0 || (x + i + move) > 14) {
                return -1;
              }
              if (arr[y - i - move][x + i + move] == thisColor) count++;
              if (arr[y - i - move][x + i + move] == nColor) return -1;
            }
            break;
        }

        if (count == maxLen) {
          let nx = changeX(x, maxLen + move, model);
          let ny = changeY(y, maxLen + move, model);

          for (let i = 0; i < 10; i++) {
            if (nx < 0 || nx > 14 || ny < 0 || ny > 14) break;
            if (arr[ny][nx] == thisColor) {
              count++;
            }
            else
            {
              break;
            }

            nx = changeX(nx, 1, model);
            ny = changeY(ny, 1, model);
          }
        }

        return count;
      }
      catch (err) {
        alert("getPower err=" + err.message);
      }

    }





    function getArr(arr, setnum, x, y) {

      try {
        let j = 0;
        setnum = setnum || 0;
        x = x || 15;
        y = y || 15;
        arr.length = 0;
        for (j = 0; j < y; j++) {
          arr[j] = [];
          for (let i = 0; i < x; i++) {
            arr[j][i] = setnum;
          }
        }
        return arr;
      }
      catch (err) {
        alert("getArr err=" + err.message);
      }
    }


    // 把arr 数组格式化成棋盘 字符串
    function printArr(arr) {

      try {
        let s = "";
        for (let i = 0; i < 15; i++) {

          s += "\n";
          for (let j = 0; j < 15; j++) {
            s += (arr[i][j] + String.fromCharCode(32) + String.fromCharCode(32));
          }
        }

        return s;
      }
      catch (err) {
        alert("printArr err=" + err.message);
      }
    }


    // 取得一个点的值
    function getArrValue(x, y, move, model, arr) {

      try {
        let nx = changeX(x, move, model);
        let ny = changeY(y, move, model);
        if (nx >= 0 && nx <= 14 && ny >= 0 && ny <= 14) {
          return arr[ny][nx];
        }
        return null;
      }
      catch (err) {
        alert("getArrValue err=" + err.message);
      }
    }



    // 取得一个点的x,y
    function getArrPoint(x, y, move, model, arr) {

      try {
        let nx = changeX(x, move, model);
        let ny = changeY(y, move, model);
        if (nx >= 0 && nx <= 14 && ny >= 0 && ny <= 14) {
          return { x: nx, y: ny };
        }
        return { x: -1, y: -1 };
      }
      catch (err) {
        alert("getArrPoint err=" + err.message);
      }
    }




    // 取得一个点的Index
    function getArrIndex(x, y, move, model, arr) {

      try {
        let nx = changeX(x, move, model);
        let ny = changeY(y, move, model);
        if (nx >= 0 && nx <= 14 && ny >= 0 && ny <= 14) {
          return ny * 15 + nx;
        }
        return -1;
      }
      catch (err) {
        alert("getArrIndex err=" + err.message);
      }
    }




    function getX(idx) {

      return idx % 15;
    }


    function getY(idx) {

      return parseInt(idx / 15);
    }




    function changeX(x, move, model) {

      try {
        switch (String(model)) {
          case "x":
            return x + move;
            break;
          case "y":
            return x;
            break;
          case "d":
            return x + move;
            break;
          case "u":
            return x + move;
            break;
        }
      }
      catch (err) {
        alert("changeX err=" + err.message);
      }
    }


    function changeY(y, move, model) {

      try {
        switch (String(model)) {
          case "x":
            return y;
            break;
          case "y":
            return y + move;
            break;
          case "d":
            return y + move;
            break;
          case "u":
            return y - move;
            break;
        }
      }
      catch (err) {
        alert("changeY err=" + err.message);
      }
    }
  </script>
  
</body>

</html>
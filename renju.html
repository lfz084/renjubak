<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes" >
  <link rel="shortcut icon" href="./pic/favicon1.ico">
  <link href="./style/renju.css" rel="stylesheet" type="text/css">
  <title> 摆棋小工具</title>

</head>


<body>
  <script src="./script/NoSleep.min.js"></script>
  <script src="./script/button.js"></script>
  <script src="./script/msgbox.js"></script>
  <script src="./script/checkerBoard.js"></script>
  <script src="./script/viewport.js"></script>
  <script src="./script/engine.js"></script>
  <script src="./script/jsPDF/jspdf.customfonts.min.js"></script>
  <script language="javascript">
    "use strict";
    
    let viewport = new view();
    let d = document;
    let dw = d.documentElement.clientWidth;
    //alert(dw);
    let dh = d.documentElement.clientHeight;
    let cWidth = dw < dh ? dw * 0.95 : dh * 0.95;
    cWidth = dw < dh ? cWidth : dh  < dw/2 ? dh : dw/2;
    //cWidth = 950;
    // dw = 2000;
    //  dh = 2000;
    let noSleep;
    let isNoSleep = false; // bodyTouchStart 防止锁屏
    let noSleepTime = 0;
    if (typeof(NoSleep) == "function") {
      noSleep = new NoSleep();
      setInterval(function() {
        if ((new Date().getTime() - noSleepTime) < 3000) {
          if (!isNoSleep) { isNoSleep = true;
            noSleep.enable(); }
        }
        else
        {
          if (isNoSleep) { isNoSleep = false;
            noSleep.disable(); }
        }
      }, 30 * 1000);
    }
    

    //用来保存跟踪正在发送的触摸事件

    let canvasStartTouches = [];

    let bodyStartTouches = [];

    let previousTouch = []; // 辅助判断双击

    let bodyPreviousTouch = [];

    let bodyMoveTouches = [];

    let continueSetCutDivX = 0;
    let continueSetCutDivY = 0;

    let isBodyClick = false; // 辅助判断单击

    let timerCanvasKeepTouch = null;

    let timerBodyKeepTouch = null;

    let timerContinueSetCutDiv = null;

    let cBoard = null; //棋盘对象


    document.write(`<div width = 100% style = "height:${cWidth*4}px" ></div>`);
    if (dw > dh) {
      d.write(`<div id="up" style="position:absolute;left:${0}px;top:0px;" > </div>`);
      d.write(`<div id="down" style="position:absolute;left:${cWidth*1.06}px;top:0px;" > </div>`);
    }
    else {
      d.write(`<div id="up" style="position:absolute;left:${(dw-cWidth)/2}px;top:${cWidth}px;" > </div>`);
      d.write(`<div id="down" style="position:absolute;left:0px;top:${cWidth*2.06}px;" > </div>`);
    }



    document.body.onload = function() {

      cBoard = new checkerBoard(d.getElementById("up"), 0, 0, cWidth, cWidth);
      cBoard.printCheckerBoard();

      setCheckerBoardEvent(cBoard.canvas);

      createRenjuCmdDiv(d.getElementById("down"), 0, 0, cWidth, cWidth);

      createImgCmdDiv(d.getElementById("down"), 0, 0, cWidth, cWidth);

      renjuLoad();


    }



    //设置事件处理程序

    function setCheckerBoardEvent(canvas) {

      canvas.addEventListener("touchstart", handleStart, false);

      canvas.addEventListener("touchend", handleEnd, false);

      canvas.addEventListener("touchcancel", handleCancel, false);

      canvas.addEventListener("touchleave", handleCancel, false);

      canvas.addEventListener("touchmove", handleMove, false);

      //canvas.addEventListener("click", canvasClick, false);

      canvas.addEventListener("contextmenu", bodyKeepTouch, false);

      canvas.addEventListener("dblclick", canvasDblClick, false);


      document.body.addEventListener("touchstart", bodyTouchStart, true);

      document.body.addEventListener("touchend", bodyTouchEnd, true);

      document.body.addEventListener("touchcancel", bodyTouchCancel, true);

      document.body.addEventListener("touchleave", bodyTouchEnd, true);

      document.body.addEventListener("touchmove", bodyTouchMove, true);

      document.body.addEventListener("click", canvasClick, false);

    }



    //处理触摸开始事件

    function handleStart(evt) {

      //evt.preventDefault();//阻止事件的默认行为

    }



    //处理触摸移动事件

    function handleMove(evt) {
    
      if (timerContinueSetCutDiv) evt.preventDefault();

    }



    //处理触摸结束事件

    function handleEnd(evt) {

      evt.preventDefault();

    }



    //处理触摸对出事件

    function handleCancel(evt) {

      evt.preventDefault();


    }



    //处理触摸开始事件

    function bodyTouchStart(evt) {

      //evt.preventDefault();
      //阻止事件的默认行为
      if (isMsgShow) return;
      // 防止锁屏

      let touches = evt.changedTouches;

      //记录坐标，给continueSetCutDiv使用
      continueSetCutDivX = touches[0].pageX;
      continueSetCutDivY = touches[0].pageY;

      if (bodyStartTouches.length == 0) {

        if (bodyPreviousTouch.length) { //触发滑动调整
          //evt.preventDefault();
          if (timerContinueSetCutDiv == null) {
            timerContinueSetCutDiv = setTimeout(continueSetCutDivStart, 0);
            // 触发长按事件之前删除定时器，变量timerBodyKeepTouch还要用来判断双击事件，由touchend 清空变量。
            setTimeout(function() { clearTimeout(timerBodyKeepTouch) }, 600);
          }
        }

        //初始化长按事件
        if (!timerBodyKeepTouch) timerBodyKeepTouch = setTimeout(bodyKeepTouch, 900);

        //保存当前触摸点
        bodyStartTouches.push(copyTouch(touches[0], 1));
        //初始化单击事件
        isBodyClick = true;

      }
      else
      {
       
        // 多点触摸取消长按事件
        if (timerBodyKeepTouch) {
          clearTimeout(timerBodyKeepTouch);
          timerBodyKeepTouch = null;
        }

        let touchNum = bodyStartTouches.length + 1; //判断是第几个手指触摸屏幕
        if (touchNum > 3) return; //超过3指忽略
        // 多点触摸 取消单击事件。
        isBodyClick = false;
        bodyStartTouches.push(copyTouch(touches[0], touchNum));
      }

    }



    //处理触摸移动事件

    function bodyTouchMove(evt) {
      
      if (timerContinueSetCutDiv) evt.preventDefault();
      let touches = evt.changedTouches;

      if (isMsgShow) return;

      if (timerBodyKeepTouch != null) { //取消长按事件
        clearTimeout(timerBodyKeepTouch);
        timerBodyKeepTouch = null;
      }

      //记录坐标，给continueSetCutDiv使用
      continueSetCutDivX = touches[0].pageX;
      continueSetCutDivY = touches[0].pageY;

      if ((bodyPreviousTouch.length && Math.abs(bodyPreviousTouch[0].pageX - touches[0].pageX) > 30) && (Math.abs(bodyPreviousTouch[0].pageY - touches[0].pageY) > 30)) {
        // 取消单击事件。
        isBodyClick = false;
      }

    }



    //处理触摸结束事件

    function bodyTouchEnd(evt) {

      //evt.preventDefault();
      if (isMsgShow) return;
      let cancelClick = false;

      let touches = evt.changedTouches;

      let idx = onTouchesIndex(touches[0].identifier, bodyStartTouches);
      // 取消  ContinueSetCutDiv 事件
      clearTimeout(timerContinueSetCutDiv);
      if (timerContinueSetCutDiv) {
        timerContinueSetCutDiv = null;
        setTimeout(continueSetCutDivEnd(), 10);
      }

      if (timerBodyKeepTouch) { //取消长按事件
        clearTimeout(timerBodyKeepTouch);
        timerBodyKeepTouch = null;
      }
      else // 触发了长按事件，取消单击
      {
        cancelClick = true;
      }

      if (idx >= 0) {

        let sX = bodyStartTouches[idx].pageX;
        let sY = bodyStartTouches[idx].pageY;
        let tX = touches[0].pageX;
        let tY = touches[0].pageY;
        let xMove = tX - sX;
        let yMove = tY - sY;

        let touchNum = bodyStartTouches.length; //判断是第几个手指触摸屏幕

        if (touchNum > 3) { // 超过3指重置触摸跟踪
          bodyStartTouches.length = 0; //remove it; we're done
          return;
        }


        if ((!cancelClick) && isBodyClick) {
          if ((bodyPreviousTouch.length > 0) && (Math.abs(bodyPreviousTouch[0].pageX - tX) < 30) && (Math.abs(bodyPreviousTouch[0].pageY - tY) < 30)) {
            bodyPreviousTouch.length = 0;
            /////////这里添加双击事件////////
            //通过 isOut 模拟 canvas事件
            if (!cBoard.isOut(tX, tY, cBoard.canvas)) {
              setTimeout(canvasDblClick(tX, tY), 10);
              //log("canvas 双击");
            }
            else {
              setTimeout(bodyDblClick(tX, tY), 10);
              //log("Body 双击");
            }
          }
          else {
            bodyPreviousTouch[0] = copyTouch(touches[0], 1);
            setTimeout("bodyPreviousTouch.length = 0;", 500);
            /////////这里添加单击事件////////
            //通过 isOut 模拟 canvas事件
            if (!cBoard.isOut(tX, tY, cBoard.canvas)) {
              evt.preventDefault();
              setTimeout(canvasClick(tX, tY), 10);
              //log("canvas 单击","red");
            }
            else {
              setTimeout(bodyClick(tX, tY), 10);
              //log("Body 单击","red");
            }
          }
        }
        else if (xMove > 380 && Math.abs(xMove / yMove) > 2) {

          //log("右滑", "red");
        }
        else if (xMove < -380 && Math.abs(xMove / yMove) > 2) {

          //log("左滑", "red");
        }
        else if (yMove > 380 && Math.abs(yMove / xMove) > 2) {

          //log("下滑", "red");
        }
        else if (yMove < -380 && Math.abs(yMove / xMove) > 2) {

          //log("上滑", "red");
        }


        bodyStartTouches.splice(idx, 1); //remove it;we're done

      } else {
        // 出错重新初始化 触摸跟踪
        bodyStartTouches.length = 0;

      }

      bodyStartTouches.length = 0;
    }



    //处理触摸对出事件

    function bodyTouchCancel(evt) {

      evt.preventDefault();

      let touches = evt.changedTouches;
      // 取消 continueSetCutDiv 事件
      clearInterval(timerContinueSetCutDiv);
      if (timerContinueSetCutDiv) {
        timerContinueSetCutDiv = null;
        setTimeout(continueSetCutDivEnd(), 10);
      }

      if (timerBodyKeepTouch) { // 取消长按事件
        clearTimeout(timerBodyKeepTouch);
        timerBodyKeepTouch = null;
      }

      bodyStartTouches.length = 0;
    }





    //拷贝一个触摸对象

    function copyTouch(touch, touchNum) {

      return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY, touchNum: touchNum };

    }





    //找出正在进行的触摸

    function onTouchesIndex(idToFind, touches) {

      for (let i = 0; i < touches.length; i++) {

        let id = touches[i].identifier;

        if (id == idToFind) {

          return i;

        }

      }

      return -1; //notfound

    }




    function canvasKeepTouch(x, y) {

      if (playModel == renjuModel) {
        if (event && event.type == "contextmenu") {
          renjuKeepTouch(event.pageX, event.pageY);
        }
        else {
          renjuKeepTouch(x, y);
        }
      }
      else {
        if (cLockImg.checked) {
          putCheckerBoard(cBoard.getPIndex(x, y));
        }
        else {
          if (!timerContinueSetCutDiv) timerContinueSetCutDiv = setTimeout(continueSetCutDivStart, 10);
        }
      }

    }


    function canvasClick(x, y) {

      if (isMsgShow) return; // 针对鼠标事件
      x = event.type == "click" ? event.pageX : x;
      y = event.type == "click" ? event.pageY : y;
      if (playModel == renjuModel) {
        renjuClick(x, y);
      }
      else if (!cLockImg.checked) {
        if (cBoard.isOut(x, y, cBoard.canvas)) return;
        let p = { x: x, y: y };
        cBoard.setxy(p, 1);
        cBoard.setCutDiv(p.x, p.y, true);
        cBoard.resetP();
        cBoard.printBorder();
      }
      else {
        let idx = cBoard.getPIndex(x, y);
        if (idx < 0) return;
        let color = cAddwhite2.checked ? "white" : "black";
        if (cBoard.P[idx].type != tEmpty) {
          cBoard.P[idx].cle();
        }
        else {
          cBoard.P[idx].printNb("★", color, cBoard.gW, cBoard.gH);
        }
      }
    }


    function canvasDblClick(x, y) {

      if (playModel == renjuModel) {
        if (event.type == "dblclick") {
          renjuDblClick(event.pageX, event.pageY);
        }
        else {
          renjuDblClick(x, y);
        }
      }
    }


    function bodyClick(x, y) {}



    function bodyDblClick() {

    }


    function bodyKeepTouch() {

      clearTimeout(timerBodyKeepTouch); //防止与canvas重复重复
      timerBodyKeepTouch = null;
      let x = bodyStartTouches[0].pageX;
      let y = bodyStartTouches[0].pageY;
      //  针对 msg 弹窗 恢复下一次长按事件
      bodyStartTouches.length = 0;
      //通过 isOut 模拟 canvas事件
      if (!cBoard.isOut(x, y, cBoard.canvas)) {
        setTimeout(canvasKeepTouch(x, y), 10);
        //log("canvad 长按");
      }
      else {
        //log("Body 长按");
      }

    }



    function continueSetCutDivStart() {
      if (playModel == renjuModel || cLockImg.checked) return;
      setTimeout(cBoard.cleAllPointBorder(), 10);
      continueSetCutDivMove();
    }




    function continueSetCutDivMove() {

      //log("continueSetCutDiv start");
      let x = parseInt(continueSetCutDivX);
      let y = parseInt(continueSetCutDivY);
      let p = { x: x, y: y };
      if (!cBoard.isOut(x, y, cBoard.canvas))
      {
        cBoard.setxy(p, 0.25);
        cBoard.setCutDiv(p.x, p.y, true);
      }

      if (timerContinueSetCutDiv != null) timerContinueSetCutDiv = setTimeout(continueSetCutDivMove, 150);
    }




    function continueSetCutDivEnd() {
      if (playModel == renjuModel || cLockImg.checked) return;
      timerContinueSetCutDiv = null;
      cBoard.resetP();
      cBoard.printBorder();

    }
  </script>
  
  <script language="javascript">
    "use strict";
    const maxThread = window.navigator.hardwareConcurrency-1 || 2;
    const renjuModel = 0;
    const imgModel = 1;
    let playModel = renjuModel;
    let lbColor = ["black", "green", "red"];
    let renjuCmddiv = null;
    let imgCmdDiv = null;

    let cLockImg = null;
    let cPutBoard = null;
    let cAutoPut = null;
    let cCleAll = null;
    let cShownum = null;
    let cCleLb = null;
    let cLocknum = null;
    let cAutoadd = null;
    let cAddblack = null;
    let cAddwhite = null;
    let cAddblack2 = null;
    let cAddwhite2 = null;
    let cLba = null;
    let cLbb = null;
    let cLbc = null;
    let cLbd = null;
    let cLbColor = null;
    let cBack = null;
    let cResetnum = null;
    let cReset = null;
    let cNextone = null;
    let cInputcode = null;
    let cOutputcode = null;
    let cStart = null;
    let cEnd = null;
    let cPrevious = null;
    let cNext = null;
    let cFlipX = null;
    let cFlipY = null;
    let cCW = null;
    let cCCW = null;
    let cLABC = null;
    let cMoveL = null;
    let cMoveR = null;
    let cMoveT = null;
    let cMoveB = null;
    let cCutImage = null;
    let cSelBlack = null;
    let cSelWhite = null;
    let cPrintVCF = null;
    let cFindPoint = null;
    let cFindVCF = null;
    let cCancelFind = null;
    let cObjVCF = { arr: [], winMoves: [], color: 0, time: false }; // 保存VCF分支
    let cLoadImg = null;
    let cSLTX = null;
    let cSLTY = null;
    let putCheckerBoard = function() {};


    // renju 模式控制面板
    function createRenjuCmdDiv(parentNode, left, top, width, height) {

      renjuCmddiv = document.createElement("div");
      parentNode.appendChild(renjuCmddiv);
      renjuCmddiv.style.position = "absolute";
      renjuCmddiv.style.width = width/1.15 +"px";
      renjuCmddiv.style.height = width+"px";
      renjuCmddiv.style.top = parseInt(top)+"px";
      renjuCmddiv.style.left = (dw - parseInt(renjuCmddiv.style.width)) / 2+"px";
      if (dw > dh) renjuCmddiv.style.left = (dw - cWidth * 2) / 2+"px";

      let sw = parseInt(renjuCmddiv.style.width);
      let w = sw / 9;
      let h = w / 1.5;
      let t = 0;


      cStart = new button(renjuCmddiv, "button", w * 0, t, w, h);
      cStart.show();
      cStart.setText("‖<<");
      cStart.setontouchend(function() {
        cBoard.toStart(cShownum.checked);
      });

      cPrevious = new button(renjuCmddiv, "button", w * 1.6, t, w, h);
      cPrevious.show();
      cPrevious.setText(" <<");
      cPrevious.setontouchend(function() {
        cBoard.toPrevious(cShownum.checked);
      });

      cNext = new button(renjuCmddiv, "button", w * 3.2, t, w, h);
      cNext.show();
      cNext.setText(">>");
      cNext.setontouchend(function() {
        cBoard.toNext(cShownum.checked);
      });

      cEnd = new button(renjuCmddiv, "button", w * 4.8, t, w, h);
      cEnd.show();
      cEnd.setText(" >>‖");
      cEnd.setontouchend(function() {
        cBoard.toEnd(cShownum.checked);
      });

      cShownum = new button(renjuCmddiv, "checkbox", w * 6.4, t, w, h);
      cShownum.show();
      cShownum.setText("●", "❶");
      cShownum.setChecked(1);
      cShownum.setontouchend(function() {
        renjucShownumClick();
        cBoard.isShowNum = cShownum.checked;
        //cShownum.setText(cShownum.checked?"❶" :"●");
      });

      cCleLb = new button(renjuCmddiv, "button", w * 8, t, w, h);
      cCleLb.show();
      cCleLb.setText("新棋局");
      cCleLb.setontouchend(function() {
        cBoard.cle();
        cBoard.resetNum = 0;
      });


      w = sw / 9;
      t = t + h * 1.5;

  

      cFlipY = new button(renjuCmddiv, "button", w * 0, t, w, h);
      cFlipY.show();
      cFlipY.setText("↔180°");
      cFlipY.setontouchend(function() {
        cBoard.boardFlipY(cShownum.checked);
      });

      cCW = new button(renjuCmddiv, "button", w * 1.6, t, w, h);
      cCW.show();
      cCW.setText(" ↗90°");
      cCW.setontouchend(function() {
        cBoard.boardCW(cShownum.checked);
      });

  

      cMoveL = new button(renjuCmddiv, "button", w * 3.2, t, w, h);
      cMoveL.show();
      cMoveL.setColor("black");
      cMoveL.setText("←");
      cMoveL.setontouchend(function() {
        cBoard.moveCheckerBoard("left");
      });

      cMoveR = new button(renjuCmddiv, "button", w * 4.8, t, w, h);
      cMoveR.show();
      cMoveR.setColor("black");
      cMoveR.setText("→ ");
      cMoveR.setontouchend(function() {
        cBoard.moveCheckerBoard("right");
      });

      cMoveT = new button(renjuCmddiv, "button", w * 6.4, t, w, h);
      cMoveT.show();
      cMoveT.setColor("black");
      cMoveT.setText(" ↑");
      cMoveT.setontouchend(function() {
        cBoard.moveCheckerBoard("top");
      });

      cMoveB = new button(renjuCmddiv, "button", w * 8, t, w, h);
      cMoveB.show();
      cMoveB.setColor("black");
      cMoveB.setText("↓");
      cMoveB.setontouchend(function() {
        cBoard.moveCheckerBoard("bottom");
      });


      w = sw / 5;
      t = t + h * 1.5;

      cSelBlack = new button(renjuCmddiv, "checkbox", w * 0, t, w, h);
      cSelBlack.show();
      cSelBlack.setText("黑先");
      cSelBlack.setChecked(1);
      cSelBlack.setontouchend(function() {
        cSelChecked(cSelBlack);
      });

      cSelWhite = new button(renjuCmddiv, "checkbox", w * 1.33, t, w, h);
      cSelWhite.show();
      cSelWhite.setText("白先");
      cSelWhite.setontouchend(function() {
        cSelChecked(cSelWhite);
      });

      cFindPoint = new button(renjuCmddiv, "select", w * 2.66, t, w, h);
      cFindPoint.addOption(0, "<<");
      cFindPoint.addOption(1, "做V点");
      cFindPoint.addOption(2, "做杀(43,冲44,冲冲抓)");
      cFindPoint.addOption(3, "活三级别");
      cFindPoint.addOption(4, "活三");
      cFindPoint.addOption(5, "❌\b三三");
      cFindPoint.addOption(6, "❌\b四四");
      cFindPoint.addOption(7, "❌\b长连");
      cFindPoint.addOption(8, "五连");
      cFindPoint.addOption(9, "活四");
      cFindPoint.addOption(10, "冲四");
      cFindPoint.addOption(11, "眠三");
      cFindPoint.show();
      cFindPoint.setText("找点");
      cFindPoint.setonchange(function(but) {
        but.setText("找点");
        if (but.input.value < 1 || vcfFinding != -1) {
          but.input.value = 0;
          return;
        }


        let arr = [];
        cBoard.getPointArray(arr);
        let newarr = getArr([]);
        switch (but.input.value * 1) {
          case 1:
            setCmd(but);

            function* vcf() {
              yield* findLevelThreePoint(arr, getRenjuSelColor(), newarr, onlyVCF, 112, false);
              callback();
            }
            generator = vcf();
            generator.next();
            break;

          case 2:
            setCmd(but);

            function* swin() {
              yield* findLevelThreePoint(arr, getRenjuSelColor(), newarr, onlySimpleWin, 112, false);
              callback();
            }
            generator = swin();
            generator.next();
            break;

          case 3:
            setCmd(but);

            function* three() {
              yield* findLevelThreePoint(arr, getRenjuSelColor(), newarr, null, 112, false);
              callback();
            }
            generator = three();
            generator.next();
            break;

          case 4:
            findThreePoint(arr, getRenjuSelColor(), newarr, onlyFree);
            cBoard.printArray(newarr, "③", "red");
            break;
          case 5:
            findTTPoint(arr, getRenjuSelColor(), newarr);
            cBoard.printArray(newarr, "❌", "red");
            break;
          case 6:
            findFFPoint(arr, getRenjuSelColor(), newarr);
            cBoard.printArray(newarr, "❌", "red");
            break;
          case 7:
            findSixPoint(arr, getRenjuSelColor(), newarr, null);
            cBoard.printArray(newarr, "❌", "red");
            break;
          case 8:
            findFivePoint(arr, getRenjuSelColor(), newarr, null);
            cBoard.printArray(newarr, "⑤", "red");
            break;
          case 9:
            findFourPoint(arr, getRenjuSelColor(), newarr, onlyFree);
            cBoard.printArray(newarr, "④", "red");
            break;
          case 10:
            findFourPoint(arr, getRenjuSelColor(), newarr, onlyNoFree);
            cBoard.printArray(newarr, "④", "black");
            break;
          case 11:
            findThreePoint(arr, getRenjuSelColor(), newarr, onlyNoFree);
            cBoard.printArray(newarr, "③", "black");
            break;
        }

        but.input.value = 0;
      });
      cFindPoint.setontouchend(function() {});
      let setCmd = function(but) {
        //msg ("","msgbox",0,cBoard.height,dw+8,dh-cBoard.height,"停止计算",null,
        //  cancelFind,null,null,"auto");
        cFindPoint.hide();
        cFindVCF.hide();
        cCancelFind.move(but.left, but.top, but.width, but.height);
      }
      let callback = function() {
        cFindPoint.show();
        cFindPoint.setText("找点");
        cFindVCF.show();
        cFindVCF.setText("解题");
        cCancelFind.hide();
        closeMsg();
      }
      let printMsg = function() {
        let fclr = cObjVCF.color == 1 ? "黑棋" : "白棋";
        console.log(cObjVCF.winMoves)
        if (cObjVCF.winMoves.length) {
          msg("✔ " + fclr + " 找到 " + cObjVCF.winMoves.length + "套 VCF,用时 " + cObjVCF.time + "秒");
        }
        else {
          msg("❌❌❌ " + fclr + " 查找VCF失败了");
        }
      }
      let createWork = function(){
        let wk = new Worker("./script/engine.js");
        wk.onmessage=function(e){
          let cmd = e.data.cmd;
          let p = e.data.parameter;
          const f = {
            "cleLb":               function(){cBoard.cleLb(p[0]);}, 
            "wLb":                 function(){cBoard.wLb(p[0],p[1],p[2]);}, 
            "printSearchPoint":    function(){cBoard.printSearchPoint(p[0],p[1],p[2]);},
            "printMoves":          function(){cBoard.printMoves(p[0],p[1]);},
            "findVCF_addVCF":      function(){
                                     cObjVCF.arr = copyArr([], p[3]);
                                     cObjVCF.winMoves = [];
                                     cObjVCF.color = p[1];
                                     cObjVCF.time = p[2];
                                     for (let i = 0; i < p[0].length; i++) { 
                                       cObjVCF.winMoves.push(p[0][i].slice(0)); 
                                     }
                                   }, 
            "findVCF_End":         function(){
                                     cObjVCF.arr = copyArr([], p[3]);
                                     cObjVCF.winMoves = [];
                                     cObjVCF.color = p[1];
                                     cObjVCF.time = p[2];
                                     for (let i = 0; i < p[0].length; i++) { 
                                       cObjVCF.winMoves.push(p[0][i].slice(0)); 
                                     }
                                     cBoard.cleLb("all");
                                     if (cObjVCF.winMoves.length) cBoard.printMoves(cObjVCF.winMoves[0] ,cObjVCF.color);
                                     callback();
                                     printMsg();
                                   }, 
            "findTwoVCF_End":      function(){callback(); }, 
          };
          wk.onerror = function(){alert("worker error");};
          console.log(cmd);
          f[cmd]();
        };
        return wk;
      };
      let work = createWork();
      let postMsg = function(cmd,param){
        console.log(cmd);
        console.log(cmd=="findTwoVCF");
        if (cmd=="cancelFind") {
          work.terminate();
          work = createWork();
          //cObjVCF = { arr: [], winMoves: [], color: 0, time: 0}; // 保存VCF分
          cBoard.cleLb("all");
          callback();
          //printMsg();
        }
        else if (cmd=="findTwoVCF") {
          let newarr = param[2];
          let color = param[1];
          let arr = param[0];
          selectPoint(arr, color, newarr, null, null, true, { level: 2 });
          findThreePoint(arr, color, newarr, onlyFree, -9999); //排除活三
          let nArr = [];
          let sPoint = [];
          for (let i=0; i<15; i++){
            for (let j=0; j<15; j++){
              if (newarr[i][j]==0) {
                sPoint.push({x:j,y:i});
                cBoard.wLb(i * 15 + j, "●", "#888888");
              } 
            }
          }
          if (sPoint.length==0) return;
          let idx=0;
          let ave=parseInt(sPoint.length/maxThread) ||  1;
          for (let i=0; i<maxThread; i++) {
            nArr[i] = getArr([],-9999);
            for (let j=idx; j<idx+ave; j++){
              if (j==sPoint.length) break;
              nArr[i][sPoint[j].y][sPoint[j].x] = 0;
            }
            idx+=ave;
            if (i==maxThread-1) {
              for (let j=idx; j<sPoint.length; j++){ 
                nArr[i][sPoint[j].y][sPoint[j].x]=0;
              }
            }
            
            let wk=createWork();
            param[2] = nArr[i];
            wk.postMessage({"cmd":cmd,parameter:param});
            
          }
        }
        else {
          work.postMessage({"cmd":cmd,parameter:param});
        }
      };

      cFindVCF = new button(renjuCmddiv, "select", w * 3.99, t, w, h);
      cFindVCF.addOption(0, "<<");
      cFindVCF.addOption(1, "快速找\b VCF");
      cFindVCF.addOption(2, "找全\b  VCF");
      cFindVCF.addOption(3, "找\b 双杀");
      cFindVCF.addOption(4, "大道五目");
      cFindVCF.addOption(5, "防\b冲四抓禁");

      cFindVCF.addOption(6, "找\b VCF防点");
      cFindVCF.addOption(7, "判断\b进攻级别");
      cFindVCF.addOption(8, "判断\b简单必胜");

      cFindVCF.show();
      cFindVCF.setText("解题");
      cFindVCF.setonchange(function(but) {
        but.setText("解题");
        if (but.input.value < 1 || vcfFinding != -1) {
          but.input.value = 0;
          return;
        }
        setCmd(but);
        let arr = [];
        cBoard.getPointArray(arr);
        // findVCF(color,timeOut,depth,count,backStage,arr,callback,callbackParameter) 
        switch (but.input.value * 1) {
          case 1:
            postMsg("findVCF",[getRenjuSelColor(),null,null,1,null,arr]);
            break;
          case 2:
            postMsg("findVCF",[getRenjuSelColor(),null,null,null,null,arr]);
            break;
          case 3:
            postMsg("findTwoVCF", [arr, getRenjuSelColor(), getArr([])]);
            break;
          case 7:
            function* g() {
              let level = (yield* getLevelB(arr, 1, getArr([]), 25000, null, false)).level;
              let level2 = (yield* getLevelB(arr, 2, getArr([]), 25000, null, false)).level;
              let str = "";
              if (level > 2) {
                str = "黑进攻级别  =  " + levelToStr(level) + "\n";
              }
              if (level2 > 2) {
                str += "白进攻级别  =  " + levelToStr(level2) + "\n";
              }
              if (str == "") {
                str = "黑,白进攻级别  =  " + levelToStr(level) + "\n";
                if (isWin(1, arr) && isWin(2, arr)) str = "❌❌❌黑白都有五连❌❌❌";
              }
              callback();
              msg(str);
            }

            function levelToStr(level) {
              switch (level) {
                case 5:
                  return "胜";
                case 4.5:
                  return "冲四";
                case 4:
                  return "冲四";
                case 3:
                  return "活三级别";
                default:
                  return "小于活三级别";
              }
            }
            generator = g();
            generator.next();
            break;
          case 6:
            function* gbf() {
              if (yield* findVCF(getRenjuSelColor(), null, null, 1, null, copyArr([], arr))) {
                let p = yield* getBlockVCFb(vcfWinMoves, vcfColor, arr, false);
                if (!p) msg("❌❌❌没有成立的防点");
              }
              else {
                msg("❌❌❌没有VCF");
              }
              callback();
            }
            generator = gbf();
            generator.next();
            break
          case 5:
            function* bcf() {
              let r = yield* blockCatchFoul(arr);
              callback();
              if (r == -1) {
                msg("❌❌❌ 没有找到冲四抓禁 ❌❌❌");
              }
              else if (r == 0) {
                msg("❌❌❌ 没有成立的解禁点 ❌❌❌");
              }
            }
            generator = bcf();
            generator.next();
            break;
          case 8:
            function* gwl() {
              let lvl = yield* getWinLevel(arr, getRenjuSelColor());
              let str = getRenjuSelColor() == 1 ? "黑棋" : "白棋";
              str += winToStr(lvl);
              callback();
              msg(str);
            }
            generator = gwl();
            generator.next();

            function winToStr(level) {
              switch (level) {
                case 5:
                  return "已胜";
                case 4.5:
                  return "活4级必胜(44，冲四抓)";
                case 4.4:
                  return "VCF必胜";
                case 3.5:
                  return "33级必胜(双杀)";
                default:
                  return "没有找到33以上的必胜";
              }
            }
            break;
          case 4:
            function* sp() {
              if (!(yield* findSimpleWin(arr, getRenjuSelColor(), getArr([]), 4))) {
                msg("❌❌❌没有两手43胜❌❌❌");
              }
              callback();
            }
            generator = sp();
            generator.next();

            break;
        }
        but.input.value = 0;

      });
      cFindVCF.setontouchend(function() {});


      cCancelFind = new button(renjuCmddiv, "button", w * 3.99, t, w, h);
      //cCancelFind.show();
      cCancelFind.setText("停止");
      cCancelFind.setontouchend(function(but) {
        postMsg("cancelFind");
      });



      t = t + h * 1.5;

      cAutoadd = new button(renjuCmddiv, "radio", 0, t, w, h);
      cAutoadd.show();
      cAutoadd.setText("\b◐\b棋");
      cAutoadd.setChecked(1);
      cAutoadd.setontouchend(function() {
        nSetChecked(cAutoadd);
      });

      cAddblack = new button(renjuCmddiv, "radio", w * 1.33, t, w, h);
      cAddblack.show();
      cAddblack.setText("\b●\b棋");
      cAddblack.setontouchend(function() {
        nSetChecked(cAddblack);
      });

      cAddwhite = new button(renjuCmddiv, "radio", w * 2.66, t, w, h);
      cAddwhite.show();
      cAddwhite.setText("\b○\b棋");
      cAddwhite.setontouchend(function() {
        nSetChecked(cAddwhite);
      });

      cPrintVCF = new button(renjuCmddiv, "select", w * 3.99, t, w, h);
      cPrintVCF.addOption(0, "<<");
      cPrintVCF.addOption(1, "第1套VCF");
      cPrintVCF.addOption(2, "第2套VCF");
      cPrintVCF.addOption(3, "第3套VCF");
      cPrintVCF.addOption(4, "第4套VCF");
      cPrintVCF.addOption(5, "第5套VCF");
      cPrintVCF.addOption(6, "第6套VCF");
      cPrintVCF.addOption(7, "第7套VCF");
      cPrintVCF.addOption(8, "第8套VCF");
      cPrintVCF.show();
      cPrintVCF.setText("➩\b VCF \b");
      cPrintVCF.setonchange(function(but) {
        but.setText("➩\b VCF \b");
        if (but.input.value) {
          let color = getRenjuSelColor();
          let arr = cBoard.getPointArray([]);
          if (color == cObjVCF.color && bArr(arr, cObjVCF.arr)) {
            if (cObjVCF.winMoves.length >= but.input.value) {
              let moves = cObjVCF.winMoves[but.input.value - 1].slice(0, cObjVCF.winMoves[but.input.value - 1].length);
              cBoard.printMoves(moves, cObjVCF.color);
              cBoard.wLb(moves[moves.length - 1], moves.length, "red");
            }
            else {
              let str = `\b${color==1?"黑棋":"白棋"}\b只找到\b${cObjVCF.winMoves.length} 套\bVCF\b记录`;
              msg(str);
            }
          }
          else {
            let str = `请先\b找全\b${color==1?"黑棋":"白棋"}\bVCF`;
            msg(str);
          }
          but.input.value = 0;
        }

        function bArr(arr, arr2) { //判断两个arr是否相等
          if (arr2.length) {
            for (let y = 0; y < 15; y++) {
              for (let x = 0; x < 15; x++) {
                if (arr[y][x] != arr2[y][x]) return false;
              }
            }
            return true;
          }
          return false;
        }
      });





      t = t + h * 1.5;


      cLba = new button(renjuCmddiv, "radio", w * 0, t, w, h);
      cLba.show();
      cLba.setText("\b ■ \b");
      cLba.setontouchend(function() {
        nSetChecked(cLba);
      });

      cLbb = new button(renjuCmddiv, "radio", w * 1.33, t, w, h);
      cLbb.show();
      cLbb.setText("\b◎\b");
      cLbb.setontouchend(function() {
        nSetChecked(cLbb);
      });

      cLABC = new button(renjuCmddiv, "select", w * 2.66, t, w, h);
      cLABC.addOption(0, "ABC...");
      cLABC.addOption(1, "abc...");
      cLABC.addOption(2, "123...");
      cLABC.addOption(3, "☆标记");
      cLABC.show();
      cLABC.setontouchstart(function() {
        nSetChecked(cLABC);
      });

      cNextone = new button(renjuCmddiv, "button", w * 3.99, t, w, h);
      cNextone.show();
      cNextone.setColor("black");
      cNextone.setText(" 下手为❶");
      cNextone.setontouchend(function() {
        cBoard.setResetNum(cBoard.MSindex + 1);
      });



      t = t + h * 1.5;


      cLbc = new button(renjuCmddiv, "radio", w * 0, t, w, h);
      cLbc.show();
      cLbc.setText("\b ▲\b");
      cLbc.setontouchend(function() {
        nSetChecked(cLbc);
      });


      cLbd = new button(renjuCmddiv, "radio", w * 1.33, t, w, h);
      cLbd.show();
      cLbd.setText("\b ✖\b");
      cLbd.setontouchend(function() {
        nSetChecked(cLbd);
      });

      cLbColor = new button(renjuCmddiv, "select", w * 2.66, t, w, h);
      cLbColor.addOption(0, "黑色标记");
      cLbColor.addOption(1, "绿色标记");
      cLbColor.addOption(2, "红色标记");
      cLbColor.show();
      cLbColor.setText("✎\b颜色");
      cLbColor.setonchange(function(but) {
        but.setColor(lbColor[but.input.value]);
        but.setText("✎\b颜色");
        cLba.setColor(lbColor[but.input.value]);
        cLbb.setColor(lbColor[but.input.value]);
        cLbc.setColor(lbColor[but.input.value]);
        cLbd.setColor(lbColor[but.input.value]);
        cLABC.setColor(lbColor[but.input.value]);
      });

      cResetnum = new button(renjuCmddiv, "button", w * 3.99, t, w, h);
      cResetnum.show();
      cResetnum.setColor("black");
      cResetnum.setText(" 重置手数");
      cResetnum.setontouchend(function() {
        cBoard.setResetNum(0);
        cShownum.setChecked(true);
      });




      t = t + h * 1.5;

      cInputcode = new button(renjuCmddiv, "button", w * 0, t, w, h);
      cInputcode.show();
      cInputcode.setColor("black");
      cInputcode.setText("输入代码");
      let inputCode = function(msgStr) {
        // 成功设置棋盘 ，就开始解析棋盘摆盘
        let st = 0;
        let end = msgStr.indexOf("{");
        end = end == -1 ? msgStr.length : end;
        let moves;
        let blackMoves;
        let whiteMoves;
        moves = cBoard.setMoves(msgStr.slice(st, end));
        st = end + 1;
        end = msgStr.indexOf("}{", st);
        end = end == -1 ? msgStr.length : end;
        blackMoves = cBoard.setMoves(msgStr.slice(st, end));
        st = end + 2;
        end = msgStr.length;
        whiteMoves = cBoard.setMoves(msgStr.slice(st, end));
        if (moves || blackMoves || whiteMoves) {
          cBoard.cle();
          cBoard.resetNum = 0;
          if (moves) cBoard.unpackMoves(cShownum.checked, "auto", moves);
          if (blackMoves) cBoard.unpackMoves(cShownum.checked, "black", blackMoves);
          if (whiteMoves) cBoard.unpackMoves(cShownum.checked, "white", whiteMoves);
        }
      }
      cInputcode.setontouchend(function() {
        let w = cBoard.width * 0.8;
        let h = w;
        let l = (dw - w) / 2;
        let t = (dh - dw) / 4;
        t = t < 0 ? 1 : t;
        msg("长按下面空白区域，粘贴棋谱代码 " + "\n" + "-------------" + "\n\n", "input", l, t, w, h, "输入代码", null,
          inputCode, null, null, 10);
      });

      cOutputcode = new button(renjuCmddiv, "button", w * 1.33, t, w, h);
      cOutputcode.show();
      cOutputcode.setColor("black");
      cOutputcode.setText("输出代码");
      cOutputcode.setontouchend(function() {
        let w = cBoard.width * 0.8;
        let h = w;
        let l = (dw - w) / 2;
        let t = (dh - dw) / 4;
        t = t < 0 ? 1 : t;
        let code = cBoard.getMoves();
        code += "\n{" + cBoard.getMoves(tBlack) + "}";
        code += "{" + cBoard.getMoves(tWhite) + "}";
        code = code == "" ? "空棋盘没有棋盘代码" : code;
        msg(code + "\n\n\n" + "-------------" + "\n" + "长按上面代码，复制棋谱代码 ", "input", l, t, w, h, "输入代码", null,
          inputCode, null, null, 10);
      });

      cLoadImg = new button(renjuCmddiv, "file", w * 2.66, t, w, h);
      cLoadImg.show();
      cLoadImg.input.accept = "image/*";
      cLoadImg.setText("输入图片");
      cLoadImg.setonchange(function() {
        let reader = new FileReader();
        let file = cLoadImg.input.files[0];
        cLoadImg.input.value = "";
        let img = cBoard.bakImg;
        img.src = null;
        reader.readAsDataURL(file);
        reader.onload = function() {
          img.src = reader.result;
        }
        img.onload = function() {
          img.onload = null;
          putImg();
        }
      });

      function putImg() {
        let img = cBoard.bakImg;
        let w = parseInt(img.width);
        let h = parseInt(img.height);
        let w1 = cBoard.width;
        let h1 = cBoard.width * h / w;
        let h2 = cBoard.canvas.height;
        cBoard.cle();
        // 画图之前，设置画布大小
        cBoard.canvas.width = w1;
        cBoard.canvas.height = h1;
        cBoard.canvas.style.width = w1+"px";
        cBoard.canvas.style.height = h1+"px";
        let ctx = cBoard.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h, w1 / 13, h1 / 13, w1 / 13 * 11, h1 / 13 * 11);
        parentNode.style.top = h1 + parentNode.offsetTop - h2+"px";
        cBoard.resetCutDiv();
        parentNode.removeChild(renjuCmddiv);
        parentNode.appendChild(imgCmdDiv);
        playModel = imgModel;
        cLockImg.setChecked(0);
        cAddblack2.setChecked(1);
        cAddwhite2.setChecked(0);
        cSLTX.input.value = cBoard.SLTX;
        cSLTX.setText(cSLTX.input.value + "\b列");
        cSLTY.input.value = cBoard.SLTY;
        cSLTY.setText(cSLTY.input.value + "\b行");
        ctx = null;
        viewport.userScalable();
      }

      cCutImage = new button(renjuCmddiv, "select", w * 3.99, t, w, h);
      cCutImage.addOption(0, "<<");
      cCutImage.addOption(1, "JPEG/(*.jpg)__压缩");
      cCutImage.addOption(2, "PNG/(*.png)__清晰");
      cCutImage.addOption(3, "SVG/(*.svg)__矢量,无损");
      cCutImage.addOption(4, "SVG/(*.svg.html__矢量，无损");
      cCutImage.addOption(5, "PDF/(*.pdf)__矢量，无损");
      cCutImage.show();
      cCutImage.setText("✄\b截图");
      cCutImage.setonchange(function(but) {
        but.setText("✄\b截图");
        switch (but.input.value * 1) {
          case 1:
            cBoard.saveAsImage("jpeg");
            break;
          case 2:
            cBoard.saveAsImage("png");
            break;
          case 3:
            cBoard.saveAsSVG("svg");
            break;
          case 4:
            cBoard.saveAsSVG("html");
            break;
          case 5:
            cBoard.saveAsPDF();
            break;
        }
        but.input.value = 0;
      });


      t = t + h * 1.3;


      function cSelChecked(chk) {
        cSelBlack.setChecked(0);
        cSelWhite.setChecked(0);
        chk.setChecked(1);
      }



      function nSetChecked(chk) {
        cLba.setChecked(0);
        cLbb.setChecked(0);
        cLbc.setChecked(0);
        cLbd.setChecked(0);
        cAutoadd.setChecked(0);
        cAddblack.setChecked(0);
        cAddwhite.setChecked(0);
        cLABC.setChecked(0);
        chk.setChecked(1);
      }


    }





    function createImgCmdDiv(parentNode, left, top, width, height) {

      imgCmdDiv = document.createElement("div");
      let s = imgCmdDiv.style;
      //parentNode.appendChild(imgCmdDiv);
      s.position = "absolute";
      s.width = width / 1.15+"px";
      s.height = width+"px";
      s.top = parseInt(top)+"px";
      s.left = (dw - parseInt(s.width)) / 2+"px";
      if (dw > dh) s.left = (dw - cWidth * 2) / 2+"px";

      let sw = parseInt(s.width);
      let w = sw / 5;
      let h = sw / 9 / 1.5;
      let t = 0;

      cLockImg = new button(imgCmdDiv, "checkbox", w * 0, t, w, h);
      cLockImg.show();
      cLockImg.setText("选定棋盘");
      cLockImg.setontouchend(function() {
        if (cLockImg.checked) {
          lockImg();
        }
        else {
          putImg();
          return;
        }
      });

      function putImg() {
        let img = cBoard.bakImg;
        let w = parseInt(img.width);
        let h = parseInt(img.height);
        let w1 = cBoard.width;
        let h1 = cBoard.width * h / w;
        let h2 = cBoard.canvas.height;
        cBoard.cle();
        // 画图之前，设置画布大小
        cBoard.canvas.width = w1;
        cBoard.canvas.height = h1;
        cBoard.canvas.style.width = w1+"px";
        cBoard.canvas.style.height = h1+"px";
        let ctx = cBoard.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h, w1 / 13, h1 / 13, w1 / 13 * 11, h1 / 13 * 11);
        parentNode.style.top = h1 + parentNode.offsetTop - h2+"px";
        cBoard.resetCutDiv();
        ctx = null;
        viewport.userScalable();
      }

      function lockImg(generator) {

        let div = cBoard.cutDiv;
        let w = parseInt(cBoard.cutDiv.style.width);
        let h = parseInt(cBoard.cutDiv.style.height);
        let w2 = w / 11 * 13;
        let h2 = h / 11 * 13;
        let l = div.offsetLeft - w / 11 > 0 ? div.offsetLeft - w / 11 : 0;
        let t = div.offsetTop - h / 11 > 0 ? div.offsetTop - h / 11 : 0;
        let L2 = l > 0 ? 0 : w / 11 - div.offsetLeft;
        let t2 = t > 0 ? 0 : h / 11 - div.offsetTop;
        //alert(`div.offsetLeft${div.offsetLeft},div.offsetTop${div.offsetTop}`)
        cBoard.bakCanvas.width = w2;
        cBoard.bakCanvas.height = h2;
        cBoard.bakCanvas.style.width = w2+"px";
        cBoard.bakCanvas.style.height = h2+"px";

        let ctx = cBoard.bakCanvas.getContext("2d");
        ctx.fillStyle = cBoard.backgroundColor;
        ctx.fillRect(0, 0, w2, h2);
        cBoard.cutImg.src = cBoard.bakCanvas.toDataURL("image/png");

        cBoard.cutImg.onload = function() {
          cBoard.cutImg.onload = null;
          let w3 = parseInt(cBoard.canvas.width) - div.offsetLeft;
          w3 = w3 < w / 11 * 12 ? w : w / 11 * 12;
          w3 += l == 0 ? div.offsetLeft : w / 11;
          let h3 = parseInt(cBoard.canvas.height) - div.offsetTop;
          h3 = h3 < h / 11 * 12 ? h : h / 11 * 12;
          h3 += t == 0 ? div.offsetTop : h / 11;
          ctx.drawImage(cBoard.canvas, l, t, w3, h3, L2, t2, w3, h3);
          cBoard.cutImg.src = cBoard.bakCanvas.toDataURL("image/png");

          cBoard.cutImg.onload = function() {
            cBoard.cutImg.onload = null;
            ctx = cBoard.canvas.getContext("2d");

            h = parseInt(cBoard.canvas.height);
            cBoard.canvas.height = parseInt(cBoard.width) * h2 / w2;
            cBoard.canvas.style.height = parseInt(cBoard.width) * h2 / w2+"px";
            ctx.drawImage(cBoard.cutImg, 0, 0, w2, h2, 0, 0, parseInt(cBoard.width), parseInt(cBoard.width) * h2 / w2);

            cBoard.XL = parseInt(cBoard.canvas.width) / 13;
            cBoard.XR = parseInt(cBoard.canvas.width) / 13 * 12;
            cBoard.YT = parseInt(cBoard.canvas.height) / 13;
            cBoard.YB = parseInt(cBoard.canvas.height) / 13 * 12;
            cBoard.resetP(cBoard.XL, cBoard.XR, cBoard.YT, cBoard.YB);
            parentNode.style.top = parseInt(cBoard.canvas.height) + parentNode.offsetTop - h+"px";

            cBoard.cleAllPointBorder();
            cBoard.hideCutDiv();
            ctx = null;
            if (generator) generator.next();
            viewport.resize();
            /*
            cBoard.parentNode.appendChild(cBoard.bakCanvas);
            cBoard.bakCanvas.style.top = 2000;
            cBoard.parentNode.appendChild(cBoard.cutImg);
            cBoard.cutImg.style.top = 1500;
            */
          }
        }

      }

      cAutoPut = new button(imgCmdDiv, "button", w * 1.33, t, w, h);
      cAutoPut.show();
      cAutoPut.setColor("black");
      cAutoPut.setText(" 自动识别");
      cAutoPut.setontouchend(function() {
        generator = autoPut();
        if (!cLockImg.checked) {
          lockImg(generator);
          cLockImg.setChecked(1);
        }
        else {
          generator.next();
        }
      });

      function* autoPut() {
        let arr = getArr([], 0, cBoard.SLTX, cBoard.SLTY);
        let max = 0;
        let min = 255;
        let timeout = 120;
        let cNum;
        let rgb;
        let idx;
        let wBoard = true; // 默认白色棋盘
        let sTime;
        setTimeout(function() { generator.next(); }, 500);
        yield; //浏览器空闲再测速
        sTime = new Date().getTime();
        cBoard.getPointColor(0); // 测速
        if ((new Date().getTime() - sTime) > timeout) {
          msg("您使用的浏览器运行速度太慢，不适合使用自动扫描");
          return;
        }
        msg("正在扫描棋盘......", null, null, null, null, null, null, null, null, null, 0);
        for (let i = cBoard.SLTY - 1; i >= 0; i--) {
          for (let j = cBoard.SLTX - 1; j >= 0; j--) {
            idx = i * cBoard.SLTX + j;
            cBoard.P[idx].printLb("★", "green", cBoard.gW, cBoard.gH);
            rgb = cBoard.getPointColor(idx);
            //alert(rgb.r+"\n"+rgb.g+"\n"+rgb.b);
            cNum = (rgb.r + rgb.g + rgb.b) / 3;
            // 黑，白以外-1000，表示空子。
            if (Math.abs(rgb.r - rgb.g) < 60 && Math.abs(rgb.r - rgb.b) < 60 && Math.abs(rgb.g - rgb.b) < 60) {
              arr[i][j] = cNum;
              max = cNum > max ? cNum : max; // 设置最白，最黑
              min = cNum < min ? cNum : min;
            }
            else {
              arr[i][j] = -1000;
              wBoard = false;
            }
            setTimeout(function() { generator.next(); }, 0);
            yield;
            cBoard.P[idx].cle();
          }
        }
        closeMsg();
        nSetChecked(cAddwhite2); // 选定白棋按钮，方便修改
        for (let i = cBoard.SLTY - 1; i >= 0; i--) {
          for (let j = cBoard.SLTX - 1; j >= 0; j--) {
            idx = i * cBoard.SLTX + j;
            if (Math.abs(arr[i][j] - max) < (wBoard || max > 250 ? 20 : 50)) {
              //arr[i][j] = 2;
              cBoard.P[idx].printNb("★", "white", cBoard.gW, cBoard.gH);
            }
            else if (Math.abs(arr[i][j] - min) < (wBoard || min < 5 ? 30 : 60)) {
              //arr[i][j] = 1;
              cBoard.P[idx].printNb("★", "black", cBoard.gW, cBoard.gH);
            }
            else if (timeout > 1000) {
              cBoard.P[idx].printNb("▲", "black", cBoard.gW, cBoard.gH);
            }
          }
        }
      }

      cPutBoard = new button(imgCmdDiv, "button", w * 2.66, t, w, h);
      cPutBoard.show();
      cPutBoard.setColor("black");
      cPutBoard.setText(" 摆入棋盘");
      cPutBoard.setontouchend(function() {
        if (cBoard.SLTX == 15 && cBoard.SLTY == 15) {
          putBoard();
        }
        else {
          msg("小棋盘,长按 H8(天元) 定位到15路棋盘");
        }
      });
      putCheckerBoard = putBoard;

      function putBoard(idx) {
        if (idx < 0) return;
        let arr = cBoard.getPointArray([]);
        let h1 = parseInt(cBoard.width);
        let h2 = parseInt(cBoard.canvas.height);
        cBoard.cle();
        cBoard.printCheckerBoard();
        cBoard.hideCutDiv();
        parentNode.style.top = h1 + parentNode.offsetTop - h2+"px";
        parentNode.removeChild(imgCmdDiv);
        parentNode.appendChild(renjuCmddiv);
        playModel = renjuModel;
        cBoard.unpackArray(changeCoordinate(arr, idx));
        viewport.resize();
      }

      function changeCoordinate(arr, idx) {
        let nArr = getArr([]);
        idx = idx || 112;
        let l = 7 - parseInt(idx % arr[0].length);
        l = l < 0 ? 0 : l;
        l = l + arr[0].length > 15 ? 15 - arr[0].length : l;
        let t = 7 - parseInt(idx / arr.length);
        t = t < 0 ? 0 : t;
        t = t + arr.length > 15 ? 15 - arr.length : t;
        for (let i = 0; i < arr.length; i++) {
          for (let j = 0; j < arr[i].length; j++) {
            nArr[i + t][j + l] = arr[i][j];
          }
        }
        return nArr;
      }

      cCleAll = new button(imgCmdDiv, "button", w * 3.99, t, w, h);
      cCleAll.show();
      cCleAll.setColor("black");
      cCleAll.setText(" 清空棋盘");
      cCleAll.setontouchend(function() {
        for (let i = cBoard.SLTX * cBoard.SLTY - 1; i >= 0; i--) cBoard.P[i].cle();
      });


      t = t + h * 1.5;

      cAddblack2 = new button(imgCmdDiv, "radio", w * 0, t, w, h);
      cAddblack2.show();
      cAddblack2.setText("\b●\b棋");
      cAddblack2.setontouchend(function() {
        nSetChecked(cAddblack2);
      });

      cAddwhite2 = new button(imgCmdDiv, "radio", w * 1.33, t, w, h);
      cAddwhite2.show();
      cAddwhite2.setText("\b○\b棋");
      cAddwhite2.setontouchend(function() {
        nSetChecked(cAddwhite2);
      });


      cSLTY = new button(imgCmdDiv, "select", w * 2.66, t, w, h);
      for (let i = 15; i >= 5; i--) {
        cSLTY.addOption(i, i);
      }
      cSLTY.show();
      cSLTY.setText(cSLTY.input.value + "\b行");
      cSLTY.setonchange(function(but) {
        but.setText(but.input.value + "\b行");
        cBoard.SLTY = but.input.value;
        cBoard.resetP(cBoard.XL, cBoard.XR, cBoard.YT, cBoard.YB);
        if (!cLockImg.checked) {
          cBoard.cleAllPointBorder();
          cBoard.printBorder();
        }
        else {
          cLockImg.setChecked(0);
          putImg();
        }
      });

      cSLTX = new button(imgCmdDiv, "select", w * 3.99, t, w, h);
      for (let i = 15; i >= 5; i--) {
        cSLTX.addOption(i, i);
      }
      cSLTX.show();
      cSLTX.setText(cSLTX.input.value + "\b列");
      cSLTX.setonchange(function(but) {
        but.setText(but.input.value + "\b列");
        cBoard.SLTX = but.input.value;
        cBoard.resetP(cBoard.XL, cBoard.XR, cBoard.YT, cBoard.YB);
        if (!cLockImg.checked) {
          cBoard.cleAllPointBorder();
          cBoard.printBorder();
        }
        else {
          cLockImg.setChecked(0);
          putImg();
        }
      });


      function nSetChecked(chk) {
        cAddblack2.setChecked(0);
        cAddwhite2.setChecked(0);
        chk.setChecked(1);
        if (!cLockImg.checked) { lockImg();
          cLockImg.setChecked(1) }
      }
    }












    //返回参数确认 添加棋子 还是标签
    function getRenjuCmd() {

      let isShow = cShownum.checked ? true : false;
      let idx;
      let code;
      let tcode;
      let txt;
      switch (true) {

        case cAutoadd.checked:
          return { type: tNum, cmd: "auto", showNum: isShow };
        case cAddblack.checked:
          return { type: tBlack, cmd: "black", showNum: isShow };
        case cAddwhite.checked:
          return { type: tWhite, cmd: "white", showNum: isShow };
        case cLba.checked:
          return { type: tLb, cmd: "■", showNum: isShow };
        case cLbb.checked:
          return { type: tLb, cmd: "◎", showNum: isShow };
        case cLbc.checked:
          return { type: tLb, cmd: "▲", showNum: isShow };
        case cLbd.checked:
          return { type: tLb, cmd: "✖", showNum: isShow };
        case cLABC.checked:

          switch (cLABC.input.value * 1) {
            case 0:
              // 搜索棋盘上最大的字母;
              code = "A".charCodeAt(); // 65→90
              for (idx = 0; idx < cBoard.SLTX * cBoard.SLTY; idx++) {
                if (cBoard.P[idx].type == tLb && cBoard.P[idx].text.length == 1) {
                  let tcode = cBoard.P[idx].text.charCodeAt(0);
                  if (tcode >= code && tcode <= 90) {
                    code = tcode < 90 ? tcode + 1 : tcode;
                  }
                }
              }
              txt = String.fromCharCode(code);
              return { type: tLb, cmd: txt, showNum: isShow };

            case 1:

              // 搜索棋盘上最大的字母;
              code = "a".charCodeAt(); // 65→90
              for (idx = 0; idx < cBoard.SLTX * cBoard.SLTY; idx++) {
                if (cBoard.P[idx].type == tLb && cBoard.P[idx].text.length == 1) {
                  tcode = cBoard.P[idx].text.charCodeAt(0);
                  if (tcode >= code && tcode <= 122) {
                    code = tcode < 122 ? tcode + 1 : tcode;
                  }
                }
              }
              txt = String.fromCharCode(code);
              return { type: tLb, cmd: txt, showNum: isShow };

            case 2:
              // 搜索棋盘上最大的数字
              code = 1 // 1-225;
              for (idx = 0; idx < cBoard.SLTX * cBoard.SLTY; idx++) {
                if (cBoard.P[idx].type == tLb) {
                  tcode = cBoard.P[idx].text * 1;
                  if (tcode >= code && tcode <= 225) {
                    code = tcode < 225 ? tcode + 1 : tcode;
                  }
                }
              }
              txt = code;
              return { type: tLb, cmd: txt, showNum: isShow };
            case 3:
              return { type: tLb, cmd: "☆", showNum: isShow };
          }
      }
    
    }




    function getRenjuLbColor() {

      return lbColor[cLbColor.input.value];
    }



    function getRenjuSelColor() {
      return cSelBlack.checked ? 1 : 2;
    }




    let timerCancelKeepTouch = null; // 防止悔棋触发取消红色显示
    let cancelKeepTouck = function() {
      if (timerCancelKeepTouch) return true;
      timerCancelKeepTouch = setTimeout("timerCancelKeepTouch=null", 800);
    }



    function renjuClick(x, y) {

      let idx = cBoard.getPIndex(x, y);

      if (idx > -1) {

        let cmds = getRenjuCmd();
        switch (cmds.type) {
          case tNum:
            cancelKeepTouck();
            if (cBoard.P[idx].type == tNum) {
              //点击棋子，触发悔棋
              cBoard.cleNb(idx, cmds.showNum);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加棋子  wNb(idx,color,showNum)
              cBoard.wNb(idx, "auto", cmds.showNum);
            }
            break;

          case tBlack:
            if (cBoard.P[idx].type == tWhite || cBoard.P[idx].type == tBlack) {
              //点击棋子，触发悔棋
              cBoard.clePoint(idx);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加棋子  wNb(idx,color,showNum)
              cBoard.wNb(idx, "black", cmds.showNum);
            }
            break;

          case tWhite:
            if (cBoard.P[idx].type == tWhite || cBoard.P[idx].type == tBlack) {
              //点击棋子，触发悔棋
              cBoard.clePoint(idx);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加棋子  wNb(idx,color,showNum)
              cBoard.wNb(idx, "white", cmds.showNum);
            }
            break;

          case tLb:
            if (cBoard.P[idx].type == tLb) {
              // 点击标记，删除标记
              cBoard.clePoint(idx);
            }
            else if (cBoard.P[idx].type == tEmpty) {
              // 添加标记 wLb(idx,text,color, showNum:isShow) 
              cBoard.wLb(idx, cmds.cmd, getRenjuLbColor());
            }
            break;
        }

      }

    }




    function renjuDblClick(x, y) {

      let idx = cBoard.getPIndex(x, y);
      if (idx > -1) {
        // 触发快速悔棋
        if (cBoard.P[idx].type == tNum) {
          if (idx != cBoard.MS[cBoard.MSindex]) {
            for (let i = cBoard.MSindex + 1; i > parseInt(cBoard.P[idx].text); i--) {
              cBoard.cleNb(idx, cShownum.checked);
            }
          }
          else { // 
            if (!cancelKeepTouck()) renjuKeepTouch(x, y);
          }
        } // 触发，手动输入标记
        else if ((cBoard.P[idx].type == tLb || cBoard.P[idx].type == tEmpty) && !cAutoadd.checked && !cAddblack.checked && !cAddwhite.checked) {
          inputLabel(idx);
        }

      }
    }




    function renjuKeepTouch(x, y) {

      let idx = cBoard.getPIndex(x, y);
      if (idx < 0) return;
      let w = cBoard.width * 0.8;
      let h;
      let l = (dw - w) / 2;
      let t = dh / 7;

      switch (cBoard.P[idx].type) {
        case tNum:
          if (idx == cBoard.MS[cBoard.MSindex]) {
            let str = cBoard.notShowLastNum ? "确认恢复 最后一手红色显示。" : "确认取消 最后一手红色显示。";
            msg(str, null, null, null, null, null, null, null, function() {

              if (cBoard.setNotShowLastNum(idx)) {
                if (cShownum.checked) {
                  cBoard.showNum();
                }
                else {
                  cBoard.hideNum();
                }
              }
            }, null, 2);
          }
          break;
        case tLb:
          // 设置弹窗，让用户手动输入标记
          inputLabel(idx);
          break;
        case tEmpty:
          // 设置弹窗，让用户手动输入标记
          inputLabel(idx);
          break;

      }

    }
    
    function inputLabel(idx){
      let w = cBoard.width * 0.8;
      let h;
      let l = (dw - w) / 2;
      let t = dh / 7;
      let color = getRenjuLbColor();
      // 设置弹窗，让用户手动输入标记
      msg("", "input", l, t, w, h, "输入标记", null, function(msgStr) {
        let str = msgStr.substr(0, 3);
        cBoard.clePoint(idx); // 清除原来标记，打印用户选定的标记
        if (str!="" && str!=" ") cBoard.wLb(idx, str, color);
      },
      function(msgStr) { //用户取消，删除标记
        //cBoard.clePoint(idx);
      });
    }




    function renjucShownumClick() {

      if (cShownum.checked) {
        cBoard.showNum();
      }
      else {
        cBoard.hideNum();
      }
    }
  </script>
  <script language="javascript">
    "use strict";
    let timerSave = null; // 保存,定时器

    function renjuSave() {

      if (timerSave) { // 如果之前的保存计划还没开始 取消计划。
        clearTimeout(timerSave);
      }
      // 预定保存点击，
      timerSave = setTimeout(function() {

        let moves = cBoard.getMoves();
        let whiteMoves = cBoard.getMoves(tWhite);
        let blackMoves = cBoard.getMoves(tBlack);
        if (moves != "" || whiteMoves != "" || blackMoves != "") {
          localStorage.setItem("moves", moves);
          localStorage.setItem("whiteMoves", whiteMoves);
          localStorage.setItem("blackMoves", blackMoves);
          localStorage.setItem("resetNum", cBoard.resetNum);
          timerSave = null;
          //log("保存棋谱:" + moves);
        }

      }, 5000);
    }




    function renjuLoad() {

      setTimeout(function() {
        let resetNum = localStorage.getItem("resetNum");
        let moves = localStorage.getItem("moves");
        let whiteMoves = localStorage.getItem("whiteMoves");
        let blackMoves = localStorage.getItem("blackMoves");
        if (parseInt(resetNum) > 0) cBoard.resetNum = parseInt(resetNum);
        if (cBoard.setMoves(moves)) cBoard.unpackMoves(true);
        if (whiteMoves != "") cBoard.unpackMoves(true, "white", whiteMoves);
        if (blackMoves != "") cBoard.unpackMoves(true, "black", blackMoves);

      }, 300);
    }
  </script>

</body>

</html>